// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Describes one specific validation failure for an input member.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ValidationExceptionField {
    /// A JSONPointer expression to the structure member whose value failed to satisfy the modeled constraints.
    pub path: ::std::string::String,
    /// A detailed description of the validation failure.
    pub message: ::std::string::String,
}
impl ValidationExceptionField {
    /// A JSONPointer expression to the structure member whose value failed to satisfy the modeled constraints.
    pub fn path(&self) -> &str {
        use std::ops::Deref;
        self.path.deref()
    }
    /// A detailed description of the validation failure.
    pub fn message(&self) -> &str {
        use std::ops::Deref;
        self.message.deref()
    }
}
impl ValidationExceptionField {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder {
        crate::model::validation_exception_field::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct FlavorText {
    /// The localized flavor text for an API resource in a specific language.
    pub flavor_text: ::std::string::String,
    /// The language this name is in.
    pub language: crate::model::Language,
}
impl FlavorText {
    /// The localized flavor text for an API resource in a specific language.
    pub fn flavor_text(&self) -> &str {
        use std::ops::Deref;
        self.flavor_text.deref()
    }
    /// The language this name is in.
    pub fn language(&self) -> &crate::model::Language {
        &self.language
    }
}
impl FlavorText {
    /// Creates a new builder-style object to manufacture [`FlavorText`](crate::model::FlavorText).
    pub fn builder() -> crate::model::flavor_text::Builder {
        crate::model::flavor_text::Builder::default()
    }
}

/// Supported languages for FlavorText entries.
#[derive(
    ::std::clone::Clone,
    ::std::cmp::Eq,
    ::std::cmp::Ord,
    ::std::cmp::PartialEq,
    ::std::cmp::PartialOrd,
    ::std::fmt::Debug,
    ::std::hash::Hash,
)]
pub enum Language {
    /// American English.
    English,
    /// Español.
    Spanish,
    /// Italiano.
    Italian,
    /// 日本語。
    Japanese,
}
/// See [`Language`](crate::model::Language).
pub mod language {
    #[derive(Debug, PartialEq)]
    pub struct ConstraintViolation(pub(crate) ::std::string::String);

    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(
                f,
                r#"Value provided for 'com.aws.example#Language' failed to satisfy constraint: Member must satisfy enum value set: [en, es, it, jp]"#
            )
        }
    }

    impl ::std::error::Error for ConstraintViolation {}
}
impl ::std::convert::TryFrom<&str> for Language {
    type Error = crate::model::language::ConstraintViolation;
    fn try_from(
        s: &str,
    ) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
        match s {
            "en" => Ok(Language::English),
            "es" => Ok(Language::Spanish),
            "it" => Ok(Language::Italian),
            "jp" => Ok(Language::Japanese),
            _ => Err(crate::model::language::ConstraintViolation(s.to_owned())),
        }
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Language {
    type Error = crate::model::language::ConstraintViolation;
    fn try_from(
        s: ::std::string::String,
    ) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error>
    {
        s.as_str().try_into()
    }
}
impl std::str::FromStr for Language {
    type Err = crate::model::language::ConstraintViolation;
    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
        Self::try_from(s)
    }
}
impl Language {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Language::English => "en",
            Language::Spanish => "es",
            Language::Italian => "it",
            Language::Japanese => "jp",
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["en", "es", "it", "jp"]
    }
}
impl ::std::convert::AsRef<str> for Language {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}
impl crate::constrained::Constrained for Language {
    type Unconstrained = ::std::string::String;
}

impl ::std::convert::From<::std::string::String>
    for crate::constrained::MaybeConstrained<crate::model::Language>
{
    fn from(value: ::std::string::String) -> Self {
        Self::Unconstrained(value)
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub enum CapturePokemonEvents {
    #[allow(missing_docs)] // documentation missing in model
    Event(crate::model::CaptureEvent),
}
impl CapturePokemonEvents {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`Event`](crate::model::CapturePokemonEvents::Event), extracting the inner [`CaptureEvent`](crate::model::CaptureEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_event(&self) -> ::std::result::Result<&crate::model::CaptureEvent, &Self> {
        if let CapturePokemonEvents::Event(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`Event`](crate::model::CapturePokemonEvents::Event).
    pub fn is_event(&self) -> bool {
        self.as_event().is_ok()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct CaptureEvent {
    #[allow(missing_docs)] // documentation missing in model
    pub name: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub captured: ::std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub shiny: ::std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub pokedex_update: ::std::option::Option<::aws_smithy_types::Blob>,
}
impl CaptureEvent {
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn captured(&self) -> ::std::option::Option<bool> {
        self.captured
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn shiny(&self) -> ::std::option::Option<bool> {
        self.shiny
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn pokedex_update(&self) -> ::std::option::Option<&::aws_smithy_types::Blob> {
        self.pokedex_update.as_ref()
    }
}
impl CaptureEvent {
    /// Creates a new builder-style object to manufacture [`CaptureEvent`](crate::model::CaptureEvent).
    pub fn builder() -> crate::model::capture_event::Builder {
        crate::model::capture_event::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub enum AttemptCapturingPokemonEvent {
    #[allow(missing_docs)] // documentation missing in model
    Event(crate::model::CapturingEvent),
}
impl AttemptCapturingPokemonEvent {
    #[allow(irrefutable_let_patterns)]
    /// Tries to convert the enum instance into [`Event`](crate::model::AttemptCapturingPokemonEvent::Event), extracting the inner [`CapturingEvent`](crate::model::CapturingEvent).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_event(&self) -> ::std::result::Result<&crate::model::CapturingEvent, &Self> {
        if let AttemptCapturingPokemonEvent::Event(val) = &self {
            ::std::result::Result::Ok(val)
        } else {
            ::std::result::Result::Err(self)
        }
    }
    /// Returns true if this is a [`Event`](crate::model::AttemptCapturingPokemonEvent::Event).
    pub fn is_event(&self) -> bool {
        self.as_event().is_ok()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct CapturingEvent {
    #[allow(missing_docs)] // documentation missing in model
    pub payload: ::std::option::Option<crate::model::CapturingPayload>,
}
impl CapturingEvent {
    #[allow(missing_docs)] // documentation missing in model
    pub fn payload(&self) -> ::std::option::Option<&crate::model::CapturingPayload> {
        self.payload.as_ref()
    }
}
impl CapturingEvent {
    /// Creates a new builder-style object to manufacture [`CapturingEvent`](crate::model::CapturingEvent).
    pub fn builder() -> crate::model::capturing_event::Builder {
        crate::model::capturing_event::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::CapturingEvent {
    type Unconstrained = crate::model::capturing_event::Builder;
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct CapturingPayload {
    #[allow(missing_docs)] // documentation missing in model
    pub name: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub pokeball: ::std::option::Option<::std::string::String>,
}
impl CapturingPayload {
    #[allow(missing_docs)] // documentation missing in model
    pub fn name(&self) -> ::std::option::Option<&str> {
        self.name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn pokeball(&self) -> ::std::option::Option<&str> {
        self.pokeball.as_deref()
    }
}
impl CapturingPayload {
    /// Creates a new builder-style object to manufacture [`CapturingPayload`](crate::model::CapturingPayload).
    pub fn builder() -> crate::model::capturing_payload::Builder {
        crate::model::capturing_payload::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::CapturingPayload {
    type Unconstrained = crate::model::capturing_payload::Builder;
}
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `path` was not provided but it is required when building `ValidationExceptionField`.
        MissingPath,
        /// `message` was not provided but it is required when building `ValidationExceptionField`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingPath => write!(f, "`path` was not provided but it is required when building `ValidationExceptionField`"),
                ConstraintViolation::MissingMessage => write!(f, "`message` was not provided but it is required when building `ValidationExceptionField`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::model::ValidationExceptionField {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> ::std::result::Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: ::std::option::Option<::std::string::String>,
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// A JSONPointer expression to the structure member whose value failed to satisfy the modeled constraints.
        pub fn path(mut self, input: ::std::string::String) -> Self {
            self.path = Some(input);
            self
        }
        /// A detailed description of the validation failure.
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        ///
        /// The builder fails to construct a [`ValidationExceptionField`](crate::model::ValidationExceptionField) if a [`ConstraintViolation`] occurs.
        ///
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::ValidationExceptionField, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::model::ValidationExceptionField, ConstraintViolation> {
            Ok(crate::model::ValidationExceptionField {
                path: self.path.ok_or(ConstraintViolation::MissingPath)?,
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
/// See [`FlavorText`](crate::model::FlavorText).
pub mod flavor_text {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `flavor_text` was not provided but it is required when building `FlavorText`.
        MissingFlavorText,
        /// `language` was not provided but it is required when building `FlavorText`.
        MissingLanguage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingFlavorText => write!(
                    f,
                    "`flavor_text` was not provided but it is required when building `FlavorText`"
                ),
                ConstraintViolation::MissingLanguage => write!(
                    f,
                    "`language` was not provided but it is required when building `FlavorText`"
                ),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::model::FlavorText {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> ::std::result::Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`FlavorText`](crate::model::FlavorText).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) flavor_text: ::std::option::Option<::std::string::String>,
        pub(crate) language: ::std::option::Option<crate::model::Language>,
    }
    impl Builder {
        /// The localized flavor text for an API resource in a specific language.
        pub fn flavor_text(mut self, input: ::std::string::String) -> Self {
            self.flavor_text = Some(input);
            self
        }
        /// The language this name is in.
        pub fn language(mut self, input: crate::model::Language) -> Self {
            self.language = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`FlavorText`](crate::model::FlavorText).
        ///
        /// The builder fails to construct a [`FlavorText`](crate::model::FlavorText) if a [`ConstraintViolation`] occurs.
        ///
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::FlavorText, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::model::FlavorText, ConstraintViolation> {
            Ok(crate::model::FlavorText {
                flavor_text: self
                    .flavor_text
                    .ok_or(ConstraintViolation::MissingFlavorText)?,
                language: self.language.ok_or(ConstraintViolation::MissingLanguage)?,
            })
        }
    }
}
/// See [`CaptureEvent`](crate::model::CaptureEvent).
pub mod capture_event {

    impl ::std::convert::From<Builder> for crate::model::CaptureEvent {
        fn from(builder: Builder) -> Self {
            builder.build()
        }
    }
    /// A builder for [`CaptureEvent`](crate::model::CaptureEvent).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: ::std::option::Option<::std::string::String>,
        pub(crate) captured: ::std::option::Option<bool>,
        pub(crate) shiny: ::std::option::Option<bool>,
        pub(crate) pokedex_update: ::std::option::Option<::aws_smithy_types::Blob>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn captured(mut self, input: ::std::option::Option<bool>) -> Self {
            self.captured = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn shiny(mut self, input: ::std::option::Option<bool>) -> Self {
            self.shiny = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn pokedex_update(
            mut self,
            input: ::std::option::Option<::aws_smithy_types::Blob>,
        ) -> Self {
            self.pokedex_update = input;
            self
        }
        /// Consumes the builder and constructs a [`CaptureEvent`](crate::model::CaptureEvent).
        pub fn build(self) -> crate::model::CaptureEvent {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(self) -> crate::model::CaptureEvent {
            crate::model::CaptureEvent {
                name: self.name,
                captured: self.captured,
                shiny: self.shiny,
                pokedex_update: self.pokedex_update,
            }
        }
    }
}
/// See [`CapturingEvent`](crate::model::CapturingEvent).
pub mod capturing_event {

    impl ::std::convert::From<Builder> for crate::model::CapturingEvent {
        fn from(builder: Builder) -> Self {
            builder.build()
        }
    }
    /// A builder for [`CapturingEvent`](crate::model::CapturingEvent).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) payload: ::std::option::Option<crate::model::CapturingPayload>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn payload(
            mut self,
            input: ::std::option::Option<crate::model::CapturingPayload>,
        ) -> Self {
            self.payload = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_payload(
            mut self,
            input: Option<impl ::std::convert::Into<crate::model::CapturingPayload>>,
        ) -> Self {
            self.payload = input.map(|v| v.into());
            self
        }
        /// Consumes the builder and constructs a [`CapturingEvent`](crate::model::CapturingEvent).
        pub fn build(self) -> crate::model::CapturingEvent {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(self) -> crate::model::CapturingEvent {
            crate::model::CapturingEvent {
                payload: self.payload,
            }
        }
    }
}
/// See [`CapturingPayload`](crate::model::CapturingPayload).
pub mod capturing_payload {

    impl ::std::convert::From<Builder> for crate::model::CapturingPayload {
        fn from(builder: Builder) -> Self {
            builder.build()
        }
    }
    /// A builder for [`CapturingPayload`](crate::model::CapturingPayload).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: ::std::option::Option<::std::string::String>,
        pub(crate) pokeball: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.name = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_name(
            mut self,
            input: Option<impl ::std::convert::Into<::std::string::String>>,
        ) -> Self {
            self.name = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn pokeball(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.pokeball = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_pokeball(
            mut self,
            input: Option<impl ::std::convert::Into<::std::string::String>>,
        ) -> Self {
            self.pokeball = input.map(|v| v.into());
            self
        }
        /// Consumes the builder and constructs a [`CapturingPayload`](crate::model::CapturingPayload).
        pub fn build(self) -> crate::model::CapturingPayload {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(self) -> crate::model::CapturingPayload {
            crate::model::CapturingPayload {
                name: self.name,
                pokeball: self.pokeball,
            }
        }
    }
}
