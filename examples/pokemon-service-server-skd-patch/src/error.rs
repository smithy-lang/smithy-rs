// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `GetStorage` operation.
/// Each variant represents an error that can occur for the `GetStorage` operation.
#[derive(::std::fmt::Debug)]
pub enum GetStorageError {
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// Not authorized to access Pokémon storage.
    StorageAccessNotAuthorized(crate::error::StorageAccessNotAuthorized),
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
}
impl ::std::fmt::Display for GetStorageError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            GetStorageError::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetStorageError::StorageAccessNotAuthorized(_inner) => _inner.fmt(f),
            GetStorageError::ValidationException(_inner) => _inner.fmt(f),
        }
    }
}
impl GetStorageError {
    /// Returns `true` if the error kind is `GetStorageError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self, GetStorageError::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetStorageError::StorageAccessNotAuthorized`.
    pub fn is_storage_access_not_authorized(&self) -> bool {
        matches!(&self, GetStorageError::StorageAccessNotAuthorized(_))
    }
    /// Returns `true` if the error kind is `GetStorageError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, GetStorageError::ValidationException(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            GetStorageError::ResourceNotFoundException(_inner) => _inner.name(),
            GetStorageError::StorageAccessNotAuthorized(_inner) => _inner.name(),
            GetStorageError::ValidationException(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for GetStorageError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            GetStorageError::ResourceNotFoundException(_inner) => Some(_inner),
            GetStorageError::StorageAccessNotAuthorized(_inner) => Some(_inner),
            GetStorageError::ValidationException(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::ResourceNotFoundException>
    for crate::error::GetStorageError
{
    fn from(variant: crate::error::ResourceNotFoundException) -> crate::error::GetStorageError {
        Self::ResourceNotFoundException(variant)
    }
}
impl ::std::convert::From<crate::error::StorageAccessNotAuthorized>
    for crate::error::GetStorageError
{
    fn from(variant: crate::error::StorageAccessNotAuthorized) -> crate::error::GetStorageError {
        Self::StorageAccessNotAuthorized(variant)
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::GetStorageError {
    fn from(variant: crate::error::ValidationException) -> crate::error::GetStorageError {
        Self::ValidationException(variant)
    }
}

/// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ValidationException {
    /// A summary of the validation failure.
    pub message: ::std::string::String,
    /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
    pub field_list: ::std::option::Option<::std::vec::Vec<crate::model::ValidationExceptionField>>,
}
impl ValidationException {
    /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
    pub fn field_list(&self) -> ::std::option::Option<&[crate::model::ValidationExceptionField]> {
        self.field_list.as_deref()
    }
}
impl ValidationException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ValidationException"
    }
}
impl ::std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ValidationException")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ValidationException {}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException).
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// Not authorized to access Pokémon storage.
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct StorageAccessNotAuthorized {}
impl StorageAccessNotAuthorized {
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "StorageAccessNotAuthorized"
    }
}
impl ::std::fmt::Display for StorageAccessNotAuthorized {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "StorageAccessNotAuthorized")?;
        Ok(())
    }
}
impl ::std::error::Error for StorageAccessNotAuthorized {}
impl StorageAccessNotAuthorized {
    /// Creates a new builder-style object to manufacture [`StorageAccessNotAuthorized`](crate::error::StorageAccessNotAuthorized).
    pub fn builder() -> crate::error::storage_access_not_authorized::Builder {
        crate::error::storage_access_not_authorized::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ResourceNotFoundException {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::string::String,
}
impl ResourceNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        &self.message
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ResourceNotFoundException"
    }
}
impl ::std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ResourceNotFoundException")?;
        {
            ::std::write!(f, ": {}", &self.message)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ResourceNotFoundException {}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// Error type for the `GetPokemonSpecies` operation.
/// Each variant represents an error that can occur for the `GetPokemonSpecies` operation.
#[derive(::std::fmt::Debug)]
pub enum GetPokemonSpeciesError {
    #[allow(missing_docs)] // documentation missing in model
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
}
impl ::std::fmt::Display for GetPokemonSpeciesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            GetPokemonSpeciesError::ResourceNotFoundException(_inner) => _inner.fmt(f),
            GetPokemonSpeciesError::ValidationException(_inner) => _inner.fmt(f),
        }
    }
}
impl GetPokemonSpeciesError {
    /// Returns `true` if the error kind is `GetPokemonSpeciesError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self, GetPokemonSpeciesError::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPokemonSpeciesError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, GetPokemonSpeciesError::ValidationException(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            GetPokemonSpeciesError::ResourceNotFoundException(_inner) => _inner.name(),
            GetPokemonSpeciesError::ValidationException(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for GetPokemonSpeciesError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            GetPokemonSpeciesError::ResourceNotFoundException(_inner) => Some(_inner),
            GetPokemonSpeciesError::ValidationException(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::ResourceNotFoundException>
    for crate::error::GetPokemonSpeciesError
{
    fn from(
        variant: crate::error::ResourceNotFoundException,
    ) -> crate::error::GetPokemonSpeciesError {
        Self::ResourceNotFoundException(variant)
    }
}
impl ::std::convert::From<crate::error::ValidationException>
    for crate::error::GetPokemonSpeciesError
{
    fn from(variant: crate::error::ValidationException) -> crate::error::GetPokemonSpeciesError {
        Self::ValidationException(variant)
    }
}

/// Error type for the `CapturePokemon` operation.
/// Each variant represents an error that can occur for the `CapturePokemon` operation.
#[derive(::std::fmt::Debug)]
pub enum CapturePokemonError {
    #[allow(missing_docs)] // documentation missing in model
    UnsupportedRegionError(crate::error::UnsupportedRegionError),
    #[allow(missing_docs)] // documentation missing in model
    ThrottlingError(crate::error::ThrottlingError),
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
    #[allow(missing_docs)] // documentation missing in model
    MasterBallUnsuccessful(crate::error::MasterBallUnsuccessful),
    #[allow(missing_docs)] // documentation missing in model
    InvalidPokeballError(crate::error::InvalidPokeballError),
}
impl ::std::fmt::Display for CapturePokemonError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            CapturePokemonError::UnsupportedRegionError(_inner) => _inner.fmt(f),
            CapturePokemonError::ThrottlingError(_inner) => _inner.fmt(f),
            CapturePokemonError::ValidationException(_inner) => _inner.fmt(f),
            CapturePokemonError::MasterBallUnsuccessful(_inner) => _inner.fmt(f),
            CapturePokemonError::InvalidPokeballError(_inner) => _inner.fmt(f),
        }
    }
}
impl CapturePokemonError {
    /// Returns `true` if the error kind is `CapturePokemonError::UnsupportedRegionError`.
    pub fn is_unsupported_region_error(&self) -> bool {
        matches!(&self, CapturePokemonError::UnsupportedRegionError(_))
    }
    /// Returns `true` if the error kind is `CapturePokemonError::ThrottlingError`.
    pub fn is_throttling_error(&self) -> bool {
        matches!(&self, CapturePokemonError::ThrottlingError(_))
    }
    /// Returns `true` if the error kind is `CapturePokemonError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, CapturePokemonError::ValidationException(_))
    }
    /// Returns `true` if the error kind is `CapturePokemonError::MasterBallUnsuccessful`.
    pub fn is_master_ball_unsuccessful(&self) -> bool {
        matches!(&self, CapturePokemonError::MasterBallUnsuccessful(_))
    }
    /// Returns `true` if the error kind is `CapturePokemonError::InvalidPokeballError`.
    pub fn is_invalid_pokeball_error(&self) -> bool {
        matches!(&self, CapturePokemonError::InvalidPokeballError(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            CapturePokemonError::UnsupportedRegionError(_inner) => _inner.name(),
            CapturePokemonError::ThrottlingError(_inner) => _inner.name(),
            CapturePokemonError::ValidationException(_inner) => _inner.name(),
            CapturePokemonError::MasterBallUnsuccessful(_inner) => _inner.name(),
            CapturePokemonError::InvalidPokeballError(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for CapturePokemonError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            CapturePokemonError::UnsupportedRegionError(_inner) => Some(_inner),
            CapturePokemonError::ThrottlingError(_inner) => Some(_inner),
            CapturePokemonError::ValidationException(_inner) => Some(_inner),
            CapturePokemonError::MasterBallUnsuccessful(_inner) => Some(_inner),
            CapturePokemonError::InvalidPokeballError(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::UnsupportedRegionError>
    for crate::error::CapturePokemonError
{
    fn from(variant: crate::error::UnsupportedRegionError) -> crate::error::CapturePokemonError {
        Self::UnsupportedRegionError(variant)
    }
}
impl ::std::convert::From<crate::error::ThrottlingError> for crate::error::CapturePokemonError {
    fn from(variant: crate::error::ThrottlingError) -> crate::error::CapturePokemonError {
        Self::ThrottlingError(variant)
    }
}
impl ::std::convert::From<crate::error::ValidationException> for crate::error::CapturePokemonError {
    fn from(variant: crate::error::ValidationException) -> crate::error::CapturePokemonError {
        Self::ValidationException(variant)
    }
}
impl ::std::convert::From<crate::error::MasterBallUnsuccessful>
    for crate::error::CapturePokemonError
{
    fn from(variant: crate::error::MasterBallUnsuccessful) -> crate::error::CapturePokemonError {
        Self::MasterBallUnsuccessful(variant)
    }
}
impl ::std::convert::From<crate::error::InvalidPokeballError>
    for crate::error::CapturePokemonError
{
    fn from(variant: crate::error::InvalidPokeballError) -> crate::error::CapturePokemonError {
        Self::InvalidPokeballError(variant)
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct InvalidPokeballError {
    #[allow(missing_docs)] // documentation missing in model
    pub pokeball: ::std::string::String,
}
impl InvalidPokeballError {
    #[allow(missing_docs)] // documentation missing in model
    pub fn pokeball(&self) -> &str {
        use std::ops::Deref;
        self.pokeball.deref()
    }
}
impl InvalidPokeballError {
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "InvalidPokeballError"
    }
}
impl ::std::fmt::Display for InvalidPokeballError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "InvalidPokeballError")?;
        Ok(())
    }
}
impl ::std::error::Error for InvalidPokeballError {}
impl InvalidPokeballError {
    /// Creates a new builder-style object to manufacture [`InvalidPokeballError`](crate::error::InvalidPokeballError).
    pub fn builder() -> crate::error::invalid_pokeball_error::Builder {
        crate::error::invalid_pokeball_error::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct MasterBallUnsuccessful {
    #[allow(missing_docs)] // documentation missing in model
    pub message: ::std::option::Option<::std::string::String>,
}
impl MasterBallUnsuccessful {
    /// Returns the error message.
    pub fn message(&self) -> ::std::option::Option<&str> {
        self.message.as_deref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "MasterBallUnsuccessful"
    }
}
impl ::std::fmt::Display for MasterBallUnsuccessful {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "MasterBallUnsuccessful")?;
        if let ::std::option::Option::Some(inner_1) = &self.message {
            {
                ::std::write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for MasterBallUnsuccessful {}
impl MasterBallUnsuccessful {
    /// Creates a new builder-style object to manufacture [`MasterBallUnsuccessful`](crate::error::MasterBallUnsuccessful).
    pub fn builder() -> crate::error::master_ball_unsuccessful::Builder {
        crate::error::master_ball_unsuccessful::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::error::MasterBallUnsuccessful {
    type Unconstrained = crate::error::master_ball_unsuccessful::Builder;
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct ThrottlingError {}
impl ThrottlingError {
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ThrottlingError"
    }
}
impl ::std::fmt::Display for ThrottlingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ThrottlingError")?;
        Ok(())
    }
}
impl ::std::error::Error for ThrottlingError {}
impl ThrottlingError {
    /// Creates a new builder-style object to manufacture [`ThrottlingError`](crate::error::ThrottlingError).
    pub fn builder() -> crate::error::throttling_error::Builder {
        crate::error::throttling_error::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct UnsupportedRegionError {
    #[allow(missing_docs)] // documentation missing in model
    pub region: ::std::string::String,
}
impl UnsupportedRegionError {
    #[allow(missing_docs)] // documentation missing in model
    pub fn region(&self) -> &str {
        use std::ops::Deref;
        self.region.deref()
    }
}
impl UnsupportedRegionError {
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "UnsupportedRegionError"
    }
}
impl ::std::fmt::Display for UnsupportedRegionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "UnsupportedRegionError")?;
        Ok(())
    }
}
impl ::std::error::Error for UnsupportedRegionError {}
impl UnsupportedRegionError {
    /// Creates a new builder-style object to manufacture [`UnsupportedRegionError`](crate::error::UnsupportedRegionError).
    pub fn builder() -> crate::error::unsupported_region_error::Builder {
        crate::error::unsupported_region_error::Builder::default()
    }
}

/// Error type for the `CapturePokemonEvents` operation.
/// Each variant represents an error that can occur for the `CapturePokemonEvents` operation.
#[derive(::std::fmt::Debug)]
pub enum CapturePokemonEventsError {
    #[allow(missing_docs)] // documentation missing in model
    InvalidPokeballError(crate::error::InvalidPokeballError),
    #[allow(missing_docs)] // documentation missing in model
    ThrottlingError(crate::error::ThrottlingError),
}
impl ::std::fmt::Display for CapturePokemonEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            CapturePokemonEventsError::InvalidPokeballError(_inner) => _inner.fmt(f),
            CapturePokemonEventsError::ThrottlingError(_inner) => _inner.fmt(f),
        }
    }
}
impl CapturePokemonEventsError {
    /// Returns `true` if the error kind is `CapturePokemonEventsError::InvalidPokeballError`.
    pub fn is_invalid_pokeball_error(&self) -> bool {
        matches!(&self, CapturePokemonEventsError::InvalidPokeballError(_))
    }
    /// Returns `true` if the error kind is `CapturePokemonEventsError::ThrottlingError`.
    pub fn is_throttling_error(&self) -> bool {
        matches!(&self, CapturePokemonEventsError::ThrottlingError(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            CapturePokemonEventsError::InvalidPokeballError(_inner) => _inner.name(),
            CapturePokemonEventsError::ThrottlingError(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for CapturePokemonEventsError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            CapturePokemonEventsError::InvalidPokeballError(_inner) => Some(_inner),
            CapturePokemonEventsError::ThrottlingError(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::InvalidPokeballError>
    for crate::error::CapturePokemonEventsError
{
    fn from(
        variant: crate::error::InvalidPokeballError,
    ) -> crate::error::CapturePokemonEventsError {
        Self::InvalidPokeballError(variant)
    }
}
impl ::std::convert::From<crate::error::ThrottlingError>
    for crate::error::CapturePokemonEventsError
{
    fn from(variant: crate::error::ThrottlingError) -> crate::error::CapturePokemonEventsError {
        Self::ThrottlingError(variant)
    }
}

/// Error type for the `AttemptCapturingPokemonEvent` operation.
/// Each variant represents an error that can occur for the `AttemptCapturingPokemonEvent` operation.
#[derive(::std::fmt::Debug)]
pub enum AttemptCapturingPokemonEventError {
    #[allow(missing_docs)] // documentation missing in model
    MasterBallUnsuccessful(crate::error::MasterBallUnsuccessful),
}
impl ::std::fmt::Display for AttemptCapturingPokemonEventError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            AttemptCapturingPokemonEventError::MasterBallUnsuccessful(_inner) => _inner.fmt(f),
        }
    }
}
impl AttemptCapturingPokemonEventError {
    /// Returns `true` if the error kind is `AttemptCapturingPokemonEventError::MasterBallUnsuccessful`.
    pub fn is_master_ball_unsuccessful(&self) -> bool {
        matches!(
            &self,
            AttemptCapturingPokemonEventError::MasterBallUnsuccessful(_)
        )
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            AttemptCapturingPokemonEventError::MasterBallUnsuccessful(_inner) => _inner.name(),
        }
    }
}
impl ::std::error::Error for AttemptCapturingPokemonEventError {
    fn source(&self) -> std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match &self {
            AttemptCapturingPokemonEventError::MasterBallUnsuccessful(_inner) => Some(_inner),
        }
    }
}
impl ::std::convert::From<crate::error::MasterBallUnsuccessful>
    for crate::error::AttemptCapturingPokemonEventError
{
    fn from(
        variant: crate::error::MasterBallUnsuccessful,
    ) -> crate::error::AttemptCapturingPokemonEventError {
        Self::MasterBallUnsuccessful(variant)
    }
}

/// See [`ValidationException`](crate::error::ValidationException).
pub mod validation_exception {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `ValidationException`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(f, "`message` was not provided but it is required when building `ValidationException`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::ValidationException {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> ::std::result::Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ValidationException`](crate::error::ValidationException).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
        pub(crate) field_list:
            ::std::option::Option<::std::vec::Vec<crate::model::ValidationExceptionField>>,
    }
    impl Builder {
        /// A summary of the validation failure.
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
        pub fn field_list(
            mut self,
            input: ::std::option::Option<::std::vec::Vec<crate::model::ValidationExceptionField>>,
        ) -> Self {
            self.field_list = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException).
        ///
        /// The builder fails to construct a [`ValidationException`](crate::error::ValidationException) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::ValidationException, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::ValidationException, ConstraintViolation> {
            Ok(crate::error::ValidationException {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
                field_list: self.field_list,
            })
        }
    }
}
/// See [`StorageAccessNotAuthorized`](crate::error::StorageAccessNotAuthorized).
pub mod storage_access_not_authorized {

    impl ::std::convert::From<Builder> for crate::error::StorageAccessNotAuthorized {
        fn from(builder: Builder) -> Self {
            builder.build()
        }
    }
    /// A builder for [`StorageAccessNotAuthorized`](crate::error::StorageAccessNotAuthorized).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`StorageAccessNotAuthorized`](crate::error::StorageAccessNotAuthorized).
        pub fn build(self) -> crate::error::StorageAccessNotAuthorized {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(self) -> crate::error::StorageAccessNotAuthorized {
            crate::error::StorageAccessNotAuthorized {}
        }
    }
}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
pub mod resource_not_found_exception {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `message` was not provided but it is required when building `ResourceNotFoundException`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingMessage => write!(f, "`message` was not provided but it is required when building `ResourceNotFoundException`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::ResourceNotFoundException {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> ::std::result::Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException).
        ///
        /// The builder fails to construct a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::ResourceNotFoundException, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::ResourceNotFoundException, ConstraintViolation> {
            Ok(crate::error::ResourceNotFoundException {
                message: self.message.ok_or(ConstraintViolation::MissingMessage)?,
            })
        }
    }
}
/// See [`InvalidPokeballError`](crate::error::InvalidPokeballError).
pub mod invalid_pokeball_error {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `pokeball` was not provided but it is required when building `InvalidPokeballError`.
        MissingPokeball,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingPokeball => write!(f, "`pokeball` was not provided but it is required when building `InvalidPokeballError`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::InvalidPokeballError {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> ::std::result::Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`InvalidPokeballError`](crate::error::InvalidPokeballError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) pokeball: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn pokeball(mut self, input: ::std::string::String) -> Self {
            self.pokeball = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`InvalidPokeballError`](crate::error::InvalidPokeballError).
        ///
        /// The builder fails to construct a [`InvalidPokeballError`](crate::error::InvalidPokeballError) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::InvalidPokeballError, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::InvalidPokeballError, ConstraintViolation> {
            Ok(crate::error::InvalidPokeballError {
                pokeball: self.pokeball.ok_or(ConstraintViolation::MissingPokeball)?,
            })
        }
    }
}
/// See [`MasterBallUnsuccessful`](crate::error::MasterBallUnsuccessful).
pub mod master_ball_unsuccessful {

    impl ::std::convert::From<Builder> for crate::error::MasterBallUnsuccessful {
        fn from(builder: Builder) -> Self {
            builder.build()
        }
    }
    /// A builder for [`MasterBallUnsuccessful`](crate::error::MasterBallUnsuccessful).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn message(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.message = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_message(
            mut self,
            input: Option<impl ::std::convert::Into<::std::string::String>>,
        ) -> Self {
            self.message = input.map(|v| v.into());
            self
        }
        /// Consumes the builder and constructs a [`MasterBallUnsuccessful`](crate::error::MasterBallUnsuccessful).
        pub fn build(self) -> crate::error::MasterBallUnsuccessful {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(self) -> crate::error::MasterBallUnsuccessful {
            crate::error::MasterBallUnsuccessful {
                message: self.message,
            }
        }
    }
}
/// See [`ThrottlingError`](crate::error::ThrottlingError).
pub mod throttling_error {

    impl ::std::convert::From<Builder> for crate::error::ThrottlingError {
        fn from(builder: Builder) -> Self {
            builder.build()
        }
    }
    /// A builder for [`ThrottlingError`](crate::error::ThrottlingError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {}
    impl Builder {
        /// Consumes the builder and constructs a [`ThrottlingError`](crate::error::ThrottlingError).
        pub fn build(self) -> crate::error::ThrottlingError {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(self) -> crate::error::ThrottlingError {
            crate::error::ThrottlingError {}
        }
    }
}
/// See [`UnsupportedRegionError`](crate::error::UnsupportedRegionError).
pub mod unsupported_region_error {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `region` was not provided but it is required when building `UnsupportedRegionError`.
        MissingRegion,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingRegion => write!(f, "`region` was not provided but it is required when building `UnsupportedRegionError`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ::std::convert::TryFrom<Builder> for crate::error::UnsupportedRegionError {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> ::std::result::Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`UnsupportedRegionError`](crate::error::UnsupportedRegionError).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn region(mut self, input: ::std::string::String) -> Self {
            self.region = Some(input);
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedRegionError`](crate::error::UnsupportedRegionError).
        ///
        /// The builder fails to construct a [`UnsupportedRegionError`](crate::error::UnsupportedRegionError) if a [`ConstraintViolation`] occurs.
        ///
        pub fn build(self) -> Result<crate::error::UnsupportedRegionError, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::error::UnsupportedRegionError, ConstraintViolation> {
            Ok(crate::error::UnsupportedRegionError {
                region: self.region.ok_or(ConstraintViolation::MissingRegion)?,
            })
        }
    }
}
