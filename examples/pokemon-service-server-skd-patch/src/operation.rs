// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
const CONTENT_TYPE_GETSTORAGE: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`GetStorageInput`](crate::input::GetStorageInput) using modelled bindings.
    pub struct GetStorageInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::GetStorageInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for GetStorageInputFuture {
    type Output = Result<
        crate::input::GetStorageInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::GetStorageInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = GetStorageInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_GETSTORAGE,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }
            crate::protocol_serde::shape_get_storage::de_get_storage_http_request(request).await
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        GetStorageInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::GetStorageOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_get_storage::ser_get_storage_http_response(self) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::error::GetStorageError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_get_storage::ser_get_storage_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_GETPOKEMONSPECIES: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`GetPokemonSpeciesInput`](crate::input::GetPokemonSpeciesInput) using modelled bindings.
    pub struct GetPokemonSpeciesInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::GetPokemonSpeciesInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for GetPokemonSpeciesInputFuture {
    type Output = Result<
        crate::input::GetPokemonSpeciesInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::GetPokemonSpeciesInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = GetPokemonSpeciesInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_GETPOKEMONSPECIES,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }
            crate::protocol_serde::shape_get_pokemon_species::de_get_pokemon_species_http_request(
                request,
            )
            .await
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        GetPokemonSpeciesInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::GetPokemonSpeciesOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_get_pokemon_species::ser_get_pokemon_species_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
                        }
                    }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::error::GetPokemonSpeciesError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_get_pokemon_species::ser_get_pokemon_species_http_error(
            &self,
        ) {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_STREAMPOKEMONRADIO: ::mime::Mime = ::mime::APPLICATION_OCTET_STREAM;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`StreamPokemonRadioInput`](crate::input::StreamPokemonRadioInput) using modelled bindings.
    pub struct StreamPokemonRadioInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::StreamPokemonRadioInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for StreamPokemonRadioInputFuture {
    type Output = Result<
        crate::input::StreamPokemonRadioInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::StreamPokemonRadioInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = StreamPokemonRadioInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_STREAMPOKEMONRADIO,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }
            crate::protocol_serde::shape_stream_pokemon_radio::de_stream_pokemon_radio_http_request(
                request,
            )
            .await
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        StreamPokemonRadioInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::StreamPokemonRadioOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_stream_pokemon_radio::ser_stream_pokemon_radio_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
                        }
                    }
    }
}

const CONTENT_TYPE_CHECKHEALTH: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`CheckHealthInput`](crate::input::CheckHealthInput) using modelled bindings.
    pub struct CheckHealthInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::CheckHealthInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for CheckHealthInputFuture {
    type Output = Result<
        crate::input::CheckHealthInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::CheckHealthInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = CheckHealthInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_CHECKHEALTH,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }
            crate::protocol_serde::shape_check_health::de_check_health_http_request(request).await
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        CheckHealthInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::CheckHealthOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_check_health::ser_check_health_http_response(self) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

static CONTENT_TYPE_CAPTUREPOKEMON: std::sync::LazyLock<::mime::Mime> =
    std::sync::LazyLock::new(|| {
        "application/vnd.amazon.eventstream"
            .parse::<::mime::Mime>()
            .expect("BUG: MIME parsing failed, content_type is not valid")
    });
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`CapturePokemonInput`](crate::input::CapturePokemonInput) using modelled bindings.
    pub struct CapturePokemonInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::CapturePokemonInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for CapturePokemonInputFuture {
    type Output = Result<
        crate::input::CapturePokemonInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::CapturePokemonInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,
    // TODO: PATCH - Changed from Into<ByteStream> to http-body 1.x constraint for hyper 1.x compatibility
    // This supports any body type that implements http-body 1.x (including custom body types)
    B: http_body_1_0::Body<Data = bytes::Bytes> + Send + Sync + 'static,
    B::Error: Into<::aws_smithy_types::body::Error> + 'static,
    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = CapturePokemonInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_CAPTUREPOKEMON,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }
            crate::protocol_serde::shape_capture_pokemon::de_capture_pokemon_http_request(request)
                .await
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        CapturePokemonInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::CapturePokemonOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_capture_pokemon::ser_capture_pokemon_http_response(self)
        {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::error::CapturePokemonError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_capture_pokemon::ser_capture_pokemon_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_DONOTHING: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`DoNothingInput`](crate::input::DoNothingInput) using modelled bindings.
    pub struct DoNothingInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::DoNothingInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for DoNothingInputFuture {
    type Output = Result<
        crate::input::DoNothingInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::DoNothingInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = DoNothingInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_DONOTHING,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }
            crate::protocol_serde::shape_do_nothing::de_do_nothing_http_request(request).await
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        DoNothingInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::DoNothingOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_do_nothing::ser_do_nothing_http_response(self) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}

const CONTENT_TYPE_GETSERVERSTATISTICS: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`GetServerStatisticsInput`](crate::input::GetServerStatisticsInput) using modelled bindings.
    pub struct GetServerStatisticsInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::GetServerStatisticsInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for GetServerStatisticsInputFuture {
    type Output = Result<
        crate::input::GetServerStatisticsInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::GetServerStatisticsInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = GetServerStatisticsInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_GETSERVERSTATISTICS,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }
            crate::protocol_serde::shape_get_server_statistics::de_get_server_statistics_http_request(request)
                            .await
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        GetServerStatisticsInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::GetServerStatisticsOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_get_server_statistics::ser_get_server_statistics_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
                        }
                    }
    }
}
