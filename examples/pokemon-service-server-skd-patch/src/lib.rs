#![allow(deprecated)]
#![allow(unknown_lints)]
#![allow(clippy::module_inception)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::wrong_self_convention)]
#![allow(clippy::should_implement_trait)]
#![allow(clippy::disallowed_names)]
#![allow(clippy::vec_init_then_push)]
#![allow(clippy::type_complexity)]
#![allow(clippy::needless_return)]
#![allow(clippy::derive_partial_eq_without_eq)]
#![allow(clippy::result_large_err)]
#![allow(clippy::unnecessary_map_on_constructor)]
#![allow(clippy::deprecated_semver)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::invalid_html_tags)]
#![forbid(unsafe_code)]
#![cfg_attr(docsrs, feature(doc_cfg))]
//! The Pokémon Service allows you to retrieve information about Pokémon species.

// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
//! A fast and customizable Rust implementation of the PokemonService Smithy service.
//!
//! # Using PokemonService
//!
//! The primary entrypoint is [`PokemonService`]: it satisfies the [`Service<http::Request, Response = http::Response>`](::tower::Service)
//! trait and therefore can be handed to a [`hyper` server](https://github.com/hyperium/hyper) via [`PokemonService::into_make_service`]
//! or used in AWS Lambda
#![cfg_attr(
    feature = "aws-lambda",
    doc = " via [`LambdaHandler`](crate::server::routing::LambdaHandler)."
)]
#![cfg_attr(
    not(feature = "aws-lambda"),
    doc = " by enabling the `aws-lambda` feature flag and utilizing the `LambdaHandler`."
)]
//! The [`crate::input`], [`crate::output`], and [`crate::error`]
//! modules provide the types used in each operation.
//!
//! ### Running on Hyper
//!
//! ```rust,no_run
//! # use std::net::SocketAddr;
//! # async fn dummy() {
//! use pokemon_service_server_sdk::{PokemonService, PokemonServiceConfig};
//!
//! # let app = PokemonService::builder(
//! #     PokemonServiceConfig::builder()
//! #         .build()
//! # ).build_unchecked();
//! use hyper_util::rt::TokioIo;
//! use hyper_util::service::TowerToHyperService;
//! use ::tokio::net::TcpListener;
//! use ::tower::Service;
//!
//! let app = app.into_make_service();
//! let bind: SocketAddr = "127.0.0.1:6969".parse()
//!     .expect("unable to parse the server bind address and port");
//! let listener = TcpListener::bind(bind).await.expect("failed to bind");
//!
//! loop {
//!     let (stream, remote_addr) = listener.accept().await.expect("failed to accept connection");
//!     let io = TokioIo::new(stream);
//!     let mut app = app.clone();
//!
//!     ::tokio::task::spawn(async move {
//!         let service = app.call(remote_addr).await.expect("failed to create service");
//!         let hyper_service = TowerToHyperService::new(service);
//!
//!         if let Err(err) = ::hyper::server::conn::http1::Builder::new()
//!             .serve_connection(io, hyper_service)
//!             .await
//!         {
//!             eprintln!("Error serving connection: {:?}", err);
//!         }
//!     });
//! }
//! # }
//! ```
//!
//! ### Running on Lambda
//!
//! ```rust,ignore
//! use pokemon_service_server_sdk::server::routing::LambdaHandler;
//! use pokemon_service_server_sdk::PokemonService;
//!
//! # async fn dummy() {
//! # let app = PokemonService::builder(
//! #     PokemonServiceConfig::builder()
//! #         .build()
//! # ).build_unchecked();
//! let handler = LambdaHandler::new(app);
//! lambda_http::run(handler).await.unwrap();
//! # }
//! ```
//!
//! # Building the PokemonService
//!
//! To construct [`PokemonService`] we use [`PokemonServiceBuilder`] returned by [`PokemonService::builder`].
//!
//! ## Plugins
//!
//! The [`PokemonService::builder`] method, returning [`PokemonServiceBuilder`],
//! accepts a config object on which plugins can be registered.
//! Plugins allow you to build middleware which is aware of the operation it is being applied to.
//!
//! ```rust,no_run
//! # use pokemon_service_server_sdk::server::plugin::IdentityPlugin as LoggingPlugin;
//! # use pokemon_service_server_sdk::server::plugin::IdentityPlugin as MetricsPlugin;
//! use pokemon_service_server_sdk::server::body::BoxBody;
//! use pokemon_service_server_sdk::server::plugin::HttpPlugins;
//! use pokemon_service_server_sdk::{PokemonService, PokemonServiceConfig};
//!
//! let http_plugins = HttpPlugins::new()
//!         .push(LoggingPlugin)
//!         .push(MetricsPlugin);
//! let config = PokemonServiceConfig::builder().http_plugin(http_plugins).build();
//! let _app = PokemonService::builder::<BoxBody, _, _, _>(config).build_unchecked();
//! ```
//!
//! Check out [`crate::server::plugin`] to learn more about plugins.
//!
//! ## Handlers
//!
//! [`PokemonServiceBuilder`] provides a setter method for each operation in your Smithy model. The setter methods expect an async function as input, matching the signature for the corresponding operation in your Smithy model.
//! We call these async functions **handlers**. This is where your application business logic lives.
//!
//! Every handler must take an `Input`, and optional [`extractor arguments`](crate::server::request), while returning:
//!
//! * A `Result<Output, Error>` if your operation has modeled errors, or
//! * An `Output` otherwise.
//!
//! ```rust,no_run
//! # struct Input;
//! # struct Output;
//! # struct Error;
//! async fn infallible_handler(input: Input) -> Output { todo!() }
//!
//! async fn fallible_handler(input: Input) -> Result<Output, Error> { todo!() }
//! ```
//!
//! Handlers can accept up to 8 extractors:
//!
//! ```rust,no_run
//! # struct Input;
//! # struct Output;
//! # struct Error;
//! # struct State;
//! # use std::net::SocketAddr;
//! use pokemon_service_server_sdk::server::request::{extension::Extension, connect_info::ConnectInfo};
//!
//! async fn handler_with_no_extensions(input: Input) -> Output {
//!     todo!()
//! }
//!
//! async fn handler_with_one_extractor(input: Input, ext: Extension<State>) -> Output {
//!     todo!()
//! }
//!
//! async fn handler_with_two_extractors(
//!     input: Input,
//!     ext0: Extension<State>,
//!     ext1: ConnectInfo<SocketAddr>,
//! ) -> Output {
//!     todo!()
//! }
//! ```
//!
//! See the [`operation module`](crate::operation) for information on precisely what constitutes a handler.
//!
//! ## Build
//!
//! You can convert [`PokemonServiceBuilder`] into [`PokemonService`] using either [`PokemonServiceBuilder::build`] or [`PokemonServiceBuilder::build_unchecked`].
//!
//! [`PokemonServiceBuilder::build`] requires you to provide a handler for every single operation in your Smithy model. It will return an error if that is not the case.
//!
//! [`PokemonServiceBuilder::build_unchecked`], instead, does not require exhaustiveness. The server will automatically return 500 Internal Server Error to all requests for operations that do not have a registered handler.
//! [`PokemonServiceBuilder::build_unchecked`] is particularly useful if you are deploying your Smithy service as a collection of Lambda functions, where each Lambda is only responsible for a subset of the operations in the Smithy service (or even a single one!).
//!
//! # Example
//!
//! ```rust,no_run
//! # use std::net::SocketAddr;
//! use pokemon_service_server_sdk::{PokemonService, PokemonServiceConfig};
//!
//! #[::tokio::main]
//! pub async fn main() {
//!    let config = PokemonServiceConfig::builder().build();
//!    let app = PokemonService::builder(config)
//!        .capture_pokemon(capture_pokemon)
//!        .check_health(check_health)
//!        .do_nothing(do_nothing)
//!        .get_pokemon_species(get_pokemon_species)
//!        .get_server_statistics(get_server_statistics)
//!        .get_storage(get_storage)
//!        .stream_pokemon_radio(stream_pokemon_radio)
//!        .build()
//!        .expect("failed to build an instance of PokemonService");
//!
//!    use hyper_util::rt::TokioIo;
//!    use hyper_util::service::TowerToHyperService;
//!    use ::tokio::net::TcpListener;
//!    use ::tower::Service;
//!
//!    let app = app.into_make_service();
//!    let bind: SocketAddr = "127.0.0.1:6969".parse()
//!        .expect("unable to parse the server bind address and port");
//!    let listener = TcpListener::bind(bind).await.expect("failed to bind");
//!
//!    loop {
//!        let (stream, remote_addr) = listener.accept().await.expect("failed to accept connection");
//!        let io = TokioIo::new(stream);
//!        let mut app = app.clone();
//!
//!        ::tokio::task::spawn(async move {
//!            let service = app.call(remote_addr).await.expect("failed to create service");
//!            let hyper_service = TowerToHyperService::new(service);
//!
//!            if let Err(err) = ::hyper::server::conn::http1::Builder::new()
//!                .serve_connection(io, hyper_service)
//!                .await
//!            {
//!                eprintln!("Error serving connection: {:?}", err);
//!            }
//!        });
//!    }
//! }
//!
//! use pokemon_service_server_sdk::{input, output, error};
//!
//! async fn capture_pokemon(input: input::CapturePokemonInput) -> Result<output::CapturePokemonOutput, error::CapturePokemonError> {
//!     todo!()
//! }
//!
//! async fn check_health(input: input::CheckHealthInput) -> output::CheckHealthOutput {
//!     todo!()
//! }
//!
//! async fn do_nothing(input: input::DoNothingInput) -> output::DoNothingOutput {
//!     todo!()
//! }
//!
//! async fn get_pokemon_species(input: input::GetPokemonSpeciesInput) -> Result<output::GetPokemonSpeciesOutput, error::GetPokemonSpeciesError> {
//!     todo!()
//! }
//!
//! async fn get_server_statistics(input: input::GetServerStatisticsInput) -> output::GetServerStatisticsOutput {
//!     todo!()
//! }
//!
//! async fn get_storage(input: input::GetStorageInput) -> Result<output::GetStorageOutput, error::GetStorageError> {
//!     todo!()
//! }
//!
//! async fn stream_pokemon_radio(input: input::StreamPokemonRadioInput) -> output::StreamPokemonRadioOutput {
//!     todo!()
//! }
//!
//! ```
//!
//! [`serve`]: https://docs.rs/hyper/0.14.16/hyper/server/struct.Builder.html#method.serve
//! [`tower::make::MakeService`]: https://docs.rs/tower/latest/tower/make/trait.MakeService.html
//! [HTTP binding traits]: https://smithy.io/2.0/spec/http-bindings.html
//! [operations]: https://smithy.io/2.0/spec/service-types.html#operation
//! [hyper server]: https://docs.rs/hyper/latest/hyper/server/index.html
//! [Service]: https://docs.rs/tower-service/latest/tower_service/trait.Service.html
pub use crate::service::{
    MissingOperationsError, PokemonService, PokemonServiceBuilder, PokemonServiceConfig,
    PokemonServiceConfigBuilder,
};

/// Contains the types that are re-exported from the `aws-smithy-http-server` crate.
pub mod server {
    // Re-export all types from the `aws-smithy-http-server` crate.
    pub use ::aws_smithy_http_server::*;
}

/// Crate version number.
pub static PKG_VERSION: &str = env!("CARGO_PKG_VERSION");

/// All error types that operations can return. Documentation on these types is copied from the model.
pub mod error;

/// Input structures for operations. Documentation on these types is copied from the model.
pub mod input;

/// Data structures used by operation inputs/outputs. Documentation on these types is copied from the model.
pub mod model;

/// All operations that this crate can perform.
pub mod operation;

/// A collection of types representing each operation defined in the service closure.
///
/// The [plugin system](::aws_smithy_http_server::plugin) makes use of these
/// [zero-sized types](https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts) (ZSTs) to
/// parameterize [`Plugin`](::aws_smithy_http_server::plugin::Plugin) implementations. Their traits, such as
/// [`OperationShape`](::aws_smithy_http_server::operation::OperationShape), can be used to provide
/// operation specific information to the [`Layer`](::tower::Layer) being applied.
pub mod operation_shape;

/// Output structures for operations. Documentation on these types is copied from the model.
pub mod output;

mod service;

/// Data primitives referenced by other data types.
pub mod types;

/// Constrained types for constrained shapes.
mod constrained;

mod event_stream_serde;

pub(crate) mod protocol_serde;
