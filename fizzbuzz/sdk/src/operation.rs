// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
static CONTENT_TYPE_FIZZBUZZ: std::sync::LazyLock<::mime::Mime> = std::sync::LazyLock::new(|| {
    "application/cbor"
        .parse::<::mime::Mime>()
        .expect("BUG: MIME parsing failed, content_type is not valid")
});
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`FizzBuzzInput`](crate::input::FizzBuzzInput) using modelled bindings.
    pub struct FizzBuzzInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::FizzBuzzInput, ::aws_smithy_http_server::protocol::rpc_v2_cbor::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for FizzBuzzInputFuture {
    type Output = Result<
        crate::input::FizzBuzzInput,
        ::aws_smithy_http_server::protocol::rpc_v2_cbor::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rpc_v2_cbor::RpcV2Cbor,
        B,
    > for crate::input::FizzBuzzInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B: Into<::aws_smithy_types::byte_stream::ByteStream>,
    B::Data: Send,
    ::aws_smithy_http_server::protocol::rpc_v2_cbor::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rpc_v2_cbor::runtime_error::RuntimeError;
    type Future = FizzBuzzInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_FIZZBUZZ,
            ) {
                return Err(::aws_smithy_http_server::protocol::rpc_v2_cbor::rejection::RequestRejection::NotAcceptable);
            }
            crate::protocol_serde::shape_fizz_buzz::de_fizz_buzz_http_request(request).await
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rpc_v2_cbor::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rpc_v2_cbor::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        FizzBuzzInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rpc_v2_cbor::RpcV2Cbor,
    > for crate::output::FizzBuzzOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_fizz_buzz::ser_fizz_buzz_http_response(self) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rpc_v2_cbor::RpcV2Cbor>::into_response(::aws_smithy_http_server::protocol::rpc_v2_cbor::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rpc_v2_cbor::RpcV2Cbor,
    > for crate::error::FizzBuzzError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_fizz_buzz::ser_fizz_buzz_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rpc_v2_cbor::RpcV2Cbor>::into_response(::aws_smithy_http_server::protocol::rpc_v2_cbor::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
