<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-0034: Smithy Orchestrator - Smithy Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Design Overview</a></li><li class="chapter-item expanded "><a href="../tenets.html"><strong aria-hidden="true">2.</strong> Tenets</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">3.</strong> Design FAQ</a></li><li class="chapter-item expanded "><a href="../transport/overview.html"><strong aria-hidden="true">4.</strong> Transport</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../transport/operation.html"><strong aria-hidden="true">4.1.</strong> HTTP Operations</a></li><li class="chapter-item expanded "><a href="../transport/middleware.html"><strong aria-hidden="true">4.2.</strong> HTTP Middleware</a></li><li class="chapter-item expanded "><a href="../transport/connector.html"><strong aria-hidden="true">4.3.</strong> TLS Connector</a></li></ol></li><li class="chapter-item expanded "><a href="../smithy/overview.html"><strong aria-hidden="true">5.</strong> Smithy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../smithy/simple_shapes.html"><strong aria-hidden="true">5.1.</strong> Simple Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/recursive_shapes.html"><strong aria-hidden="true">5.2.</strong> Recursive Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/aggregate_shapes.html"><strong aria-hidden="true">5.3.</strong> Aggregate Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/endpoint.html"><strong aria-hidden="true">5.4.</strong> Endpoint Resolution</a></li><li class="chapter-item expanded "><a href="../smithy/backwards-compat.html"><strong aria-hidden="true">5.5.</strong> Backwards Compatibility</a></li></ol></li><li class="chapter-item expanded "><a href="../client/overview.html"><strong aria-hidden="true">6.</strong> Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../client/orchestrator.html"><strong aria-hidden="true">6.1.</strong> What is the 'orchestrator' and why does it exist?</a></li><li class="chapter-item expanded "><a href="../client/identity_and_auth.html"><strong aria-hidden="true">6.2.</strong> Identity and Auth</a></li></ol></li><li class="chapter-item expanded "><a href="../server/overview.html"><strong aria-hidden="true">7.</strong> Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/middleware.html"><strong aria-hidden="true">7.1.</strong> Middleware</a></li><li class="chapter-item expanded "><a href="../server/instrumentation.html"><strong aria-hidden="true">7.2.</strong> Instrumentation</a></li><li class="chapter-item expanded "><a href="../server/from_parts.html"><strong aria-hidden="true">7.3.</strong> Accessing Un-modelled Data</a></li><li class="chapter-item expanded "><a href="../server/anatomy.html"><strong aria-hidden="true">7.4.</strong> The Anatomy of a Service</a></li><li class="chapter-item expanded "><a href="../server/code_generation.html"><strong aria-hidden="true">7.5.</strong> Generating Common Service Code</a></li></ol></li><li class="chapter-item expanded "><a href="../rfcs/overview.html"><strong aria-hidden="true">8.</strong> RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rfcs/rfc0001_shared_config.html"><strong aria-hidden="true">8.1.</strong> RFC-0001: Sharing configuration between multiple clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0002_http_versions.html"><strong aria-hidden="true">8.2.</strong> RFC-0002: Supporting multiple HTTP versions for SDKs that use Event Stream</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0003_presigning_api.html"><strong aria-hidden="true">8.3.</strong> RFC-0003: API for Pre-signed URLs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0004_retry_behavior.html"><strong aria-hidden="true">8.4.</strong> RFC-0004: Retry Behavior</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0005_service_generation.html"><strong aria-hidden="true">8.5.</strong> RFC-0005: Smithy Rust service framework</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0006_service_specific_middleware.html"><strong aria-hidden="true">8.6.</strong> RFC-0006: Service-specific middleware</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0007_split_release_process.html"><strong aria-hidden="true">8.7.</strong> RFC-0007: Split release process</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0008_paginators.html"><strong aria-hidden="true">8.8.</strong> RFC-0008: Paginators</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0009_example_consolidation.html"><strong aria-hidden="true">8.9.</strong> RFC-0009: Example Consolidation</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0010_waiters.html"><strong aria-hidden="true">8.10.</strong> RFC-0010: Waiters</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0011_crates_io_alpha_publishing.html"><strong aria-hidden="true">8.11.</strong> RFC-0011: Publishing Alpha to Crates.io</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0012_independent_crate_versioning.html"><strong aria-hidden="true">8.12.</strong> RFC-0012: Independent Crate Versioning</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0013_body_callback_apis.html"><strong aria-hidden="true">8.13.</strong> RFC-0013: Body Callback APIs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0014_timeout_config.html"><strong aria-hidden="true">8.14.</strong> RFC-0014: Fine-grained timeout configuration</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0015_using_features_responsibly.html"><strong aria-hidden="true">8.15.</strong> RFC-0015: How Cargo "features" should be used in the SDK and runtime crates</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0016_flexible_checksum_support.html"><strong aria-hidden="true">8.16.</strong> RFC-0016: Supporting Flexible Checksums</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0017_customizable_client_operations.html"><strong aria-hidden="true">8.17.</strong> RFC-0017: Customizable Client Operations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0018_logging_sensitive.html"><strong aria-hidden="true">8.18.</strong> RFC-0018: Logging in the Presence of Sensitive Data</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0019_event_streams_errors.html"><strong aria-hidden="true">8.19.</strong> RFC-0019: Event Streams Errors</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0020_service_builder.html"><strong aria-hidden="true">8.20.</strong> RFC-0020: Service Builder Improvements</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0021_dependency_versions.html"><strong aria-hidden="true">8.21.</strong> RFC-0021: Dependency Versions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0022_error_context_and_compatibility.html"><strong aria-hidden="true">8.22.</strong> RFC-0022: Error Context and Compatibility</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0023_refine_builder.html"><strong aria-hidden="true">8.23.</strong> RFC-0023: Evolving the new service builder API</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0024_request_id.html"><strong aria-hidden="true">8.24.</strong> RFC-0024: RequestID</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0025_constraint_traits.html"><strong aria-hidden="true">8.25.</strong> RFC-0025: Constraint traits</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0026_client_crate_organization.html"><strong aria-hidden="true">8.26.</strong> RFC-0026: Client Crate Organization</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0027_endpoints_20.html"><strong aria-hidden="true">8.27.</strong> RFC-0027: Endpoints 2.0</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0028_sdk_credential_cache_type_safety.html"><strong aria-hidden="true">8.28.</strong> RFC-0028: SDK Credential Cache Type Safety</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0029_new_home_for_cred_types.html"><strong aria-hidden="true">8.29.</strong> RFC-0029: Finding New Home for Credential Types</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0030_serialization_and_deserialization.html"><strong aria-hidden="true">8.30.</strong> RFC-0030: Serialization And Deserialization</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0031_providing_fallback_credentials_on_timeout.html"><strong aria-hidden="true">8.31.</strong> RFC-0031: Providing Fallback Credentials on Timeout</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0032_better_constraint_violations.html"><strong aria-hidden="true">8.32.</strong> RFC-0032: Better Constraint Violations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0033_improve_sdk_request_id_access.html"><strong aria-hidden="true">8.33.</strong> RFC-0033: Improving access to request IDs in SDK clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0034_smithy_orchestrator.html" class="active"><strong aria-hidden="true">8.34.</strong> RFC-0034: Smithy Orchestrator</a></li></ol></li><li class="chapter-item expanded "><a href="../contributing/overview.html"><strong aria-hidden="true">9.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../contributing/writing_and_debugging_a_low-level_feature_that_relies_on_HTTP.html"><strong aria-hidden="true">9.1.</strong> Writing and debugging a low-level feature that relies on HTTP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Smithy Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="smithy-orchestrator"><a class="header" href="#smithy-orchestrator">Smithy Orchestrator</a></h1>
<blockquote>
<p>status: implemented
applies-to: The smithy client</p>
</blockquote>
<p>This RFC proposes a new process for constructing client requests and handling service responses. This new process is intended to:</p>
<ul>
<li>Improve the user experience by</li>
<li>Simplifying several aspects of sending a request</li>
<li>Adding more extension points to the request/response lifecycle</li>
<li>Improve the maintainer experience by</li>
<li>Making our SDK more similar in structure to other AWS SDKs</li>
<li>Simplifying many aspects of the request/response lifecycle</li>
<li>Making room for future changes</li>
</ul>
<p>Additionally, functionality that the SDKs currently provide like retries, logging, and auth with be incorporated into this new process in such a way as to make it more configurable and understandable.</p>
<p>This RFC references but is not the source of truth on:</p>
<ul>
<li>Interceptors: To be described in depth in a future RFC.</li>
<li>Runtime Plugins: To be described in depth in a future RFC.</li>
</ul>
<h2 id="tldr"><a class="header" href="#tldr">TLDR;</a></h2>
<p>When a smithy client communicates with a smithy service, messages are handled by an &quot;orchestrator.&quot; The orchestrator runs in two main phases:</p>
<ol>
<li>Constructing configuration.
<ul>
<li>This process is user-configurable with &quot;runtime plugins.&quot;</li>
<li>Configuration is stored in a typemap.</li>
</ul>
</li>
<li>Transforming a client request into a server response.
<ul>
<li>This process is user-configurable with &quot;interceptors.&quot;</li>
<li>Interceptors are functions that are run by &quot;hooks&quot; in the request/response lifecycle.</li>
</ul>
</li>
</ol>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<ul>
<li><strong>SDK Client</strong>: A high-level abstraction allowing users to make requests to remote services.</li>
<li><strong>Remote Service</strong>: A remote API that a user wants to use. Communication with a remote service usually happens over HTTP. The remote service is usually, but not necessarily, an AWS service.</li>
<li><strong>Operation</strong>: A high-level abstraction representing an interaction between an *SDK Client and a <em>remote service</em>.</li>
<li><strong>Input Message</strong>: A modeled request passed into an <em>SDK client</em>. For example, S3’s <code>ListObjectsRequest</code>.</li>
<li><strong>Transport Request Message</strong>: A message that can be transmitted to a <em>remote service</em>. For example, an HTTP request.</li>
<li><strong>Transport Response Message</strong>: A message that can be received from a <em>remote service</em>. For example, an HTTP response.</li>
<li><strong>Output Message</strong>: A modeled response or exception returned to an <em>SDK client</em> caller. For example, S3’s <code>ListObjectsResponse</code> or <code>NoSuchBucketException</code>.</li>
<li><strong>The request/response lifecycle</strong>: The process by which an <em>SDK client</em> makes requests and receives responses from a <em>remote service</em>. This process is enacted and managed by the <em>orchestrator</em>.</li>
<li><strong>Orchestrator</strong>: The code within an <em>SDK client</em> that handles the process of making requests and receiving responses from <em>remote services</em>. The orchestrator is configurable by modifying the <em>runtime plugins</em> it's built from. The orchestrator is responsible for calling <em>interceptors</em> at the appropriate times in the <em>request/response lifecycle</em>.</li>
<li><strong>Interceptor</strong>/<strong>Hook</strong>: A generic extension point within the <em>orchestrator</em>. Supports &quot;anything that someone should be able to do&quot;, NOT &quot;anything anyone might want to do&quot;. These hooks are:
<ul>
<li>Either <strong>read-only</strong> or <strong>read/write</strong>.</li>
<li>Able to read and modify the <strong>Input</strong>, <strong>Transport Request</strong>, <strong>Transport Response</strong>, or <strong>Output</strong> messages.</li>
</ul>
</li>
<li><strong>Runtime Plugin</strong>: Runtime plugins are similar to interceptors, but they act on configuration instead of requests and response. Both users and services may define runtime plugins. Smithy also defines several default runtime plugins used by most clients. See the F.A.Q. for a list of plugins with descriptions.</li>
<li><strong>ConfigBag</strong>: A <code>typemap</code> that's equivalent to <a href="https://docs.rs/http/latest/http/struct.Extensions.html"><code>http::Extensions</code></a>. Used to store configuration for the orchestrator.</li>
</ul>
<h2 id="the-user-experience-if-this-rfc-is-implemented"><a class="header" href="#the-user-experience-if-this-rfc-is-implemented">The user experience if this RFC is implemented</a></h2>
<p>For many users, the changes described by this RFC will be invisible. Making a request with an orchestrator-based SDK client looks very similar to the way requests were made pre-RFC:</p>
<pre><code class="language-rust ignore">let sdk_config = aws_config::load_from_env().await;
let client = aws_sdk_s3::Client::new(&amp;sdk_config);
let res = client.get_object()
    .bucket(&quot;a-bucket&quot;)
    .key(&quot;a-file.txt&quot;)
    .send()
    .await?;

match res {
    Ok(res) =&gt; println!(&quot;success: {:?}&quot;),
    Err(err) =&gt; eprintln!(&quot;failure: {:?}&quot;)
};</code></pre>
<p>Users may further configure clients and operations with <strong>runtime plugins</strong>, and they can modify requests and responses with <strong>interceptors</strong>. We'll examine each of these concepts in the following sections.</p>
<h3 id="service-clients-and-operations-are-configured-with-runtime-plugins"><a class="header" href="#service-clients-and-operations-are-configured-with-runtime-plugins">Service clients and operations are configured with runtime plugins</a></h3>
<blockquote>
<p>The exact implementation of <strong>runtime plugins</strong> is left for another RFC. That other RFC will be linked here once it's written. To get an idea of what they may look like, see the <em>&quot;Layered configuration, stored in type maps&quot;</em> section of this RFC.</p>
</blockquote>
<p>Runtime plugins construct and modify client configuration. Plugin initialization is the first step of sending a request, and plugins set in later steps can override the actions of earlier plugins. Plugin ordering is deterministic and non-customizable.</p>
<p>While AWS services define a default set of plugins, users may define their own plugins, and set them by calling the appropriate methods on a service's config, client, or operation. Plugins are specifically meant for constructing service and operation configuration. If a user wants to define behavior that should occur at specific points in the <em>request/response lifecycle</em>, then they should instead consider defining an <em>interceptor</em>.</p>
<h3 id="requests-and-responses-are-modified-by-interceptors"><a class="header" href="#requests-and-responses-are-modified-by-interceptors">Requests and responses are modified by interceptors</a></h3>
<p>Interceptors are similar to middlewares, in that they are functions that can read and modify request and response state. However, they are more restrictive than middlewares in that they can't modify the &quot;control flow&quot; of the request/response lifecycle. This is intentional. Interceptors can be registered on a client or operation, and the orchestrator is responsible for calling interceptors at the appropriate time. Users MUST NOT perform blocking IO within an interceptor. Interceptors are sync, and are not intended to perform large amounts of work. This makes them easier to reason about and use. Depending on when they are called, interceptors may read and modify <em>input messages</em>, <em>transport request messages</em>, <em>transport response messages</em>, and <em>output messages</em>. Additionally, all interceptors may write to a context object that is shared between all interceptors.</p>
<h4 id="currently-supported-hooks"><a class="header" href="#currently-supported-hooks">Currently supported hooks</a></h4>
<ol>
<li><strong>Read Before Execution <em>(Read-Only)</em></strong>: Before anything happens. This is the first
thing the SDK calls during operation execution.</li>
<li><strong>Modify Before Serialization <em>(Read/Write)</em></strong>: Before the input message given by
the customer is marshalled into a transport request message. Allows modifying the
input message.</li>
<li><strong>Read Before Serialization <em>(Read-Only)</em></strong>: The last thing the SDK calls before
marshaling the input message into a transport message.</li>
<li><strong>Read After Serialization <em>(Read-Only)</em></strong>: The first thing the SDK calls after marshaling the input message into a transport message.</li>
<li><em>(Retry Loop)</em>
<ol>
<li><strong>Modify Before Retry Loop <em>(Read/Write)</em></strong>: The last thing the SDK calls before entering the retry look. Allows modifying the transport message.</li>
<li><strong>Read Before Attempt <em>(Read-Only)</em></strong>: The first thing the SDK calls “inside” of the retry loop.</li>
<li><strong>Modify Before Signing <em>(Read/Write)</em></strong>: Before the transport request message is signed. Allows modifying the transport message.</li>
<li><strong>Read Before Signing <em>(Read-Only)</em></strong>: The last thing the SDK calls before signing the transport request message.</li>
<li>**Read After Signing (Read-Only)****: The first thing the SDK calls after signing the transport request message.</li>
<li><strong>Modify Before Transmit <em>(Read/Write)</em></strong>: Before the transport request message is sent to the service. Allows modifying the transport message.</li>
<li><strong>Read Before Transmit <em>(Read-Only)</em></strong>: The last thing the SDK calls before sending the transport request message.</li>
<li><strong>Read After Transmit <em>(Read-Only)</em></strong>: The last thing the SDK calls after receiving the transport response message.</li>
<li><strong>Modify Before Deserialization <em>(Read/Write)</em></strong>: Before the transport response message is unmarshaled. Allows modifying the transport response message.</li>
<li><strong>Read Before Deserialization <em>(Read-Only)</em></strong>: The last thing the SDK calls before unmarshalling the transport response message into an output message.</li>
<li><strong>Read After Deserialization <em>(Read-Only)</em></strong>: The last thing the SDK calls after unmarshaling the transport response message into an output message.</li>
<li><strong>Modify Before Attempt Completion <em>(Read/Write)</em></strong>: Before the retry loop ends. Allows modifying the unmarshaled response (output message or error).</li>
<li><strong>Read After Attempt <em>(Read-Only)</em></strong>: The last thing the SDK calls “inside” of the retry loop.</li>
</ol>
</li>
<li><strong>Modify Before Execution Completion <em>(Read/Write)</em></strong>: Before the execution ends. Allows modifying the unmarshaled response (output message or error).</li>
<li><strong>Read After Execution <em>(Read-Only)</em></strong>: After everything has happened. This is the last thing the SDK calls during operation execution.</li>
</ol>
<h3 id="interceptor-context"><a class="header" href="#interceptor-context">Interceptor context</a></h3>
<p>As mentioned above, interceptors may read/write a context object that is shared between all interceptors:</p>
<pre><code class="language-rust ignore">pub struct InterceptorContext&lt;ModReq, TxReq, TxRes, ModRes&gt; {
    // a.k.a. the input message
    modeled_request: ModReq,
    // a.k.a. the transport request message
    tx_request: Option&lt;TxReq&gt;,
    // a.k.a. the output message
    modeled_response: Option&lt;ModRes&gt;,
    // a.k.a. the transport response message
    tx_response: Option&lt;TxRes&gt;,
    // A type-keyed map
    properties: SharedPropertyBag,
}</code></pre>
<p>The optional request and response types in the interceptor context can only be accessed by interceptors that are run after specific points in the <em>request/response lifecycle</em>. Rather than go into depth in this RFC, I leave that to a future &quot;Interceptors RFC.&quot;</p>
<h2 id="how-to-implement-this-rfc"><a class="header" href="#how-to-implement-this-rfc">How to implement this RFC</a></h2>
<h3 id="integrating-with-the-orchestrator"><a class="header" href="#integrating-with-the-orchestrator">Integrating with the orchestrator</a></h3>
<p>Imagine we have some sort of request signer. This signer doesn't refer to any orchestrator types. All it needs is a <code>HeaderMap</code> along with two strings, and will return a signature in string form.</p>
<pre><code class="language-rust ignore">struct Signer;

impl Signer {
    fn sign(headers: &amp;http::HeaderMap, signing_name: &amp;str, signing_region: &amp;str) -&gt; String {
        todo!()
    }
}</code></pre>
<p>Now imagine things from the orchestrator's point of view. It requires something that implements an <code>AuthOrchestrator</code> which will be responsible for resolving the correct auth
scheme, identity, and signer for an operation, as well as signing the request</p>
<pre><code class="language-rust ignore">pub trait AuthOrchestrator&lt;Req&gt;: Send + Sync + Debug {
    fn auth_request(&amp;self, req: &amp;mut Req, cfg: &amp;ConfigBag) -&gt; Result&lt;(), BoxError&gt;;
}

// And it calls that `AuthOrchestrator` like so:
fn invoke() {
    // code omitted for brevity

    // Get the request to be signed
    let tx_req_mut = ctx.tx_request_mut().expect(&quot;tx_request has been set&quot;);
    // Fetch the auth orchestrator from the bag
    let auth_orchestrator = cfg
        .get::&lt;Box&lt;dyn AuthOrchestrator&lt;Req&gt;&gt;&gt;()
        .ok_or(&quot;missing auth orchestrator&quot;)?;
    // Auth the request
    auth_orchestrator.auth_request(tx_req_mut, cfg)?;

    // code omitted for brevity
}</code></pre>
<p>The specific implementation of the <code>AuthOrchestrator</code> is what brings these two things together:</p>
<pre><code class="language-rust ignore">struct Sigv4AuthOrchestrator;

impl AuthOrchestrator for Sigv4AuthOrchestrator {
    fn auth_request(&amp;self, req: &amp;mut http::Request&lt;SdkBody&gt;, cfg: &amp;ConfigBag) -&gt; Result&lt;(), BoxError&gt; {
        let signer = Signer;
        let signing_name = cfg.get::&lt;SigningName&gt;().ok_or(Error::MissingSigningName)?;
        let signing_region = cfg.get::&lt;SigningRegion&gt;().ok_or(Error::MissingSigningRegion)?;
        let headers = req.headers_mut();

        let signature = signer.sign(headers, signing_name, signing_region);
        match cfg.get::&lt;SignatureLocation&gt;() {
            Some(SignatureLocation::Query) =&gt; req.query.set(&quot;sig&quot;, signature),
            Some(SignatureLocation::Header) =&gt; req.headers_mut().insert(&quot;sig&quot;, signature),
            None =&gt; return Err(Error::MissingSignatureLocation),
        };

        Ok(())
    }
}</code></pre>
<p>This intermediate code should be free from as much logic as possible. Whenever possible, we must maintain this encapsulation. Doing so will make the Orchestrator more flexible, maintainable, and understandable.</p>
<h3 id="layered-configuration-stored-in-type-maps"><a class="header" href="#layered-configuration-stored-in-type-maps">Layered configuration, stored in type maps</a></h3>
<blockquote>
<p><strong>Type map</strong>: A data structure where stored values are keyed by their type. Hence, only one value can be stored for a given type.</p>
<p><em>See <a href="https://docs.rs/typemap">typemap</a>, <a href="https://docs.rs/crate/type-map">type-map</a>, <a href="https://docs.rs/http/latest/http/struct.Extensions.html">http::Extensions</a>, and <a href="https://docs.rs/actix-http/latest/actix_http/struct.Extensions.html">actix_http::Extensions</a> for examples.</em></p>
</blockquote>
<pre><code class="language-rust ignore"> let conf: ConfigBag = aws_config::from_env()
    // Configuration can be common to all smithy clients
    .with(RetryConfig::builder().disable_retries().build())
    // Or, protocol-specific
    .with(HttpClient::builder().build())
    // Or, AWS-specific
    .with(Region::from(&quot;us-east-1&quot;))
    // Or, service-specific
    .with(S3Config::builder().force_path_style(false).build())
    .await;

let client = aws_sdk_s3::Client::new(&amp;conf);

client.list_buckets()
    .customize()
    // Configuration can be set on operations as well as clients
    .with(HttpConfig::builder().conn(some_other_conn).build())
    .send()
    .await;</code></pre>
<p>Setting configuration that will not be used wastes memory and can make debugging more difficult. Therefore, configuration defaults are only set when they're relevant. For example, if a smithy service doesn't support HTTP, then no HTTP client will be set.</p>
<h4 id="what-is-layered-configuration"><a class="header" href="#what-is-layered-configuration">What is &quot;layered&quot; configuration?</a></h4>
<p>Configuration has precedence. Configuration set on an operation will override configuration set on a client, and configuration set on a client will override default configuration. However, configuration with a higher precedence can also augment configuration with a lower precedence. For example:</p>
<pre><code class="language-rust ignore">let conf: ConfigBag = aws_config::from_env()
    .with(
        SomeConfig::builder()
            .option_a(1)
            .option_b(2)
            .option_c(3)
    )
    .build()
    .await;

let client = aws_sdk_s3::Client::new(&amp;conf);

client.list_buckets()
    .customize()
    .with(
        SomeConfig::builder()
            .option_a(0)
            .option_b(Value::Inherit)
            .option_c(Value::Unset)
    )
    .build()
    .send()
    .await;</code></pre>
<p>In the above example, when the <code>option_a</code>, <code>option_b</code>, <code>option_c</code>, values of <code>SomeConfig</code> are accessed, they'll return:</p>
<ul>
<li><code>option_a</code>: <code>0</code></li>
<li><code>option_b</code>: <code>2</code></li>
<li><code>option_c</code>: No value</li>
</ul>
<p>Config values are wrapped in a special enum called <code>Value</code> with three variants:</p>
<ul>
<li><code>Value::Set</code>: A set value that will override values from lower layers.</li>
<li><code>Value::Unset</code>: An explicitly unset value that will override values from lower layers.</li>
<li><code>Value::Inherit</code>: An explicitly unset value that will inherit a value from a lower layer.</li>
</ul>
<p>Builders are defined like this:</p>
<pre><code class="language-rust ignore">struct SomeBuilder {
    value: Value&lt;T&gt;,
}

impl struct SomeBuilder&lt;T&gt; {
    fn new() -&gt; Self {
        // By default, config values inherit from lower-layer configs
        Self { value: Value::Inherit }
    }

    fn some_field(&amp;mut self, value: impl Into&lt;Value&lt;T&gt;&gt;) -&gt; &amp;mut self {
        self.value = value.into();
        self
    }
}</code></pre>
<p>Because of <code>impl Into&lt;Value&lt;T&gt;&gt;</code>, users don't need to reference the <code>Value</code> enum unless they want to &quot;unset&quot; a value.</p>
<h4 id="layer-separation-and-precedence"><a class="header" href="#layer-separation-and-precedence">Layer separation and precedence</a></h4>
<p>Codegen defines default sets of interceptors and runtime plugins at various &quot;levels&quot;:</p>
<ol>
<li>AWS-wide defaults set by codegen.</li>
<li>Service-wide defaults set by codegen.</li>
<li>Operation-specific defaults set by codegen.</li>
</ol>
<p>Likewise, users may mount their own interceptors and runtime plugins:</p>
<ol>
<li>The AWS config level, e.g. <code>aws_types::Config</code>.</li>
<li>The service config level, e.g. <code>aws_sdk_s3::Config</code>.</li>
<li>The operation config level, e.g. <code>aws_sdk_s3::Client::get_object</code>.</li>
</ol>
<p>Configuration is resolved in a fixed manner by reading the &quot;lowest level&quot; of config available, falling back to &quot;higher levels&quot; only when no value has been set. Therefore, at least 3 separate <code>ConfigBag</code>s are necessary, and user configuration has precedence over codegen-defined default configuration. With that in mind, resolution of configuration would look like this:</p>
<ol>
<li>Check user-set operation config.</li>
<li>Check codegen-defined operation config.</li>
<li>Check user-set service config.</li>
<li>Check codegen-defined service config.</li>
<li>Check user-set AWS config.</li>
<li>Check codegen-defined AWS config.</li>
</ol>
<h3 id="the-aws-smithy-orchestrator-crate"><a class="header" href="#the-aws-smithy-orchestrator-crate">The <code>aws-smithy-orchestrator</code> crate</a></h3>
<p><em>I've omitted some of the error conversion to shorten this example and make it easier to understand. The real version will be messier.</em></p>
<pre><code class="language-rust ignore">/// `In`: The input message e.g. `ListObjectsRequest`
/// `Req`: The transport request message e.g. `http::Request&lt;SmithyBody&gt;`
/// `Res`: The transport response message e.g. `http::Response&lt;SmithyBody&gt;`
/// `Out`: The output message. A `Result` containing either:
///     - The 'success' output message e.g. `ListObjectsResponse`
///     - The 'failure' output message e.g. `NoSuchBucketException`
pub async fn invoke&lt;In, Req, Res, T&gt;(
    input: In,
    interceptors: &amp;mut Interceptors&lt;In, Req, Res, Result&lt;T, BoxError&gt;&gt;,
    runtime_plugins: &amp;RuntimePlugins,
    cfg: &amp;mut ConfigBag,
) -&gt; Result&lt;T, BoxError&gt;
    where
        // The input must be Clone in case of retries
        In: Clone + 'static,
        Req: 'static,
        Res: 'static,
        T: 'static,
{
    let mut ctx: InterceptorContext&lt;In, Req, Res, Result&lt;T, BoxError&gt;&gt; =
        InterceptorContext::new(input);

    runtime_plugins.apply_client_configuration(cfg)?;
    interceptors.client_read_before_execution(&amp;ctx, cfg)?;

    runtime_plugins.apply_operation_configuration(cfg)?;
    interceptors.operation_read_before_execution(&amp;ctx, cfg)?;

    interceptors.read_before_serialization(&amp;ctx, cfg)?;
    interceptors.modify_before_serialization(&amp;mut ctx, cfg)?;

    let request_serializer = cfg
        .get::&lt;Box&lt;dyn RequestSerializer&lt;In, Req&gt;&gt;&gt;()
        .ok_or(&quot;missing serializer&quot;)?;
    let req = request_serializer.serialize_request(ctx.modeled_request_mut(), cfg)?;
    ctx.set_tx_request(req);

    interceptors.read_after_serialization(&amp;ctx, cfg)?;
    interceptors.modify_before_retry_loop(&amp;mut ctx, cfg)?;

    loop {
        make_an_attempt(&amp;mut ctx, cfg, interceptors).await?;
        interceptors.read_after_attempt(&amp;ctx, cfg)?;
        interceptors.modify_before_attempt_completion(&amp;mut ctx, cfg)?;

        let retry_strategy = cfg
            .get::&lt;Box&lt;dyn RetryStrategy&lt;Result&lt;T, BoxError&gt;&gt;&gt;&gt;()
            .ok_or(&quot;missing retry strategy&quot;)?;
        let mod_res = ctx
            .modeled_response()
            .expect(&quot;it's set during 'make_an_attempt'&quot;);
        if retry_strategy.should_retry(mod_res, cfg)? {
            continue;
        }

        interceptors.modify_before_completion(&amp;mut ctx, cfg)?;
        let trace_probe = cfg
            .get::&lt;Box&lt;dyn TraceProbe&gt;&gt;()
            .ok_or(&quot;missing trace probes&quot;)?;
        trace_probe.dispatch_events(cfg);
        interceptors.read_after_execution(&amp;ctx, cfg)?;

        break;
    }

    let (modeled_response, _) = ctx.into_responses()?;
    modeled_response
}

// Making an HTTP request can fail for several reasons, but we still need to
// call lifecycle events when that happens. Therefore, we define this
// `make_an_attempt` function to make error handling simpler.
async fn make_an_attempt&lt;In, Req, Res, T&gt;(
    ctx: &amp;mut InterceptorContext&lt;In, Req, Res, Result&lt;T, BoxError&gt;&gt;,
    cfg: &amp;mut ConfigBag,
    interceptors: &amp;mut Interceptors&lt;In, Req, Res, Result&lt;T, BoxError&gt;&gt;,
) -&gt; Result&lt;(), BoxError&gt;
    where
        In: Clone + 'static,
        Req: 'static,
        Res: 'static,
        T: 'static,
{
    interceptors.read_before_attempt(ctx, cfg)?;

    let tx_req_mut = ctx.tx_request_mut().expect(&quot;tx_request has been set&quot;);
    let endpoint_orchestrator = cfg
        .get::&lt;Box&lt;dyn EndpointOrchestrator&lt;Req&gt;&gt;&gt;()
        .ok_or(&quot;missing endpoint orchestrator&quot;)?;
    endpoint_orchestrator.resolve_and_apply_endpoint(tx_req_mut, cfg)?;

    interceptors.modify_before_signing(ctx, cfg)?;
    interceptors.read_before_signing(ctx, cfg)?;

    let tx_req_mut = ctx.tx_request_mut().expect(&quot;tx_request has been set&quot;);
    let auth_orchestrator = cfg
        .get::&lt;Box&lt;dyn AuthOrchestrator&lt;Req&gt;&gt;&gt;()
        .ok_or(&quot;missing auth orchestrator&quot;)?;
    auth_orchestrator.auth_request(tx_req_mut, cfg)?;

    interceptors.read_after_signing(ctx, cfg)?;
    interceptors.modify_before_transmit(ctx, cfg)?;
    interceptors.read_before_transmit(ctx, cfg)?;

    // The connection consumes the request but we need to keep a copy of it
    // within the interceptor context, so we clone it here.
    let res = {
        let tx_req = ctx.tx_request_mut().expect(&quot;tx_request has been set&quot;);
        let connection = cfg
            .get::&lt;Box&lt;dyn Connection&lt;Req, Res&gt;&gt;&gt;()
            .ok_or(&quot;missing connector&quot;)?;
        connection.call(tx_req, cfg).await?
    };
    ctx.set_tx_response(res);

    interceptors.read_after_transmit(ctx, cfg)?;
    interceptors.modify_before_deserialization(ctx, cfg)?;
    interceptors.read_before_deserialization(ctx, cfg)?;
    let tx_res = ctx.tx_response_mut().expect(&quot;tx_response has been set&quot;);
    let response_deserializer = cfg
        .get::&lt;Box&lt;dyn ResponseDeserializer&lt;Res, Result&lt;T, BoxError&gt;&gt;&gt;&gt;()
        .ok_or(&quot;missing response deserializer&quot;)?;
    let res = response_deserializer.deserialize_response(tx_res, cfg)?;
    ctx.set_modeled_response(res);

    interceptors.read_after_deserialization(ctx, cfg)?;

    Ok(())
}</code></pre>
<h4 id="traits"><a class="header" href="#traits">Traits</a></h4>
<p>At various points in the execution of <code>invoke</code>, trait objects are fetched from the <code>ConfigBag</code>. These are preliminary definitions of those traits:</p>
<pre><code class="language-rust ignore">pub trait TraceProbe: Send + Sync + Debug {
    fn dispatch_events(&amp;self, cfg: &amp;ConfigBag) -&gt; BoxFallibleFut&lt;()&gt;;
}

pub trait RequestSerializer&lt;In, TxReq&gt;: Send + Sync + Debug {
    fn serialize_request(&amp;self, req: &amp;mut In, cfg: &amp;ConfigBag) -&gt; Result&lt;TxReq, BoxError&gt;;
}

pub trait ResponseDeserializer&lt;TxRes, Out&gt;: Send + Sync + Debug {
    fn deserialize_response(&amp;self, res: &amp;mut TxRes, cfg: &amp;ConfigBag) -&gt; Result&lt;Out, BoxError&gt;;
}

pub trait Connection&lt;TxReq, TxRes&gt;: Send + Sync + Debug {
    fn call(&amp;self, req: &amp;mut TxReq, cfg: &amp;ConfigBag) -&gt; BoxFallibleFut&lt;TxRes&gt;;
}

pub trait RetryStrategy&lt;Out&gt;: Send + Sync + Debug {
    fn should_retry(&amp;self, res: &amp;Out, cfg: &amp;ConfigBag) -&gt; Result&lt;bool, BoxError&gt;;
}

pub trait AuthOrchestrator&lt;Req&gt;: Send + Sync + Debug {
    fn auth_request(&amp;self, req: &amp;mut Req, cfg: &amp;ConfigBag) -&gt; Result&lt;(), BoxError&gt;;
}

pub trait EndpointOrchestrator&lt;Req&gt;: Send + Sync + Debug {
    fn resolve_and_apply_endpoint(&amp;self, req: &amp;mut Req, cfg: &amp;ConfigBag) -&gt; Result&lt;(), BoxError&gt;;
    fn resolve_auth_schemes(&amp;self) -&gt; Result&lt;Vec&lt;String&gt;, BoxError&gt;;
}</code></pre>
<h2 id="faq"><a class="header" href="#faq">F.A.Q.</a></h2>
<ul>
<li>The orchestrator is a large and complex feature, with many moving parts. How can we ensure that multiple people can contribute in parallel?
<ul>
<li>By defining the entire orchestrator and agreeing on its structure, we can then move on to working on individual runtime plugins and interceptors.</li>
</ul>
</li>
<li>What is the precedence of interceptors?
<ul>
<li>The precedence of interceptors is as follows:
<ul>
<li>Interceptors registered via Smithy default plugins.</li>
<li><em>(AWS Services only)</em> Interceptors registered via AWS default plugins.</li>
<li>Interceptors registered via service-customization plugins.</li>
<li>Interceptors registered via client-level plugins.</li>
<li>Interceptors registered via client-level configuration.</li>
<li>Interceptors registered via operation-level plugins.</li>
<li>Interceptors registered via operation-level configuration.</li>
</ul>
</li>
</ul>
</li>
<li>What runtime plugins will be defined in <code>smithy-rs</code>?
<ul>
<li><code>RetryStrategy</code>: Configures how requests are retried.</li>
<li><code>TraceProbes</code>: Configures locations to which SDK metrics are published.</li>
<li><code>EndpointProviders</code>: Configures which hostname an SDK will call when making a request.</li>
<li><code>HTTPClients</code>: Configures how remote services are called.</li>
<li><code>IdentityProviders</code>: Configures how customers identify themselves to remote services.</li>
<li><code>HTTPAuthSchemes</code> &amp; <code>AuthSchemeResolvers</code>: Configures how customers authenticate themselves to remote services.</li>
<li><code>Checksum Algorithms</code>: Configures how an SDK calculates request and response checksums.</li>
</ul>
</li>
</ul>
<h2 id="changes-checklist"><a class="header" href="#changes-checklist">Changes checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Create a new <code>aws-smithy-runtime</code> crate.
<ul>
<li>Add orchestrator implementation</li>
<li>Define the orchestrator/runtime plugin interface traits
<ul>
<li><code>TraceProbe</code></li>
<li><code>RequestSerializer&lt;In, TxReq&gt;</code></li>
<li><code>ResponseDeserializer&lt;TxRes, Out&gt;</code></li>
<li><code>Connection&lt;TxReq, TxRes&gt;</code></li>
<li><code>RetryStrategy&lt;Out&gt;</code></li>
<li><code>AuthOrchestrator&lt;Req&gt;</code></li>
<li><code>EndpointOrchestrator&lt;Req&gt;</code></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Create a new <code>aws-smithy-runtime-api</code> crate.
<ul>
<li>Add <code>ConfigBag</code> module</li>
<li>Add <code>retries</code> module
<ul>
<li>Add <code>rate_limiting</code> sub-module</li>
</ul>
</li>
<li>Add <code>interceptors</code> module
<ul>
<li><code>Interceptor</code> trait</li>
<li><code>InterceptorContext</code> impl</li>
</ul>
</li>
<li>Add <code>runtime_plugins</code> module</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Create a new integration test that ensures the orchestrator works.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rfcs/rfc0033_improve_sdk_request_id_access.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../contributing/overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rfcs/rfc0033_improve_sdk_request_id_access.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../contributing/overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../static/mermaid.min.js"></script>
        <script src="../static/mermaid-init.js"></script>


    </div>
    </body>
</html>
