<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-0023: Evolving the new service builder API - Smithy Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Design Overview</a></li><li class="chapter-item expanded "><a href="../tenets.html"><strong aria-hidden="true">2.</strong> Tenets</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">3.</strong> Design FAQ</a></li><li class="chapter-item expanded "><a href="../transport/overview.html"><strong aria-hidden="true">4.</strong> Transport</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../transport/operation.html"><strong aria-hidden="true">4.1.</strong> HTTP Operations</a></li><li class="chapter-item expanded "><a href="../transport/middleware.html"><strong aria-hidden="true">4.2.</strong> HTTP Middleware</a></li><li class="chapter-item expanded "><a href="../transport/connector.html"><strong aria-hidden="true">4.3.</strong> TLS Connector</a></li></ol></li><li class="chapter-item expanded "><a href="../smithy/overview.html"><strong aria-hidden="true">5.</strong> Smithy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../smithy/simple_shapes.html"><strong aria-hidden="true">5.1.</strong> Simple Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/recursive_shapes.html"><strong aria-hidden="true">5.2.</strong> Recursive Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/aggregate_shapes.html"><strong aria-hidden="true">5.3.</strong> Aggregate Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/endpoint.html"><strong aria-hidden="true">5.4.</strong> Endpoint Resolution</a></li><li class="chapter-item expanded "><a href="../smithy/backwards-compat.html"><strong aria-hidden="true">5.5.</strong> Backwards Compatibility</a></li></ol></li><li class="chapter-item expanded "><a href="../client/overview.html"><strong aria-hidden="true">6.</strong> Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../client/orchestrator.html"><strong aria-hidden="true">6.1.</strong> What is the 'orchestrator' and why does it exist?</a></li><li class="chapter-item expanded "><a href="../client/identity_and_auth.html"><strong aria-hidden="true">6.2.</strong> Identity and Auth</a></li></ol></li><li class="chapter-item expanded "><a href="../server/overview.html"><strong aria-hidden="true">7.</strong> Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/middleware.html"><strong aria-hidden="true">7.1.</strong> Middleware</a></li><li class="chapter-item expanded "><a href="../server/instrumentation.html"><strong aria-hidden="true">7.2.</strong> Instrumentation</a></li><li class="chapter-item expanded "><a href="../server/from_parts.html"><strong aria-hidden="true">7.3.</strong> Accessing Un-modelled Data</a></li><li class="chapter-item expanded "><a href="../server/anatomy.html"><strong aria-hidden="true">7.4.</strong> The Anatomy of a Service</a></li><li class="chapter-item expanded "><a href="../server/code_generation.html"><strong aria-hidden="true">7.5.</strong> Generating Common Service Code</a></li></ol></li><li class="chapter-item expanded "><a href="../rfcs/overview.html"><strong aria-hidden="true">8.</strong> RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rfcs/rfc0001_shared_config.html"><strong aria-hidden="true">8.1.</strong> RFC-0001: Sharing configuration between multiple clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0002_http_versions.html"><strong aria-hidden="true">8.2.</strong> RFC-0002: Supporting multiple HTTP versions for SDKs that use Event Stream</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0003_presigning_api.html"><strong aria-hidden="true">8.3.</strong> RFC-0003: API for Pre-signed URLs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0004_retry_behavior.html"><strong aria-hidden="true">8.4.</strong> RFC-0004: Retry Behavior</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0005_service_generation.html"><strong aria-hidden="true">8.5.</strong> RFC-0005: Smithy Rust service framework</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0006_service_specific_middleware.html"><strong aria-hidden="true">8.6.</strong> RFC-0006: Service-specific middleware</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0007_split_release_process.html"><strong aria-hidden="true">8.7.</strong> RFC-0007: Split release process</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0008_paginators.html"><strong aria-hidden="true">8.8.</strong> RFC-0008: Paginators</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0009_example_consolidation.html"><strong aria-hidden="true">8.9.</strong> RFC-0009: Example Consolidation</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0010_waiters.html"><strong aria-hidden="true">8.10.</strong> RFC-0010: Waiters</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0011_crates_io_alpha_publishing.html"><strong aria-hidden="true">8.11.</strong> RFC-0011: Publishing Alpha to Crates.io</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0012_independent_crate_versioning.html"><strong aria-hidden="true">8.12.</strong> RFC-0012: Independent Crate Versioning</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0013_body_callback_apis.html"><strong aria-hidden="true">8.13.</strong> RFC-0013: Body Callback APIs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0014_timeout_config.html"><strong aria-hidden="true">8.14.</strong> RFC-0014: Fine-grained timeout configuration</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0015_using_features_responsibly.html"><strong aria-hidden="true">8.15.</strong> RFC-0015: How Cargo "features" should be used in the SDK and runtime crates</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0016_flexible_checksum_support.html"><strong aria-hidden="true">8.16.</strong> RFC-0016: Supporting Flexible Checksums</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0017_customizable_client_operations.html"><strong aria-hidden="true">8.17.</strong> RFC-0017: Customizable Client Operations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0018_logging_sensitive.html"><strong aria-hidden="true">8.18.</strong> RFC-0018: Logging in the Presence of Sensitive Data</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0019_event_streams_errors.html"><strong aria-hidden="true">8.19.</strong> RFC-0019: Event Streams Errors</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0020_service_builder.html"><strong aria-hidden="true">8.20.</strong> RFC-0020: Service Builder Improvements</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0021_dependency_versions.html"><strong aria-hidden="true">8.21.</strong> RFC-0021: Dependency Versions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0022_error_context_and_compatibility.html"><strong aria-hidden="true">8.22.</strong> RFC-0022: Error Context and Compatibility</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0023_refine_builder.html" class="active"><strong aria-hidden="true">8.23.</strong> RFC-0023: Evolving the new service builder API</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0024_request_id.html"><strong aria-hidden="true">8.24.</strong> RFC-0024: RequestID</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0025_constraint_traits.html"><strong aria-hidden="true">8.25.</strong> RFC-0025: Constraint traits</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0026_client_crate_organization.html"><strong aria-hidden="true">8.26.</strong> RFC-0026: Client Crate Organization</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0027_endpoints_20.html"><strong aria-hidden="true">8.27.</strong> RFC-0027: Endpoints 2.0</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0028_sdk_credential_cache_type_safety.html"><strong aria-hidden="true">8.28.</strong> RFC-0028: SDK Credential Cache Type Safety</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0029_new_home_for_cred_types.html"><strong aria-hidden="true">8.29.</strong> RFC-0029: Finding New Home for Credential Types</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0030_serialization_and_deserialization.html"><strong aria-hidden="true">8.30.</strong> RFC-0030: Serialization And Deserialization</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0031_providing_fallback_credentials_on_timeout.html"><strong aria-hidden="true">8.31.</strong> RFC-0031: Providing Fallback Credentials on Timeout</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0032_better_constraint_violations.html"><strong aria-hidden="true">8.32.</strong> RFC-0032: Better Constraint Violations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0033_improve_sdk_request_id_access.html"><strong aria-hidden="true">8.33.</strong> RFC-0033: Improving access to request IDs in SDK clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0034_smithy_orchestrator.html"><strong aria-hidden="true">8.34.</strong> RFC-0034: Smithy Orchestrator</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0035_collection_defaults.html"><strong aria-hidden="true">8.35.</strong> RFC-0035: Collection Defaults</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0036_http_dep_elimination.html"><strong aria-hidden="true">8.36.</strong> RFC-0036: HTTP Dependency Exposure</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0037_http_wrapper.html"><strong aria-hidden="true">8.37.</strong> RFC-0037: The HTTP Wrapper</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0038_retry_classifier_customization.html"><strong aria-hidden="true">8.38.</strong> RFC-0038: User-configurable retry classification</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0039_forward_compatible_errors.html"><strong aria-hidden="true">8.39.</strong> RFC-0039: Forward Compatible Errors</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0040_behavior_versions.html"><strong aria-hidden="true">8.40.</strong> RFC-0040: Behavior Versions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0041_improve_client_error_ergonomics.html"><strong aria-hidden="true">8.41.</strong> RFC-0041: Improve client error ergonomics</a></li></ol></li><li class="chapter-item expanded "><a href="../contributing/overview.html"><strong aria-hidden="true">9.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../contributing/writing_and_debugging_a_low-level_feature_that_relies_on_HTTP.html"><strong aria-hidden="true">9.1.</strong> Writing and debugging a low-level feature that relies on HTTP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Smithy Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rfc-evolving-the-new-service-builder-api"><a class="header" href="#rfc-evolving-the-new-service-builder-api">RFC: Evolving the new service builder API</a></h1>
<blockquote>
<p>Status: Accepted</p>
<p>Applies to: Server</p>
</blockquote>
<p><a href="rfc0020_service_builder.html">RFC 20</a> introduced a new service builder API.
It supports fine-grained configuration at multiple levels (per-handler middlewares, router middlewares, plugins) while trying to prevent some misconfiguration issues at compile-time (i.e. missing operation handlers).
There is consensus that the new API is an improvement over the pre-existing <code>OperationRegistryBuilder</code>/<code>OperationRegistry</code>, which is now on its way to deprecation in one of the next releases.</p>
<p>This RFC builds on top of <a href="rfc0020_service_builder.html">RFC 20</a> to explore an alternative API design prior to its stabilisation.
The API proposed in this RFC has been manually implemented for the Pokemon service. You can find the code <a href="https://github.com/LukeMathWalker/builder-experiments">here</a>.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Type-heavy builders can lead to a poor developer experience when it comes to writing function signatures, conditional branches and clarity of error messages.
This RFC provides examples for the issues we are trying to mitigate and showcases an alternative design for the service builder, cutting generic parameters from 2*(N+1) to 2, where <code>N</code> is the number of operations on the service.
We rely on eagerly upgrading the registered handlers and operations to <code>Route&lt;B&gt;</code> to achieve this reduction.</p>
<p>Goals:</p>
<ul>
<li>Maximise API ergonomics, with a particular focus on the developer experience for Rust beginners.</li>
</ul>
<p>Strategy:</p>
<ul>
<li>Reduce type complexity, exposing a less generic API;</li>
<li>Provide clearer errors when the service builder is misconfigured.</li>
</ul>
<p>Trade-offs:</p>
<ul>
<li>Reduce compile-time safety. Missing handlers will be detected at runtime instead of compile-time.</li>
</ul>
<p>Constraints:</p>
<ul>
<li>There should be no significant degradation in runtime performance (i.e. startup time for applications).</li>
</ul>
<h2 id="handling-missing-operations"><a class="header" href="#handling-missing-operations">Handling missing operations</a></h2>
<p>Let's start by reviewing the API proposed in <a href="rfc0020_service_builder.html">RFC 20</a>. We will use the <a href="https://github.com/smithy-lang/smithy-rs/blob/c7ddb164b28b920313432789cfe05d8112a035cc/codegen-core/common-test-models/pokemon.smithy">Pokemon service</a> as our driving example throughout the RFC.
This is what the startup code looks like:</p>
<pre><code class="language-rust ignore">#[tokio::main]
pub async fn main() {
    // [...]
    let app = PokemonService::builder()
        .get_pokemon_species(get_pokemon_species)
        .get_storage(get_storage)
        .get_server_statistics(get_server_statistics)
        .capture_pokemon(capture_pokemon)
        .do_nothing(do_nothing)
        .check_health(check_health)
        .build();

    // Setup shared state and middlewares.
    let shared_state = Arc::new(State::default());
    let app = app.layer(&amp;AddExtensionLayer::new(shared_state));

    // Start the [`hyper::Server`].
    let bind: SocketAddr = /* */;
    let server = hyper::Server::bind(&amp;bind).serve(app.into_make_service());
    // [...]
}</code></pre>
<p>The builder is infallible: we are able to verify at compile-time that all handlers have been provided using the <a href="https://www.greyblake.com/blog/builder-with-typestate-in-rust/">typestate builder pattern</a>.</p>
<h3 id="compiler-errors-cannot-be-tuned"><a class="header" href="#compiler-errors-cannot-be-tuned">Compiler errors cannot be tuned</a></h3>
<p>What happens if we stray away from the happy path? We might forget, for example, to add the <code>check_health</code> handler.
The compiler greets us with this error:</p>
<pre><code class="language-text">error[E0277]: the trait bound `MissingOperation: Upgradable&lt;AwsRestJson1, CheckHealth, (), _, IdentityPlugin&gt;` is not satisfied
  --&gt; pokemon-service/src/bin/pokemon-service.rs:38:10
   |
38 |         .build();
   |          ^^^^^ the trait `Upgradable&lt;AwsRestJson1, CheckHealth, (), _, IdentityPlugin&gt;` is not implemented for `MissingOperation`
   |
   = help: the following other types implement trait `Upgradable&lt;Protocol, Operation, Exts, B, Plugin&gt;`:
             FailOnMissingOperation
             Operation&lt;S, L&gt;
</code></pre>
<p>The compiler complains that <code>MissingOperation</code> does not implement the <code>Upgradable</code> trait. Neither <code>MissingOperation</code> nor <code>Upgradable</code> appear in the startup code we looked at. This is likely to be the first time the developer sees those traits, assuming they haven't spent time getting familiar with <code>aws-smithy-http-server</code>'s internals.
The <code>help</code> section is unhelpful, if not actively misdirecting.
How can the developer figure out that the issue lies with <code>check_health</code>?
They need to inspect the generic parameters attached to <code>Upgradable</code> in the code label or the top-level error message - we see, among other things, a <code>CheckHealth</code> parameter. That is the hint they need to follow to move forward.</p>
<p>We unfortunately do not have agency on the compiler error we just examined. Rust does not expose hooks for crate authors to tweak the errors returned when a type does not implement a trait we defined.
All implementations of the <a href="https://www.greyblake.com/blog/builder-with-typestate-in-rust/">typestate builder pattern</a> accept this shortcoming in exchange for compile-time safety.</p>
<p>Is it a good tradeoff in our case?</p>
<h3 id="the-cost-of-a-runtime-error"><a class="header" href="#the-cost-of-a-runtime-error">The cost of a runtime error</a></h3>
<p>If <code>build</code> returns an error, the HTTP server is never launched. The application fails to start.</p>
<p>Let's examine the cost of this runtime error along two dimensions:</p>
<ul>
<li>Impact on developer productivity;</li>
<li>Impact on end users.</li>
</ul>
<p>We'd love for this issue to be caught on the developer machine - it provides the shortest feedback loop.
The issue won't be surfaced by a <code>cargo check</code> or <code>cargo build</code> invocation, as it happens with the typestate builder approach.
It should be surfaced by executing the application test suite, assuming that the developer has written at least a single integration test - e.g. a test that passes a request to the <code>call</code> method exposed by <code>PokemonService</code> or launches a full-blown instance of the application which is then probed via an HTTP client.</p>
<p>If there are no integration tests, the issue won't be detected on the developer machine nor in CI.
Nonetheless, it is unlikely to cause any end-user impact even if it manages to escape detection and reach production. The deployment will never complete if they are using a progressive rollout strategy: instances of the new version will crash as soon as they are launched, never getting a chance to mark themselves as healthy; all traffic will keep being handled by the old version, with no visible impact on end users of the application.</p>
<p>Given the above, we think that the impact of a runtime error is low enough to be worth exploring designs that do not guarantee compile-safety for the builder API<sup class="footnote-reference"><a href="#further-dev-productivity-improvements">1</a></sup>.</p>
<h3 id="providing-clear-feedback"><a class="header" href="#providing-clear-feedback">Providing clear feedback</a></h3>
<p>Moving from a compile-time error to a runtime error does not require extensive refactoring.
The definition of <code>PokemonServiceBuilder</code> goes from:</p>
<pre><code class="language-rust ignore">pub struct PokemonServiceBuilder&lt;
    Op1,
    Op2,
    Op3,
    Op4,
    Op5,
    Op6,
    Exts1 = (),
    Exts2 = (),
    Exts3 = (),
    Exts4 = (),
    Exts5 = (),
    Exts6 = (),
    Pl = aws_smithy_http_server::plugin::IdentityPlugin,
&gt; {
    check_health: Op1,
    do_nothing: Op2,
    get_pokemon_species: Op3,
    get_server_statistics: Op4,
    capture_pokemon: Op5,
    get_storage: Op6,
    #[allow(unused_parens)]
    _exts: std::marker::PhantomData&lt;(Exts1, Exts2, Exts3, Exts4, Exts5, Exts6)&gt;,
    plugin: Pl,
}</code></pre>
<p>to:</p>
<pre><code class="language-rust ignore">pub struct PokemonServiceBuilder&lt;
    Op1,
    Op2,
    Op3,
    Op4,
    Op5,
    Op6,
    Exts1 = (),
    Exts2 = (),
    Exts3 = (),
    Exts4 = (),
    Exts5 = (),
    Exts6 = (),
    Pl = aws_smithy_http_server::plugin::IdentityPlugin,
&gt; {
    check_health: Option&lt;Op1&gt;,
    do_nothing: Option&lt;Op2&gt;,
    get_pokemon_species: Option&lt;Op3&gt;,
    get_server_statistics: Option&lt;Op4&gt;,
    capture_pokemon: Option&lt;Op5&gt;,
    get_storage: Option&lt;Op6&gt;,
    #[allow(unused_parens)]
    _exts: std::marker::PhantomData&lt;(Exts1, Exts2, Exts3, Exts4, Exts5, Exts6)&gt;,
    plugin: Pl,
}</code></pre>
<p>All operation fields are now <code>Option</code>-wrapped.
We introduce a new <code>MissingOperationsError</code> error to hold the names of the missing operations and their respective setter methods:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
pub struct MissingOperationsError {
    service_name: &amp;'static str,
    operation_names2setter_methods: HashMap&lt;&amp;'static str, &amp;'static str&gt;,
}

impl Display for MissingOperationsError { /* */ }
impl std::error::Error for MissingOperationsError {}</code></pre>
<p>which is then used in <code>build</code> as error type <em>(not shown here for brevity)</em>.
We can now try again to stray away from the happy path by forgetting to register a handler for the <code>CheckHealth</code> operation.
The code compiles just fine this time, but the application fails when launched via <code>cargo run</code>:</p>
<pre><code class="language-text">&lt;timestamp&gt; ERROR pokemon_service: You must specify a handler for all operations attached to the `Pokemon` service.
We are missing handlers for the following operations:
- com.aws.example#CheckHealth

Use the dedicated methods on `PokemonServiceBuilder` to register the missing handlers:
- PokemonServiceBuilder::check_health
</code></pre>
<p>The error speaks the language of the domain, Smithy's interface definition language: it mentions operations, services, handlers.
Understanding the error requires no familiarity with <code>smithy-rs</code>' internal type machinery or advanced trait patterns in Rust.
We can also provide actionable suggestions: Rust beginners should be able to easily process the information, rectify the mistake and move on quickly.</p>
<h2 id="simplifying-pokemonservicebuilders-signature"><a class="header" href="#simplifying-pokemonservicebuilders-signature">Simplifying <code>PokemonServiceBuilder</code>'s signature</a></h2>
<p>Let's take a second look at the (updated) definition of <code>PokemonServiceBuilder</code>:</p>
<pre><code class="language-rust ignore">pub struct PokemonServiceBuilder&lt;
    Op1,
    Op2,
    Op3,
    Op4,
    Op5,
    Op6,
    Exts1 = (),
    Exts2 = (),
    Exts3 = (),
    Exts4 = (),
    Exts5 = (),
    Exts6 = (),
    Pl = aws_smithy_http_server::plugin::IdentityPlugin,
&gt; {
    check_health: Option&lt;Op1&gt;,
    do_nothing: Option&lt;Op2&gt;,
    get_pokemon_species: Option&lt;Op3&gt;,
    get_server_statistics: Option&lt;Op4&gt;,
    capture_pokemon: Option&lt;Op5&gt;,
    get_storage: Option&lt;Op6&gt;,
    #[allow(unused_parens)]
    _exts: std::marker::PhantomData&lt;(Exts1, Exts2, Exts3, Exts4, Exts5, Exts6)&gt;,
    plugin: Pl,
}</code></pre>
<p>We have 13 generic parameters:</p>
<ul>
<li>1 for plugins (<code>Pl</code>);</li>
<li>2 for each operation (<code>OpX</code> and <code>ExtsX</code>);</li>
</ul>
<p>All those generic parameters were necessary when we were using the <a href="https://www.greyblake.com/blog/builder-with-typestate-in-rust/">typestate builder pattern</a>. They kept track of which operation handlers were missing: if any <code>OpX</code> was set to <code>MissingOperation</code> when calling <code>build</code> -&gt; compilation error!</p>
<p>Do we still need all those generic parameters if we move forward with this RFC?
You might be asking yourselves: why do those generics bother us? Is there any harm in keeping them around?
We'll look at the impact of those generic parameters on two scenarios:</p>
<ul>
<li>Branching in startup logic;</li>
<li>Breaking down a monolithic startup function into multiple smaller functions.</li>
</ul>
<h3 id="branching---incompatible-types"><a class="header" href="#branching---incompatible-types">Branching -&gt; "Incompatible types"</a></h3>
<p>Conditional statements appear quite often in the startup logic for an application (or in the setup code for its integration tests).
Let's consider a toy example: if a <code>check_database</code> flag is set to <code>true</code>, we want to register a different <code>check_health</code> handler - one that takes care of pinging the database to make sure it's up.</p>
<p>The "obvious" solution would look somewhat like this:</p>
<pre><code class="language-rust ignore">let check_database: bool = /* */;
let app = if check_database {
    app.check_health(check_health)
} else {
    app.check_health(check_health_with_database)
};
app.build();</code></pre>
<p>The compiler is not pleased:</p>
<pre><code class="language-text">error[E0308]: `if` and `else` have incompatible types
  --&gt; pokemon-service/src/bin/pokemon-service.rs:39:9
   |
36 |       let app = if check_database {
   |  _______________-
37 | |         app.check_health(check_health)
   | |         ------------------------------ expected because of this
38 | |     } else {
39 | |         app.check_health(check_health_with_database)
   | |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected fn item, found a different fn item
40 | |     };
   | |_____- `if` and `else` have incompatible types
   |
   = note: expected struct `PokemonServiceBuilder&lt;Operation&lt;IntoService&lt;_, fn(CheckHealthInput) -&gt; impl Future&lt;Output =
    CheckHealthOutput&gt; {check_health}&gt;&gt;, _, _, _, _, _, _, _, _, _, _, _&gt;`
              found struct `PokemonServiceBuilder&lt;Operation&lt;IntoService&lt;_, fn(CheckHealthInput) -&gt; impl Future&lt;Output =
    CheckHealthOutput&gt; {check_health_with_database}&gt;&gt;, _, _, _, _, _, _, _, _, _, _, _&gt;`
</code></pre>
<p>The developer must be aware of the following facts to unpack the error message:</p>
<ol>
<li>The two branches of an <code>if</code>/<code>else</code> statement need to return the same type.</li>
<li>Each function closure has a new unique type (represented as <code>fn(CheckHealthInput) -&gt; impl Future&lt;Output =  CheckHealthOutput&gt; {check_health}</code> for <code>check_health</code>);</li>
<li>The handler function type becomes part of the overall <code>PokemonServiceBuilder</code> type, a cog in the larger <code>Op1</code> generic parameter used to hold the handler for the <code>CheckHealth</code> operation (i.e. <code>Operation&lt;IntoService&lt;_, fn(CheckHealthInput) -&gt; impl Future&lt;Output =  CheckHealthOutput&gt; {check_health}&gt;&gt;</code>);</li>
</ol>
<p>The second fact requires an intermediate understanding of Rust's closures and opaque types (<code>impl Trait</code>). It's quite likely to confuse Rust beginners.</p>
<p>The developer has three options to move forward:</p>
<ol>
<li>Convert <code>check_health</code> and <code>check_health_with_database</code> into a common type that can be passed as a handler to <code>PokemonServiceBuilder::check_health</code>;</li>
<li>Invoke the <code>build</code> method inside the two branches in order to return a "plain" <code>PokemonService&lt;Route&lt;B&gt;&gt;</code> from both branches.</li>
<li>Embed the configuration parameter (<code>check_database</code>) in the application state, retrieve it inside <code>check_health</code> and perform the branching there.</li>
</ol>
<p>I can't easily see a way to accomplish 1) using the current API. Pursuing 2) is straight-forward with a single conditional:</p>
<pre><code class="language-rust ignore">let check_database: bool = /* */;
let app = if check_database {
    app.check_health(check_health).build()
} else {
    app.check_health(check_health_with_database).build()
};</code></pre>
<p>It becomes more cumbersome when we have more than a single conditional:</p>
<pre><code class="language-rust ignore">let check_database: bool = /* */;
let include_cpu_statics: bool = /* */;
match (check_database, include_cpu_statics) {
    (true, true) =&gt; app
        .check_health(check_health_with_database)
        .get_server_statistics(get_server_statistics_with_cpu)
        .build(),
    (true, false) =&gt; app
        .check_health(check_health_with_database)
        .get_server_statistics(get_server_statistics)
        .build(),
    (false, true) =&gt; app
        .check_health(check_health)
        .get_server_statistics(get_server_statistics_with_cpu())
        .build(),
    (false, false) =&gt; app
        .check_health(check_health)
        .get_server_statistics(get_server_statistics)
        .build(),
}</code></pre>
<p>A lot of repetition compared to the code for the "obvious" approach:</p>
<pre><code class="language-rust ignore">let check_database: bool = /* */;
let include_cpu_statics: bool = /* */;
let app = if check_database {
    app.check_health(check_health)
} else {
    app.check_health(check_health_with_database)
};
let app = if include_cpu_statistics {
    app.get_server_statistics(get_server_statistics_with_cpu)
} else {
    app.get_server_statistics(get_server_statistics)
};
app.build();</code></pre>
<p>The obvious approach becomes viable if we stop embedding the handler function type in <code>PokemonServiceBuilder</code>'s overall type.</p>
<h3 id="refactoring-into-smaller-functions---prepare-for-some-type-juggling"><a class="header" href="#refactoring-into-smaller-functions---prepare-for-some-type-juggling">Refactoring into smaller functions -&gt; Prepare for some type juggling!</a></h3>
<p>Services with a high number of routes can lead to fairly long startup routines.
Developers might be tempted to break down the startup routine into smaller functions, grouping together operations with common requirements (similar domain, same middlewares, etc.).</p>
<p>What does the signature of those smaller functions look like?
The service builder must be one of the arguments if we want to register handlers. We must also return it to allow the orchestrating function to finish the application setup (our setters take ownership of <code>self</code>).</p>
<p>A first sketch:</p>
<pre><code class="language-rust ignore">fn partial_setup(builder: PokemonServiceBuilder) -&gt; PokemonServiceBuilder {
    /* */
}</code></pre>
<p>The compiler demands to see those generic parameters in the signature:</p>
<pre><code class="language-text">error[E0107]: missing generics for struct `PokemonServiceBuilder`
  --&gt; pokemon-service/src/bin/pokemon-service.rs:28:27
   |
28 | fn partial_setup(builder: PokemonServiceBuilder) -&gt; PokemonServiceBuilder {
   |                           ^^^^^^^^^^^^^^^^^^^^^ expected at least 6 generic arguments
   |
note: struct defined here, with at least 6 generic parameters: `Op1`, `Op2`, `Op3`, `Op4`, `Op5`, `Op6`

error[E0107]: missing generics for struct `PokemonServiceBuilder`
  --&gt; pokemon-service/src/bin/pokemon-service.rs:28:53
   |
28 | fn partial_setup(builder: PokemonServiceBuilder) -&gt; PokemonServiceBuilder {
   |                                                     ^^^^^^^^^^^^^^^^^^^^^ expected at least 6 generic arguments
   |
note: struct defined here, with at least 6 generic parameters: `Op1`, `Op2`, `Op3`, `Op4`, `Op5`, `Op6`
</code></pre>
<p>We could try to nudge the compiler into inferring them:</p>
<pre><code class="language-rust ignore">fn partial_setup(
    builder: PokemonServiceBuilder&lt;_, _, _, _, _, _&gt;,
) -&gt; PokemonServiceBuilder&lt;_, _, _, _, _, _&gt; {
    /* */
}</code></pre>
<p>but that won't fly either:</p>
<pre><code class="language-text">error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types
  --&gt; pokemon-service/src/bin/pokemon-service.rs:30:28
   |
30 | ) -&gt; PokemonServiceBuilder&lt;_, _, _, _, _, _&gt; {
   |                            ^  ^  ^  ^  ^  ^ not allowed in type signatures
   |                            |  |  |  |  |
   |                            |  |  |  |  not allowed in type signatures
   |                            |  |  |  not allowed in type signatures
   |                            |  |  not allowed in type signatures
   |                            |  not allowed in type signatures
   |                            not allowed in type signatures
</code></pre>
<p>We must type it all out:</p>
<pre><code class="language-rust ignore">fn partial_setup&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt;(
    builder: PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt;,
) -&gt; PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt; {
    builder
}</code></pre>
<p>That compiles, at last.
Let's try to register an operation handler now:</p>
<pre><code class="language-rust ignore">fn partial_setup&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt;(
    builder: PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt;,
) -&gt; PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt; {
    builder.get_server_statistics(get_server_statistics)
}</code></pre>
<p>That looks innocent, but it doesn't fly:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; pokemon-service/src/bin/pokemon-service.rs:31:5
   |
28 | fn partial_setup&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt;(
   |                                 --- this type parameter
29 |     builder: PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt;,
30 | ) -&gt; PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt; {
   |      --------------------------------------------------- expected `PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt;` because of return type
31 |     builder.get_server_statistics(get_server_statistics)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `Op4`, found struct `Operation`
   |
   = note: expected struct `PokemonServiceBuilder&lt;_, _, _, Op4, _, _, _&gt;`
              found struct `PokemonServiceBuilder&lt;_, _, _, Operation&lt;IntoService&lt;GetServerStatistics, fn(GetServerStatisticsInput, Extension&lt;Arc&lt;State&gt;&gt;) -&gt; impl Future&lt;Output = GetServerStatisticsOutput&gt; {get_server_statistics}&gt;&gt;, _, _, _&gt;
</code></pre>
<p>By registering a handler we have changed the corresponding <code>OpX</code> generic parameter.
Fixing this error requires some non-trivial type gymnastic - I gave up after trying for ~15 minutes.</p>
<h3 id="cut-them-down-going-from-2n1-to-2-generic-parameters"><a class="header" href="#cut-them-down-going-from-2n1-to-2-generic-parameters">Cut them down: going from 2N+1 to 2 generic parameters</a></h3>
<p>The previous two examples should have convinced you that the 2N+1 generic parameters on <code>PokemonServiceBuilder</code> harm the ergonomics of our API.
Can we get rid of them?</p>
<p>Yes! Let's look at one possible approach:</p>
<pre><code class="language-rust ignore">pub struct PokemonServiceBuilder&lt;Body, Plugin&gt; {
    check_health: Option&lt;Route&lt;Body&gt;&gt;,
    do_nothing: Option&lt;Route&lt;Body&gt;&gt;,
    get_pokemon_species: Option&lt;Route&lt;Body&gt;&gt;,
    get_server_statistics: Option&lt;Route&lt;Body&gt;&gt;,
    capture_pokemon: Option&lt;Route&lt;Body&gt;&gt;,
    get_storage: Option&lt;Route&lt;Body&gt;&gt;,
    plugin: Plugin,
}</code></pre>
<p>We no longer store the raw handlers inside <code>PokemonServiceBuilder</code>.
We eagerly upgrade the operation handlers to a <code>Route</code> instance when they are registered with the builder.</p>
<pre><code class="language-rust ignore">impl&lt;Body, Plugin&gt; PokemonServiceBuilder&lt;Body, Plugin&gt; {
    pub fn get_pokemon_species&lt;Handler, Extensions&gt;(mut self, handler: Handler) -&gt; Self
    /* Complex trait bounds */
    {
        let route = Route::new(Operation::from_handler(handler).upgrade(&amp;self.plugin));
        self.get_pokemon_species = Some(route);
        self
    }

    /* other setters and methods */
}</code></pre>
<p>The existing API performs the upgrade when <code>build</code> is called, forcing <code>PokemonServiceBuilder</code> to store the raw handlers and keep two generic parameters around (<code>OpX</code> and <code>ExtsX</code>) for each operation.
The proposed API requires plugins to be specified upfront, when creating an instance of the builder. They cannot be modified after a <code>PokemonServiceBuilder</code> instance has been built:</p>
<pre><code class="language-rust ignore">impl PokemonService&lt;()&gt; {
    /// Constructs a builder for [`PokemonService`].
    pub fn builder&lt;Body, Plugin&gt;(plugin: Plugin) -&gt; PokemonServiceBuilder&lt;Body, Plugin&gt; {
        PokemonServiceBuilder {
            check_health: None,
            do_nothing: None,
            get_pokemon_species: None,
            get_server_statistics: None,
            capture_pokemon: None,
            get_storage: None,
            plugin,
        }
    }
}</code></pre>
<p>This constraint guarantees that all operation handlers are upgraded to a <code>Route</code> using the same set of plugins.</p>
<p>Having to specify all plugins upfront is unlikely to have a negative impact on developers currently using <code>smithy-rs</code>.
We have seen how cumbersome it is to break the startup logic into different functions using the current service builder API. Developers are most likely specifying all plugins and routes in the same function even if the current API allows them to intersperse route registrations and plugin registrations: they would simply have to re-order their registration statements to adopt the API proposed in this RFC.</p>
<h3 id="alternatives-allow-new-plugins-to-be-registered-after-builder-creation"><a class="header" href="#alternatives-allow-new-plugins-to-be-registered-after-builder-creation">Alternatives: allow new plugins to be registered after builder creation</a></h3>
<p>The new design prohibits the following invocation style:</p>
<pre><code class="language-rust ignore">let plugin = ColorPlugin::new();
PokemonService::builder(plugin)
    // [...]
    .get_pokemon_species(get_pokemon_species)
    // Add PrintPlugin
    .print()
    .get_storage(get_storage)
    .build()</code></pre>
<p>We could choose to remove this limitation and allow handlers to be upgraded using a different set of plugins depending on where they were registered.
In the snippet above, for example, we would have:</p>
<ul>
<li><code>get_pokemon_species</code> is upgraded using just the <code>ColorPlugin</code>;</li>
<li><code>get_storage</code> is upgraded using both the <code>ColorPlugin</code> and the <code>PrintPlugin</code>.</li>
</ul>
<p>There are no technical obstacles preventing us from implementing this API, but I believe it could easily lead to confusion and runtime surprises due to a mismatch between what the developer might expect <code>PrintPlugin</code> to apply to (all handlers) and what it actually applies to (handlers registered after <code>.print()</code>).</p>
<p>We can provide developers with other mechanisms to register plugins for a single operation or a subset of operations without introducing ambiguity.
For attaching additional plugins to a single operation, we could introduce a blanket <code>Pluggable</code> implementation for all operations in <code>aws-smithy-http-server</code>:</p>
<pre><code class="language-rust ignore">impl&lt;P, Op, Pl, S, L&gt; Pluggable&lt;Pl&gt; for Operation&lt;S, L&gt; where Pl: Plugin&lt;P, Op, S, L&gt; {
    type Output = Operation&lt;Pl::Service, Pl::Layer&gt;;

    fn apply(self, new_plugin: Pl) -&gt; Self::Output {
       new_plugin.map(self)
   }
}</code></pre>
<p>which would allow developers to invoke <code>op.apply(MyPlugin)</code> or call extensions methods such as <code>op.print()</code> where <code>op</code> is an <code>Operation</code>.
For attaching additional plugins to a subgroup of operations, instead, we could introduce nested builders:</p>
<pre><code class="language-rust ignore">let initial_plugins = ColorPlugin;
let mut builder = PokemonService::builder(initial_plugins)
    .get_pokemon_species(get_pokemon_species);
let additional_plugins = PrintPlugin;
// PrintPlugin will be applied to all handlers registered on the scoped builder returned by `scope`.
let nested_builder = builder.scoped(additional_plugins)
    .get_storage(get_storage)
    .capture_pokemon(capture_pokemon)
    // Register all the routes on the scoped builder with the parent builder.
    // API names are definitely provisional and bikesheddable.
    .attach(builder);
let app = builder.build();</code></pre>
<p>Both proposals are outside the scope of this RFC, but they are shown here for illustrative purposes.</p>
<h3 id="alternatives-lazy-and-eager-on-demand-type-erasure"><a class="header" href="#alternatives-lazy-and-eager-on-demand-type-erasure">Alternatives: lazy and eager-on-demand type erasure</a></h3>
<p>A lot of our issues stem from type mismatch errors: we are encoding the type of our handlers into the overall type of the service builder and, as a consequence, we end up modifying that type every time we set a handler or modify its state.
Type erasure is a common approach for mitigating these issues - reduce those generic parameters to a common type to avoid the mismatch errors.
This whole RFC can be seen as a type erasure proposal - done eagerly, as soon as the handler is registered, using <code>Option&lt;Route&lt;B&gt;&gt;</code> as our "common type" after erasure.</p>
<p>We could try to strike a different balance - i.e. avoid performing type erasure eagerly, but allow developers to erase types on demand.
Based on my analysis, this could happen in two ways:</p>
<ol>
<li>We cast handlers into a <code>Box&lt;dyn Upgradable&lt;Protocol, Operation, Exts, Body, Plugin&gt;&gt;</code> to which we can later apply plugins (lazy type erasure);</li>
<li>We upgrade registered handlers to <code>Route&lt;B&gt;</code> and apply plugins in the process (eager type erasure on-demand).</li>
</ol>
<p>Let's ignore these implementation issues for the time being to focus on what the ergonomics would look like assuming we can actually perform type erasure.
In practice, we are going to assume that:</p>
<ul>
<li>In approach 1), we can call <code>.boxed()</code> on a registered operation and get a <code>Box&lt;dyn Upgradable&gt;</code> back;</li>
<li>In approach 2), we can call <code>.erase()</code> on the entire service builder and convert all registered operations to <code>Route&lt;B&gt;</code> while keeping the <code>MissingOperation</code> entries as they are. After <code>erase</code> has been called, you can no longer register plugins (or, alternatively, the plugins you register will only apply new handlers).</li>
</ul>
<p>We are going to explore both approaches under the assumption that we want to preserve compile-time verification for missing handlers. If we are willing to abandon compile-time verification, we get better ergonomics since all <code>OpX</code> and <code>ExtsX</code> generic parameters can be erased (i.e. we no longer need to worry about <code>MissingOperation</code>).</p>
<h4 id="on-boxdyn-upgradableprotocol-operation-exts-body-plugin"><a class="header" href="#on-boxdyn-upgradableprotocol-operation-exts-body-plugin">On <code>Box&lt;dyn Upgradable&lt;Protocol, Operation, Exts, Body, Plugin&gt;&gt;</code></a></h4>
<p>This is the current definition of the <code>Upgradable</code> trait:</p>
<pre><code class="language-rust ignore">/// Provides an interface to convert a representation of an operation to a HTTP [`Service`](tower::Service) with
/// canonical associated types.
pub trait Upgradable&lt;Protocol, Operation, Exts, Body, Plugin&gt; {
    type Service: Service&lt;http::Request&lt;Body&gt;, Response = http::Response&lt;BoxBody&gt;&gt;;

    /// Performs an upgrade from a representation of an operation to a HTTP [`Service`](tower::Service).
    fn upgrade(self, plugin: &amp;Plugin) -&gt; Self::Service;
}</code></pre>
<p>In order to perform type erasure, we need to determine:</p>
<ul>
<li>what type parameters we are going to pass as generic arguments to <code>Upgradable</code>;</li>
<li>what type we are going to use for the associated type <code>Service</code>.</li>
</ul>
<p>We have:</p>
<ul>
<li>there is a single known protocol for a service, therefore we can set <code>Protocol</code> to its concrete type (e.g. <code>AwsRestJson1</code>);</li>
<li>each handler refers to a different operation, therefore we cannot erase the <code>Operation</code> and the <code>Exts</code> parameters;</li>
<li>both <code>Body</code> and <code>Plugin</code> appear as generic parameters on the service builder itself, therefore we can set them to the same type;</li>
<li>we can use <code>Route&lt;B&gt;</code> to normalize the <code>Service</code> associated type.</li>
</ul>
<p>The above leaves us with two unconstrained type parameters, <code>Operation</code> and <code>Exts</code>, for each operation. Those unconstrained type parameters leak into the type signature of the service builder itself. We therefore find ourselves having, again, 2N+2 type parameters.</p>
<h4 id="branching"><a class="header" href="#branching">Branching</a></h4>
<p>Going back to the branching example:</p>
<pre><code class="language-rust ignore">let check_database: bool = /* */;
let builder = if check_database {
    builder.check_health(check_health)
} else {
    builder.check_health(check_health_with_database)
};
let app = builder.build();</code></pre>
<p>In approach 1), we could leverage the <code>.boxed()</code> method to convert the actual <code>OpX</code> type into a <code>Box&lt;dyn Upgradable&gt;</code>, thus ensuring that both branches return the same type:</p>
<pre><code class="language-rust ignore">let check_database: bool = /* */;
let builder = if check_database {
    builder.check_health_operation(Operation::from_handler(check_health).boxed())
} else {
    builder.check_health_operation(Operation::from_handler(check_health_with_database).boxed())
};
let app = builder.build();</code></pre>
<p>The same cannot be done when conditionally registering a route, because on the <code>else</code> branch we cannot convert <code>MissingOperation</code> into a <code>Box&lt;dyn Upgradable&gt;</code> since <code>MissingOperation</code> doesn't implement <code>Upgradable</code> - the pillar on which we built all our compile-time safety story.</p>
<pre><code class="language-rust ignore">// This won't compile!
let builder = if check_database {
    builder.check_health_operation(Operation::from_handler(check_health).boxed())
} else {
    builder
};</code></pre>
<p>In approach 2), we can erase the whole builder in both branches when they both register a route:</p>
<pre><code class="language-rust ignore">let check_database: bool = /* */;
let boxed_builder = if check_database {
    builder.check_health(check_health).erase()
} else {
    builder.check_health(check_health_with_database).erase()
};
let app = boxed_builder.build();</code></pre>
<p>but, like in approach 1), we will still get a type mismatch error if one of the two branches leaves the route unset.</p>
<h4 id="refactoring-into-smaller-functions"><a class="header" href="#refactoring-into-smaller-functions">Refactoring into smaller functions</a></h4>
<p>Developers would still have to spell out all generic parameters when writing a function that takes in a builder as a parameter:</p>
<pre><code class="language-rust ignore">fn partial_setup&lt;Op1, Op2, Op3, Op4, Op5, Op6, Body, Plugin&gt;(
    builder: PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6, Body, Plugin&gt;,
) -&gt; PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6, Body, Plugin&gt; {
    builder
}</code></pre>
<p>Writing the signature after having modified the builder becomes easier though.
In approach 1), they can explicitly change the touched operation parameters to the boxed variant:</p>
<pre><code class="language-rust ignore">fn partial_setup&lt;Op1, Op2, Op3, Op4, Op5, Op6, Exts4, Body, Plugin&gt;(
    builder: PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6, Body, Plugin, Exts4=Exts4&gt;,
) -&gt; PokemonServiceBuilder&lt;
        Op1, Op2, Op3, Box&lt;dyn Upgradable&lt;AwsRestJson1, GetServerStatistics, Exts4, Body, Plugin&gt;&gt;,
        Op5, Op6, Body, Plugin, Body, Plugin, Exts4=Exts
    &gt; {
    builder.get_server_statistics(get_server_statistics)
}</code></pre>
<p>It becomes trickier in approach 2), since to retain compile-time safety on the builder we expect <code>erase</code> to map <code>MissingOperation</code> into <code>MissingOperation</code>. Therefore, we can't write something like this:</p>
<pre><code class="language-rust ignore">fn partial_setup&lt;Body, Op1, Op2, Op3, Op4, Op5, Op6&gt;(
    builder: PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt;,
) -&gt; PokemonServiceBuilder&lt;Route&lt;B&gt;, Route&lt;B&gt;, Route&lt;B&gt;, Route&lt;B&gt;, Route&lt;B&gt;, Route&lt;B&gt;&gt; {
    builder.get_server_statistics(get_server_statistics).()
}</code></pre>
<p>The compiler would reject it since it can't guarantee that all other operations can be erased to a <code>Route&lt;B&gt;</code>. This is likely to require something along the lines of:</p>
<pre><code class="language-rust ignore">fn partial_setup&lt;Body, Op1, Op2, Op3, Op4, Op5, Op6&gt;(
    builder: PokemonServiceBuilder&lt;Op1, Op2, Op3, Op4, Op5, Op6&gt;,
) -&gt; PokemonServiceBuilder&lt;&lt;Op1 as TypeErase&gt;::Erased, &lt;Op2 as TypeErase&gt;::Erased, &lt;Op3 as TypeErase&gt;::Erased, &lt;Op4 as TypeErase&gt;::Erased, &lt;Op5 as TypeErase&gt;::Erased, &lt;Op6 as TypeErase&gt;::Erased&gt;
where
    // Omitting a bunch of likely needed additional generic parameters and bounds here
    Op1: TypeErase,
    Op2: TypeErase,
    Op3: TypeErase,
    Op4: TypeErase,
    Op5: TypeErase,
    Op6: TypeErase,
{
    builder.get_server_statistics(get_server_statistics).()
}</code></pre>
<h4 id="summary"><a class="header" href="#summary">Summary</a></h4>
<p>Both approaches force us to have a number of generic parameters that scales linearly with the number of operations on the service, affecting the ergonomics of the resulting API in both the branching and the refactoring scenarios.
We believe that the ergonomics advantages of the proposal advanced by this RFC outweigh the limitation of having to specify your plugins upfront, when creating the builder instance.</p>
<h3 id="builder-extensions-what-now"><a class="header" href="#builder-extensions-what-now">Builder extensions: what now?</a></h3>
<p>The <code>Pluggable</code> trait was an interesting development out of <a href="rfc0020_service_builder.html">RFC 20</a>: it allows you to attach methods to a service builder using an extension trait.</p>
<pre><code class="language-rust ignore">/// An extension to service builders to add the `print()` function.
pub trait PrintExt: aws_smithy_http_server::plugin::Pluggable&lt;PrintPlugin&gt; {
    /// Causes all operations to print the operation name when called.
    ///
    /// This works by applying the [`PrintPlugin`].
    fn print(self) -&gt; Self::Output
        where
            Self: Sized,
    {
        self.apply(PrintPlugin)
    }
}</code></pre>
<p>This pattern needs to be revisited if we want to move forward with this RFC, since new plugins cannot be registered after the builder has been instantiated.
My recommendation would be to implement <code>Pluggable</code> for <code>PluginStack</code>, providing the same pattern ahead of the creation of the builder:</p>
<pre><code class="language-rust ignore">// Currently you'd have to go for `PluginStack::new(IdentityPlugin, IdentityPlugin)`,
// but that can be smoothed out even if this RFC isn't approved.
let plugin_stack = PluginStack::default()
    // Use the extension method
    .print();
let app = PokemonService::builder(plugin_stack)
    .get_pokemon_species(get_pokemon_species)
    .get_storage(get_storage)
    .get_server_statistics(get_server_statistics)
    .capture_pokemon(capture_pokemon)
    .do_nothing(do_nothing)
    .build()?;</code></pre>
<h2 id="playing-around-with-the-design"><a class="header" href="#playing-around-with-the-design">Playing around with the design</a></h2>
<p>The API proposed in this RFC has been manually implemented for the Pokemon service. You can find the code <a href="https://github.com/LukeMathWalker/builder-experiments">here</a>.</p>
<h2 id="changes-checklist"><a class="header" href="#changes-checklist">Changes checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Update <code>codegen-server</code> to generate the proposed service builder API
<ul>
<li><a href="https://github.com/smithy-lang/smithy-rs/pull/1954">https://github.com/smithy-lang/smithy-rs/pull/1954</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Implement <code>Pluggable</code> for <code>PluginStack</code>
<ul>
<li><a href="https://github.com/smithy-lang/smithy-rs/pull/1954">https://github.com/smithy-lang/smithy-rs/pull/1954</a></li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Evaluate the introduction of a <code>PluginBuilder</code> as the primary API to compose multiple plugins (instead of <code>PluginStack::new(IdentityPlugin, IdentityPlugin).apply(...)</code>)
<ul>
<li><a href="https://github.com/smithy-lang/smithy-rs/pull/1971">https://github.com/smithy-lang/smithy-rs/pull/1971</a></li>
</ul>
</li>
</ul>
<div class="footnote-definition" id="further-dev-productivity-improvements"><sup class="footnote-definition-label">1</sup>
<p>The impact of a runtime error on developer productivity can be further minimised by encouraging adoption of integration testing; this can be achieved, among other options, by authoring guides that highlight its benefits and provide implementation guidance.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rfcs/rfc0022_error_context_and_compatibility.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rfcs/rfc0024_request_id.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rfcs/rfc0022_error_context_and_compatibility.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rfcs/rfc0024_request_id.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../static/mermaid.min.js"></script>
        <script src="../static/mermaid-init.js"></script>


    </div>
    </body>
</html>
