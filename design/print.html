<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AWS Rust SDK Design</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Design Overview</a></li><li class="chapter-item expanded "><a href="tenets.html"><strong aria-hidden="true">2.</strong> Tenets</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">3.</strong> Design FAQ</a></li><li class="chapter-item expanded "><a href="transport/overview.html"><strong aria-hidden="true">4.</strong> Transport</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="transport/operation.html"><strong aria-hidden="true">4.1.</strong> Http Operations</a></li><li class="chapter-item expanded "><a href="transport/middleware.html"><strong aria-hidden="true">4.2.</strong> HTTP middleware</a></li></ol></li><li class="chapter-item expanded "><a href="smithy/overview.html"><strong aria-hidden="true">5.</strong> Smithy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="smithy/simple_shapes.html"><strong aria-hidden="true">5.1.</strong> Simple Shapes</a></li><li class="chapter-item expanded "><a href="smithy/recursive_shapes.html"><strong aria-hidden="true">5.2.</strong> Recursive Shapes</a></li><li class="chapter-item expanded "><a href="smithy/aggregate_shapes.html"><strong aria-hidden="true">5.3.</strong> Aggregate Shapes</a></li><li class="chapter-item expanded "><a href="smithy/endpoint.html"><strong aria-hidden="true">5.4.</strong> Endpoint Resolution</a></li></ol></li><li class="chapter-item expanded "><a href="rfcs/overview.html"><strong aria-hidden="true">6.</strong> RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rfcs/rfc0001_shared_config.html"><strong aria-hidden="true">6.1.</strong> RFC-0001: Sharing configuration between multiple clients</a></li><li class="chapter-item expanded "><a href="rfcs/rfc0002_http_versions.html"><strong aria-hidden="true">6.2.</strong> RFC-0002: Supporting multiple HTTP versions for SDKs that use Event Stream</a></li><li class="chapter-item expanded "><a href="rfcs/rfc0003_presigning_api.html"><strong aria-hidden="true">6.3.</strong> RFC-0003: API for Pre-signed URLs</a></li><li class="chapter-item expanded "><a href="rfcs/rfc0004_retry_behavior.html"><strong aria-hidden="true">6.4.</strong> RFC-0004: Retry Behavior</a></li><li class="chapter-item expanded "><a href="rfcs/rfc0005_service_generation.html"><strong aria-hidden="true">6.5.</strong> RFC-0005: Smithy Rust service framework</a></li><li class="chapter-item expanded "><a href="rfcs/rfc0006_service_specific_middleware.html"><strong aria-hidden="true">6.6.</strong> RFC-0006: Service-specific middleware</a></li><li class="chapter-item expanded "><a href="rfcs/rfc0007_split_release_process.html"><strong aria-hidden="true">6.7.</strong> RFC-0007: Split release process</a></li><li class="chapter-item expanded "><a href="rfcs/rfc0008_paginators.html"><strong aria-hidden="true">6.8.</strong> RFC-0008: Paginators</a></li><li class="chapter-item expanded "><a href="rfcs/rfc0009_example_consolidation.html"><strong aria-hidden="true">6.9.</strong> RFC-0009: Example Consolidation</a></li><li class="chapter-item expanded "><a href="rfcs/rfc0010_waiters.html"><strong aria-hidden="true">6.10.</strong> RFC-0010: Waiters</a></li><li class="chapter-item expanded "><a href="rfcs/rfc0011_crates_io_alpha_publishing.html"><strong aria-hidden="true">6.11.</strong> RFC-0011: Publishing Alpha to Crates.io</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">AWS Rust SDK Design</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="design-overview"><a class="header" href="#design-overview">Design Overview</a></h1>
<p>The AWS Rust SDK aims to provide an official, high quality &amp; complete interface to AWS services. We plan to eventually use the CRT to provide signing &amp; credential management. The Rust SDK will provide first-class support for the CRT as well as <a href="https://tokio.rs/">Tokio </a> &amp; <a href="https://hyper.rs">Hyper</a>. The Rust SDK empowers advanced customers to bring their own HTTP/IO implementations.</p>
<p>Our design choices are guided by our <a href="./tenets.html">Tenets</a>.</p>
<h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>The design builds on the learnings, ideas, hard work, and GitHub issues of the 142 Rusoto contributors &amp; thousands of users who built this first and learned the hard way.</p>
<h2 id="external-api-overview"><a class="header" href="#external-api-overview">External API Overview</a></h2>
<p>The Rust SDK is &quot;modular&quot; meaning that each AWS service is its own crate. Each crate provides two layers to access the service:</p>
<ol>
<li>The &quot;fluent&quot; API. For most use cases, a high level API that ties together connection management and serialization will be the quickest path to success.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    let client = dynamodb::Client::from_env();
    let tables = client
        .list_tables()
        .limit(10)
        .send()
        .await.expect(&quot;failed to load tables&quot;);
}
</code></pre></pre>
<ol start="2">
<li>The &quot;low-level&quot; API: It is also possible for customers to assemble the pieces themselves. This offers more control over operation construction &amp; dispatch semantics:</li>
</ol>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    let conf = dynamodb::Config::builder().build();
    let conn = aws_hyper::Client::https();
    let operation = dynamodb::ListTables::builder()
        .limit(10)
        .build(&amp;conf)
        .expect(&quot;invalid operation&quot;);
    let tables = conn.call(operation).await.expect(&quot;failed to list tables&quot;);
}
</code></pre></pre>
<p>The Fluent API is implemented as a thin wrapper around the core API to improve ergonomics.</p>
<h2 id="internals"><a class="header" href="#internals">Internals</a></h2>
<p>The Rust SDK is built on Tower Middleware, Tokio &amp; Hyper. We're continuing to iterate on the internals to enable running the AWS SDK in other executors &amp; HTTP stacks. As an example, you can see a demo of adding <code>reqwest</code> as a custom HTTP stack to gain access to its HTTP Proxy support!</p>
<p>For more details about the SDK internals see <a href="transport/operation.html">Operation Design</a></p>
<h2 id="code-generation"><a class="header" href="#code-generation">Code Generation</a></h2>
<p>The Rust SDK is code generated from Smithy models, using Smithy codegeneration utilities. The Code generation is written in Kotlin. More details can be found in the <a href="./smithy/overview.html">Smithy</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-sdk-design-tenets"><a class="header" href="#rust-sdk-design-tenets">Rust SDK Design Tenets</a></h1>
<blockquote>
<p>Unless you know better ones! These are our tenets today, but we'd love your thoughts. Do you wish we had different priorities? Let us know by opening and issue or starting a discussion.</p>
</blockquote>
<ol>
<li><a href="tenets.html#batteries-included-but-replaceable"><strong>Batteries included, but replaceable.</strong></a> The AWS SDK for Rust should provide a best-in-class experience for many use cases, <strong>but</strong>, customers will use the SDK in unique and unexpected ways. <strong>Meet customers where they are;</strong> strive to be compatible with their tools. Provide mechanisms to allow customers make different choices.</li>
<li><a href="tenets.html#make-common-problems-easy-to-solve"><strong>Make common problems easy to solve.</strong></a> The AWS SDK for Rust should make common problems solvable. Guide customers to patterns that set them up for long-term success.</li>
<li><a href="tenets.html#design-for-the-future"><strong>Design for the Future.</strong></a> The AWS SDK for Rust should evolve with AWS without breaking existing customers. APIs will evolve in unpredictable directions, new protocols will gain adoption, and new services will be created that we never could have imagined. Don’t simplify or unify code today that prevents evolution tomorrow.</li>
</ol>
<h2 id="details-justifications-and-ramifications"><a class="header" href="#details-justifications-and-ramifications">Details, Justifications, and Ramifications</a></h2>
<h3 id="batteries-included-but-replaceable"><a class="header" href="#batteries-included-but-replaceable">Batteries included, but replaceable.</a></h3>
<p>Some customers will use the Rust SDK as their first experience with async Rust, potentially <strong>any</strong> Rust. They may not be familiar with Tokio or the concept of an async executor. We are not afraid to have an opinion about the best solution for most customers.</p>
<p>Other customers will come to the SDK with specific requirements. Perhaps they're integrating the SDK into a much larger project that uses <code>async_std</code>. Maybe they need to set custom headers, modify the user agent, or audit every request. They should be able to use the Rust SDK without forking it to meet their needs.</p>
<h3 id="make-common-problems-easy-to-solve"><a class="header" href="#make-common-problems-easy-to-solve">Make common problems easy to solve</a></h3>
<p>If solving a common problem isn’t obvious from the API, it should be obvious from the documentation. The SDK should guide users towards the best solutions for common tasks, <strong>first</strong> with well named methods, <strong>second</strong> with documentation, and <strong>third</strong> with real -world usage examples. Provide misuse resistant APIs. Async Rust has the potential to introduce subtle bugs; the Rust SDK should help customers avoid them.</p>
<h3 id="design-for-the-future"><a class="header" href="#design-for-the-future">Design for the Future</a></h3>
<p>APIs evolve in unpredictable ways, and it's crucial that the SDK can evolve without breaking existing customers. This means designing the SDK so that fundamental changes to the internals can be made without altering the external interface we surface to customers:</p>
<ul>
<li>Keeping the shared core as small &amp; opaque as possible.</li>
<li>Don’t leak our internal dependencies to customers</li>
<li>With every design choice, consider, &quot;Can I reverse this choice in the future?&quot;</li>
</ul>
<p>This may not result in DRY code, and that’s OK! Code that is auto generated has different goals and tradeoffs than code that has been written by hand.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-faq"><a class="header" href="#design-faq">Design FAQ</a></h1>
<h3 id="what-is-smithy"><a class="header" href="#what-is-smithy">What is Smithy?</a></h3>
<p>Smithy is the interface design language used by AWS services. <code>smithy-rs</code> allows users to generate a Rust client for any Smithy based service (pending protocol support), including those outside of AWS.</p>
<h3 id="why-is-there-one-crate-per-service"><a class="header" href="#why-is-there-one-crate-per-service">Why is there one crate per service?</a></h3>
<ol>
<li>
<p>Compilation time: Although it's possible to use cargo features to conditionally compile individual services, we decided that this added significant complexity to the generated code. In Rust the &quot;unit of compilation&quot; is a Crate, so by using smaller crates we can get better compilation parallelism.</p>
</li>
<li>
<p>Versioning: It is expected that over time we may major-version-bump individual services. New updates will be pushed for <em>some</em> AWS service nearly every day. Maintaining separate crates allows us to only increment versions for the relevant pieces that change.</p>
</li>
</ol>
<p>It is worth noting that this isn't a set-in-stone design decision. A parent crate may be even be created at some point!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transport"><a class="header" href="#transport">Transport</a></h1>
<p>The transport layer of smithy-rs and the Rust SDK. Our goal is support customers to bring their own HTTP stack and runtime.</p>
<h2 id="where-we-are-today"><a class="header" href="#where-we-are-today">Where we are today</a></h2>
<p><code>aws-hyper</code> assembles a middleware stack with <code>tower</code>. It provides a way to use an HTTP client other than Hyper, however, it currently has a hard dependency on Hyper &amp; Tokio. <code>hyper::Body</code> is being used directly as the body implementation for responses.</p>
<h2 id="where-we-want-to-go"><a class="header" href="#where-we-want-to-go">Where we want to go</a></h2>
<ol>
<li>Extend <code>HttpService</code> to add a <code>sleep</code> method. This is required to enable runtimes other than Tokio to define how they should sleep.</li>
<li>Replace <code>hyper::Body</code> in responses with SDK Body. For now, SDKBody will probably privately wrap <code>hyper::Body</code>.</li>
<li>Merge <code>aws-hyper</code> into <code>aws-http</code>. Tokio becomes an optional feature—When the Tokio feature is opted out the &quot;fast path&quot; variants for the connection variants are <code>cfg</code>'d out.</li>
<li>By default, customers get a fully baked HTTP stack, but they can opt out of certain features and BYO implementation of <code>HttpService</code>.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-based-operations"><a class="header" href="#http-based-operations">HTTP-based Operations</a></h1>
<p>The Smithy code generator for Rust (and by extension), the AWS SDK use an <code>Operation</code> abstraction to provide a unified
interface for dispatching requests. <code>Operation</code>s contain:</p>
<ul>
<li>A base HTTP request (with a potentially streaming body)</li>
<li>A typed property bag of configuration options</li>
<li>A fully generic response handler</li>
</ul>
<p>In the typical case, these configuration options include things like a <code>CredentialsProvider</code>, however, they can also be
full middleware layers that will get added by the dispatch stack.</p>
<h2 id="operation-phases"><a class="header" href="#operation-phases">Operation Phases</a></h2>
<p>This section details the flow of a request through the SDK until a response is returned to the user.</p>
<h3 id="input-construction"><a class="header" href="#input-construction">Input Construction</a></h3>
<p>A customer interacts with the SDK builders to construct an input. The <code>build()</code> method on an input returns
an <code>Operation&lt;Output&gt;</code>. This codifies the base HTTP request &amp; all the configuration and middleware layers required to modify and dispatch the request.</p>
<pre><code class="language-rust ignore">pub struct Operation&lt;H, R&gt; {
    request: Request,
    response_handler: H,
    _retry_policy: R,
}

pub struct Request {
    inner: http::Request&lt;SdkBody&gt;,
    properties: PropertyBag,
}
</code></pre>
<p>For most requests, <code>.build()</code> will NOT consume the input. A user can call <code>.build()</code> multiple times to produce multiple operations from the same input.</p>
<p>By using a property bag, we can define the <code>Operation</code> in Smithy core. AWS specific configuration can be added later in the stack.</p>
<h3 id="operation-construction"><a class="header" href="#operation-construction">Operation Construction</a></h3>
<p>In order to construct an operation, the generated code injects appropriate middleware &amp; configuration via the configuration property bag. It does this by reading the configuration properties out of the service
config, copying them as necessary, and loading them into the <code>Request</code>:</p>
<pre><code class="language-rust ignore">// This is approximately the generated code, I've cleaned a few things up for readability.
pub fn build(self, config: &amp;dynamodb::config::Config) -&gt; Operation&lt;BatchExecuteStatement&gt; {
    let op = BatchExecuteStatement::new(BatchExecuteStatementInput {
        statements: self.statements,
    });
    let req = op.build_http_request().map(SdkBody::from);

    let mut req = operation::Request::new(req);
    let mut props = req.properties_mut();
    props.insert_signing_config(config.signing_service());
    props.insert_endpoint_resolver(config.endpoint_resolver.clone());
    Operation::new(req)
}
</code></pre>
<h3 id="operation-dispatch-and-middleware"><a class="header" href="#operation-dispatch-and-middleware">Operation Dispatch and Middleware</a></h3>
<p>The Rust SDK endeavors to behave as predictably as possible. This means that if at all possible we will not dispatch extra HTTP requests during the dispatch of normal operation. Making this work is covered in more detail in the design of credentials providers &amp; endpoint resolution.</p>
<p>The upshot is that we will always prefer a design where the user has explicit control of when credentials are loaded and endpoints are resolved. This doesn't mean that users can't use easy-to-use options (We will provide an automatically refreshing credentials provider), however, the credential provider won't load requests during the dispatch of an individual request.</p>
<h2 id="operation-parsing-and-response-loading"><a class="header" href="#operation-parsing-and-response-loading">Operation Parsing and Response Loading</a></h2>
<p>The fundamental trait for HTTP-based protocols is <code>ParseHttpResponse</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-middleware"><a class="header" href="#http-middleware">HTTP middleware</a></h1>
<p>Signing, endpoint specification, and logging are all handled as middleware. The Rust SDK takes a minimalist approach to middleware:</p>
<p>Middleware is defined as minimally as possible, then adapted into the middleware system used by the IO layer. Tower is the de facto standard for HTTP middleware in Rust—we will probably use it. But we also want to make our middleware usable for users who aren't using Tower (or if we decide to not use Tower in the long run).</p>
<p>Because of this, rather than implementing all our middleware as &quot;Tower Middleware&quot;, we implement it narrowly (e.g. as a function that operates on <code>operation::Request</code>), then define optional adapters to make our middleware tower compatible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smithy"><a class="header" href="#smithy">Smithy</a></h1>
<p>The Rust SDK uses Smithy models and code generation tooling to generate an SDK. Smithy is an open source IDL (interface design language) developed by Amazon. Although the Rust SDK uses Smithy models for AWS services, smithy-rs and Smithy models in general are not AWS specific.</p>
<p>Design documentation here covers both our implementation of Smithy Primitives (e.g. simple shape) as well as more complex Smithy traits like <a href="smithy/./endpoint.html">Endpoint</a>.</p>
<h2 id="internals-1"><a class="header" href="#internals-1">Internals</a></h2>
<p>Smithy introduces a few concepts that are defined here:</p>
<ol>
<li>
<p>Shape: The core Smithy primitive. A smithy model is composed of nested shapes defining an API.</p>
</li>
<li>
<p><code>Symbol</code>: A Representation of a type including namespaces &amp; and any dependencies required to use a type. A shape can be converted into a symbol by a <code>SymbolVisitor</code>. A <code>SymbolVisitor</code> maps shapes to types in your programming language (e.g. Rust). In the Rust SDK, see <a href="https://github.com/awslabs/smithy-rs/blob/c049a37f8cba5f9bec2e96c28db83e7efb2edc53/codegen/src/main/kotlin/software/amazon/smithy/rust/codegen/smithy/SymbolVisitor.kt">SymbolVisitor.kt</a>. Symbol visitors are composable—many specific behaviors are mixed in via small &amp; focused symbol providers, e.g. support for the streaming trait is mixed in separately.</p>
</li>
<li>
<p><code>Writer</code>: Writers are code generation primitives that collect code prior to being written to a file. Writers enable language specific helpers to be added to simplify codegen for a given language. For example, <code>smithy-rs</code> adds <code>rustBlock</code> to <a href="https://github.com/awslabs/smithy-rs/blob/908dec558e26bbae6fe4b7d9d1c221dd81699b59/codegen/src/main/kotlin/software/amazon/smithy/rust/codegen/rustlang/RustWriter.kt"><code>RustWriter</code></a> to create a &quot;Rust block&quot; of code.</p>
<pre><code class="language-kotlin">writer.rustBlock(&quot;struct Model&quot;) {
    model.fields.forEach {
        write(&quot;${field.name}: #T&quot;, field.symbol)
    }
}
</code></pre>
<p>This would produce something like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Model {
   field1: u32,
   field2: String
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>Generators: A Generator, e.g. <code>StructureGenerator</code>, <code>UnionGenerator</code> generates more complex Rust code from a Smithy model. Protocol generators pull these individual tools together to generate code for an entire service / protocol.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-shapes"><a class="header" href="#simple-shapes">Simple Shapes</a></h1>
<table><thead><tr><th>Smithy Type (links to design discussions)</th><th>Rust Type (links to Rust documentation)</th></tr></thead><tbody>
<tr><td>blob</td><td><code>Vec&lt;u8&gt;</code></td></tr>
<tr><td>boolean</td><td><a href="https://doc.rust-lang.org/std/primitive.bool.html"><code>bool</code></a></td></tr>
<tr><td><a href="smithy/simple_shapes.html#strings">string</a></td><td><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a></td></tr>
<tr><td>byte</td><td><code>i8</code></td></tr>
<tr><td>short</td><td><code>i16</code></td></tr>
<tr><td>integer</td><td><code>i32</code></td></tr>
<tr><td>long</td><td><code>i64</code></td></tr>
<tr><td>float</td><td><code>f32</code></td></tr>
<tr><td>double</td><td><code>f64</code></td></tr>
<tr><td><a href="smithy/simple_shapes.html#big-numbers">bigInteger</a></td><td><code>BigInteger</code> (Not implemented yet)</td></tr>
<tr><td><a href="smithy/simple_shapes.html#big-numbers">bigDecimal</a></td><td><code>BigDecimal</code> (Not implemented yet)</td></tr>
<tr><td><a href="smithy/simple_shapes.html#timestamps">timestamp</a></td><td><a href="https://github.com/awslabs/smithy-rs/blob/main/rust-runtime/aws-smithy-types/src/date_time/mod.rs"><code>DateTime</code></a></td></tr>
<tr><td><a href="smithy/simple_shapes.html#documents">document</a></td><td><a href="https://github.com/awslabs/smithy-rs/blob/v0.14/rust-runtime/aws-smithy-types/src/lib.rs#L38-L52"><code>Document</code></a></td></tr>
</tbody></table>
<h3 id="big-numbers"><a class="header" href="#big-numbers">Big Numbers</a></h3>
<p>Rust currently has no standard library or universally accepted large-number crate. Until one is stabilized, a string representation is a reasonable compromise:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BigInteger(String);
pub struct BigDecimal(String);
<span class="boring">}
</span></code></pre></pre>
<p>This will enable us to add helpers over time as requested. Users will also be able to define their own conversions into their preferred large-number libraries.</p>
<p>As of 5/23/2021 BigInteger / BigDecimal are not included in AWS models. Implementation is tracked <a href="https://github.com/awslabs/smithy-rs/issues/312">here</a>.</p>
<h3 id="timestamps"><a class="header" href="#timestamps">Timestamps</a></h3>
<p><a href="https://github.com/chronotope/chrono">chrono</a> is the current de facto library for datetime in Rust, but it is pre-1.0. DateTimes are represented by an SDK defined structure modeled on <code>std::time::Duration</code> from the Rust standard library.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>/// DateTime in time.
///
/// DateTime in time represented as seconds and sub-second nanos since
/// the Unix epoch (January 1, 1970 at midnight UTC/GMT).
///
/// This type can be converted to/from the standard library's [`SystemTime`](std::time::SystemTime):
/// ```rust
/// # fn doc_fn() -&gt; Result&lt;(), aws_smithy_types::date_time::ConversionError&gt; {
/// # use aws_smithy_types::date_time::DateTime;
/// # use std::time::SystemTime;
/// use std::convert::TryFrom;
///
/// let the_millennium_as_system_time = SystemTime::try_from(DateTime::from_secs(946_713_600))?;
/// let now_as_date_time = DateTime::from(SystemTime::now());
/// # Ok(())
/// # }
/// ```
///
/// The [`aws-smithy-types-convert`](https://crates.io/crates/aws-smithy-types-convert) crate
/// can be used for conversions to/from other libraries, such as
/// [`time`](https://crates.io/crates/time) or [`chrono`](https://crates.io/crates/chrono).
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct DateTime {
    seconds: i64,
    subsecond_nanos: u32,
}

<span class="boring">}
</span></code></pre></pre>
<p>Functions in the <code>aws-smithy-types-convert</code> crate provide conversions to other crates, such as <code>time</code> or <code>chrono</code>.</p>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>Rust has two different String representations:</p>
<ul>
<li><code>String</code>, an owned, heap allocated string.</li>
<li><code>&amp;str</code>, a reference to a string, owned elsewhere.</li>
</ul>
<p>In ideal world, input shapes, where there is no reason for the strings to be owned would use <code>&amp;'a str</code>. Outputs would likely use <code>String</code>. However, Smithy does not provide a distinction between input and output shapes.</p>
<p>A third compromise could be storing <code>Arc&lt;String&gt;</code>, an atomic reference counted pointer to a <code>String</code>. This may be ideal for certain advanced users, but is likely to confuse most users and produces worse ergonomics. <em>This is an open design area where we will seek user feedback.</em> Rusoto uses <code>String</code> and there has been <a href="https://github.com/rusoto/rusoto/issues/1806">one feature request</a> to date to change that.</p>
<p>Current models represent strings as <code>String</code>.</p>
<h3 id="document-types"><a class="header" href="#document-types">Document Types</a></h3>
<p>Smithy defines the concept of &quot;Document Types&quot;:</p>
<blockquote>
<p>[Documents represent] protocol-agnostic open content that is accessed like JSON data. Open content is useful for modeling unstructured data that has no schema, data that can't be modeled using rigid types, or data that has a schema that evolves outside of the purview of a model. The serialization format of a document is an implementation detail of a protocol and MUST NOT have any effect on the types exposed by tooling to represent a document value.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>/// Document Type
///
/// Document types represents protocol-agnostic open content that is accessed like JSON data.
/// Open content is useful for modeling unstructured data that has no schema, data that can't be
/// modeled using rigid types, or data that has a schema that evolves outside of the purview of a model.
/// The serialization format of a document is an implementation detail of a protocol.
#[derive(Debug, Clone, PartialEq)]
pub enum Document {
    /// JSON object
    Object(HashMap&lt;String, Document&gt;),
    /// JSON array
    Array(Vec&lt;Document&gt;),
    /// JSON number
    Number(Number),
    /// JSON string
    String(String),
    /// JSON boolean
    Bool(bool),
    /// JSON null
    Null,
}

/// A number type that implements Javascript / JSON semantics, modeled on serde_json:
/// &lt;https://docs.serde.rs/src/serde_json/number.rs.html#20-22&gt;
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Number {
    /// Unsigned 64-bit integer value
    PosInt(u64),
    /// Signed 64-bit integer value
    NegInt(i64),
    /// 64-bit floating-point value
    Float(f64),
}

macro_rules! to_num_fn {
    ($name:ident, $typ:ident) =&gt; {
        /// Converts to a `$typ`. This conversion may be lossy.
        pub fn $name(self) -&gt; $typ {
            match self {
                Number::PosInt(val) =&gt; val as $typ,
                Number::NegInt(val) =&gt; val as $typ,
                Number::Float(val) =&gt; val as $typ,
            }
        }
    };
}

impl Number {
    to_num_fn!(to_f32, f32);
    to_num_fn!(to_f64, f64);

    to_num_fn!(to_i8, i8);
    to_num_fn!(to_i16, i16);
    to_num_fn!(to_i32, i32);
    to_num_fn!(to_i64, i64);

    to_num_fn!(to_u8, u8);
    to_num_fn!(to_u16, u16);
    to_num_fn!(to_u32, u32);
    to_num_fn!(to_u64, u64);
}

<span class="boring">}
</span></code></pre></pre>
<p>Individual protocols define their own document serialization behavior, with some protocols such as AWS and EC2 Query not supporting document types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-shapes"><a class="header" href="#recursive-shapes">Recursive Shapes</a></h1>
<blockquote>
<p>Note: Throughout this document, the word &quot;box&quot; always refers to a Rust <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>, a heap allocated pointer to T, and not the Smithy concept of boxed vs. unboxed.</p>
</blockquote>
<p>Recursive shapes pose a problem for Rust, because the following Rust code will not compile:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TopStructure {
    intermediate: IntermediateStructure
}

struct IntermediateStructure {
    top: Option&lt;TopStructure&gt;
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-rust ignore">  |
3 | struct TopStructure {
  | ^^^^^^^^^^^^^^^^^^^ recursive type has infinite size
4 |     intermediate: IntermediateStructure
  |     ----------------------------------- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to make `main::TopStructure` representable
</code></pre>
<p>This occurs because Rust types must be a size known at compile time. The way around this, as the message suggests, is to Box the offending type. <code>smithy-rs</code> implements this design in <a href="https://github.com/awslabs/smithy-rs/blob/main/codegen/src/main/kotlin/software/amazon/smithy/rust/codegen/smithy/transformers/RecursiveShapeBoxer.kt">RecursiveShapeBoxer.kt</a></p>
<p>To support this, as the message suggests, we must &quot;<code>Box</code>&quot; the offending type. There is a touch of trickiness—only one element in the cycle needs to be boxed, but we need to select it deterministically such that we always pick the same element between multiple codegen runs. To do this the Rust SDK will:</p>
<ol>
<li>Topologically sort the graph of shapes.</li>
<li>Identify cycles that do not pass through an existing Box<T>, List, Set, or Map</li>
<li>For each cycle, select the earliest shape alphabetically &amp; mark it as Box<T> in the Smithy model by attaching the custom <code>RustBoxTrait</code> to the member.</li>
<li>Go back to step 1.</li>
</ol>
<p>This would produce valid Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TopStructure {
    intermediate: IntermediateStructure
}

struct IntermediateStructure {
    top: Box&lt;Option&lt;TopStructure&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Backwards Compatibility Note!</strong></p>
<p>Box<T> is not generally compatible with T in Rust. There are several unlikely but valid model changes that will cause the SDK to produce code that may break customers. If these are problematic, all are avoidable with customizations.</p>
<ol>
<li>
<p>A recursive link is added to an existing structure. This causes a member that was not boxed before to become Box<T>.</p>
<blockquote>
<p><strong>Workaround</strong>: Mark the new member as Box<T> in a customization.</p>
</blockquote>
</li>
<li>
<p>A field is removed from a structure that removes the recursive dependency. The SDK would generate T instead of Box<T>.</p>
<blockquote>
<p><strong>Workaround</strong>: Mark the member that used to be boxed as Box<T> in a customization. The Box will be unnecessary, but we will keep it for backwards compatibility.</p>
</blockquote>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregate-shapes"><a class="header" href="#aggregate-shapes">Aggregate Shapes</a></h1>
<table><thead><tr><th>Smithy Type</th><th>Rust Type</th></tr></thead><tbody>
<tr><td><a href="smithy/aggregate_shapes.html#list">List</a></td><td><code>Vec&lt;Member&gt;</code></td></tr>
<tr><td><a href="smithy/aggregate_shapes.html#set">Set</a></td><td><code>Vec&lt;Member&gt;</code></td></tr>
<tr><td><a href="smithy/aggregate_shapes.html#map">Map</a></td><td><code>HashMap&lt;String, Value&gt;</code></td></tr>
<tr><td><a href="smithy/aggregate_shapes.html#structure">Structure</a></td><td><code>struct</code></td></tr>
<tr><td><a href="smithy/aggregate_shapes.html#union">Union</a></td><td><code>enum</code></td></tr>
</tbody></table>
<p>Most generated types are controlled by <a href="https://github.com/awslabs/smithy-rs/blob/main/codegen/src/main/kotlin/software/amazon/smithy/rust/codegen/smithy/SymbolVisitor.kt">SymbolVisitor</a>.</p>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<p>List objects in Smithy are transformed into vectors in Rust. Based on the output of the <a href="https://awslabs.github.io/smithy/javadoc/1.5.1/software/amazon/smithy/model/knowledge/NullableIndex.html">NullableIndex</a>, the generated list may be <code>Vec&lt;T&gt;</code> or <code>Vec&lt;Option&lt;T&gt;&gt;</code>.</p>
<h2 id="set"><a class="header" href="#set">Set</a></h2>
<p>Because floats are not Hashable in Rust, for simplicity smithy-rs translates all sets to into <code>Vec&lt;T&gt;</code> instead of <code>HashSet&lt;T&gt;</code>. In the future, a breaking change may be made to introduce a library-provided wrapper type for Sets.</p>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<p>Because <code>key</code> MUST be a string in Smithy maps, we avoid the hashibility issue encountered with <code>Set</code>. There are optimizations that could be considered (e.g. since these maps will probably never be modified), however, pending customer feedback, Smithy Maps become <code>HashMap&lt;String, V&gt;</code> in Rust.</p>
<h2 id="structure"><a class="header" href="#structure">Structure</a></h2>
<blockquote>
<p>See <code>StructureGenerator.kt</code> for more details</p>
</blockquote>
<p>Smithy <code>structure</code> becomes a <code>struct</code> in Rust. Backwards compatibility &amp; usability concerns lead to a few design choices:</p>
<ol>
<li>As specified by <code>NullableIndex</code>, fields are <code>Option&lt;T&gt;</code> when Smithy models them as nullable.</li>
<li>All structs are marked <code>#[non_exhaustive]</code></li>
<li>All structs derive <code>Debug</code> &amp; <code>PartialEq</code>. Structs <strong>do not</strong> derive <code>Eq</code> because a <code>float</code> member may be added in the future.</li>
<li>Struct fields are public. Public struct fields allow for <a href="https://doc.rust-lang.org/nomicon/borrow-splitting.html">split borrows</a>. When working with output objects this significantly improves ergonomics, especially with optional fields.
<code>rust,ignore let out = dynamo::ListTablesOutput::new(); out.some_field.unwrap(); // &lt;- partial move, impossible with an accessor </code></li>
<li>Builders are generated for structs that provide ergonomic and backwards compatible constructors. A builder for a struct is always available via the convenience method <code>SomeStruct::builder()</code></li>
<li>Structures manually implement debug: In order to support the <a href="https://awslabs.github.io/smithy/1.0/spec/core/documentation-traits.html#sensitive-trait">sensitive trait</a>, a <code>Debug</code> implementation for structures is manually generated.</li>
</ol>
<h3 id="example-structure-output"><a class="header" href="#example-structure-output">Example Structure Output</a></h3>
<p><strong>Smithy Input</strong>:</p>
<pre><code class="language-java">@documentation(&quot;&lt;p&gt;Contains I/O usage metrics...&quot;)
structure IOUsage {
    @documentation(&quot;... elided&quot;)
    ReadIOs: ReadIOs,
    @documentation(&quot;... elided&quot;)
    WriteIOs: WriteIOs
}

long ReadIOs

long WriteIOs
</code></pre>
<p><strong>Rust Output</strong>:</p>
<pre><code class="language-rust ignore">/// &lt;p&gt;Contains I/O usage metrics for a command that was invoked.&lt;/p&gt;
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IOUsage {
    /// &lt;p&gt;The number of read I/O requests that the command made.&lt;/p&gt;
    pub read_i_os: i64,
    /// &lt;p&gt;The number of write I/O requests that the command made.&lt;/p&gt;
    pub write_i_os: i64,
}
impl std::fmt::Debug for IOUsage {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        let mut formatter = f.debug_struct(&quot;IOUsage&quot;);
        formatter.field(&quot;read_i_os&quot;, &amp;self.read_i_os);
        formatter.field(&quot;write_i_os&quot;, &amp;self.write_i_os);
        formatter.finish()
    }
}
/// See [`IOUsage`](crate::model::IOUsage)
pub mod io_usage {
    /// A builder for [`IOUsage`](crate::model::IOUsage)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        read_i_os: std::option::Option&lt;i64&gt;,
        write_i_os: std::option::Option&lt;i64&gt;,
    }
    impl Builder {
        /// &lt;p&gt;The number of read I/O requests that the command made.&lt;/p&gt;
        pub fn read_i_os(mut self, inp: i64) -&gt; Self {
            self.read_i_os = Some(inp);
            self
        }
        pub fn set_read_i_os(mut self, inp: i64) -&gt; Self {
            self.read_i_os = Some(inp);
            self
        }
        /// &lt;p&gt;The number of write I/O requests that the command made.&lt;/p&gt;
        pub fn write_i_os(mut self, inp: i64) -&gt; Self {
            self.write_i_os = Some(inp);
            self
        }
        pub fn set_write_i_os(mut self, inp: i64) -&gt; Self {
            self.write_i_os = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`IOUsage`](crate::model::IOUsage)
        pub fn build(self) -&gt; crate::model::IOUsage {
            crate::model::IOUsage {
                read_i_os: self.read_i_os.unwrap_or_default(),
                write_i_os: self.write_i_os.unwrap_or_default(),
            }
        }
    }
}
impl IOUsage {
    /// Creates a new builder-style object to manufacture [`IOUsage`](crate::model::IOUsage)
    pub fn builder() -&gt; crate::model::io_usage::Builder {
        crate::model::io_usage::Builder::default()
    }
}
</code></pre>
<h2 id="union"><a class="header" href="#union">Union</a></h2>
<p>Smithy <code>Union</code> is modeled as <code>enum</code> in Rust.</p>
<pre><code>1. Generated `enum`s must be marked `#[non_exhaustive]`.
2. Generated `enum`s must provide an `Unknown` variant. If parsing receives an unknown input that doesn't match any of the given union variants, `Unknown` should be constructed. [Tracking Issue](https://github.com/awslabs/smithy-rs/issues/185).
1. Union members (enum variants) are **not** nullable, because Smithy union members cannot contain null values.
2. When union members contain references to other shapes, we generate a wrapping variant (see below).
3. Union members do not require `#[non_exhaustive]`, because changing the shape targeted by a union member is not backwards compatible.
4. `is_variant` and `as_variant` helper functions are generated to improve ergonomics.
</code></pre>
<h3 id="generated-union-example"><a class="header" href="#generated-union-example">Generated Union Example</a></h3>
<p>The union generated for a simplified <code>dynamodb::AttributeValue</code>
<strong>Smithy</strong>:</p>
<pre><code class="language-java">namespace test

union AttributeValue {
    @documentation(&quot;A string value&quot;)
    string: String,
    bool: Boolean,
    bools: BoolList,
    map: ValueMap
}

map ValueMap {
    key: String,
    value: AttributeValue
}

list BoolList {
    member: Boolean
}
</code></pre>
<p><strong>Rust</strong>:</p>
<pre><code class="language-rust ignore">#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub enum AttributeValue {
    /// a string value
    String(std::string::String),
    Bool(bool),
    Bools(std::vec::Vec&lt;bool&gt;),
    Map(std::collections::HashMap&lt;std::string::String, crate::model::AttributeValue&gt;),
}

impl AttributeValue {
    pub fn as_bool(&amp;self) -&gt; Result&lt;&amp;bool, &amp;crate::model::AttributeValue&gt; {
        if let AttributeValue::Bool(val) = &amp;self { Ok(&amp;val) } else { Err(self) }
    }
    pub fn is_bool(&amp;self) -&gt; bool {
        self.as_bool().is_some()
    }
    pub fn as_bools(&amp;self) -&gt; Result&lt;&amp;std::vec::Vec&lt;bool&gt;, &amp;crate::model::AttributeValue&gt; {
        if let AttributeValue::Bools(val) = &amp;self { Ok(&amp;val) } else { Err(self) }
    }
    pub fn is_bools(&amp;self) -&gt; bool {
        self.as_bools().is_some()
    }
    pub fn as_map(&amp;self) -&gt; Result&lt;&amp;std::collections::HashMap&lt;std::string::String, crate::model::AttributeValue&gt;, &amp;crate::model::AttributeValue&gt; {
        if let AttributeValue::Map(val) = &amp;self { Ok(&amp;val) } else { Err(self) }
    }
    pub fn is_map(&amp;self) -&gt; bool {
        self.as_map().is_some()
    }
    pub fn as_string(&amp;self) -&gt; Result&lt;&amp;std::string::String, &amp;crate::model::AttributeValue&gt; {
        if let AttributeValue::String(val) = &amp;self { Ok(&amp;val) } else { Err(self) }
    }
    pub fn is_string(&amp;self) -&gt; bool {
        self.as_string().is_some()
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="endpoint-resolution"><a class="header" href="#endpoint-resolution">Endpoint Resolution</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>The core codegen generates HTTP requests that do not contain an authority, scheme or post. These properties must be set later based on configuration. Existing AWS services have a number of requirements that increase the complexity:</p>
<ol>
<li>Endpoints must support manual configuration by end users:</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = dynamodb::Config::builder()
    .endpoint(StaticEndpoint::for_uri(&quot;http://localhost:8000&quot;))
<span class="boring">}
</span></code></pre></pre>
<p>When a user specifies a custom endpoint URI, <em>typically</em> they will want to avoid having this URI mutated by other endpoint discovery machinery.</p>
<ol start="2">
<li>
<p>Endpoints must support being customized on a per-operation basis by the endpoint trait. This will prefix the base endpoint, potentially driven by fields of the operation. <a href="https://awslabs.github.io/smithy/1.0/spec/core/endpoint-traits.html#endpoint-trait">Docs</a></p>
</li>
<li>
<p>Endpoints must support being customized by <a href="https://awslabs.github.io/smithy/1.0/spec/aws/aws-core.html#client-endpoint-discovery">endpoint discovery</a>. A request, customized by a predefined set of fields from the input operation is dispatched to a specific URI. That operation returns the endpoint that should be used. Endpoints must be cached by a cache key containing:</p>
</li>
</ol>
<pre><code>(access_key_id, [all input fields], operation)
</code></pre>
<p>Endpoints retrieved in this way specify a TTL.</p>
<ol start="4">
<li>Endpoints must be able to customize the signing (and other phases of the operation). For example, requests sent to a global region will have a region set by the endpoint provider.</li>
</ol>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>Configuration objects for services <em>must</em> contain an <code>Endpoint</code>. This endpoint may be set by a user or it will default to the <code>endpointPrefix</code> from the service definition. In the case of endpoint discovery, <em>this</em> is the endpoint that we will start with.</p>
<p>During operation construction (see <a href="smithy/../transport/operation.html#operation-construction">Operation Construction</a>) an <code>EndpointPrefix</code> may be set on the property bag. The eventual endpoint middleware will search for this in the property bag and (depending on the URI mutability) utilize this prefix when setting the endpoint.</p>
<p>In the case of endpoint discovery, we envision a different pattern:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// EndpointClient manages the endpoint cache
let (tx, rx) = dynamodb::EndpointClient::new();
let client = aws_hyper::Client::new();
// `endpoint_req` is an operation that can be dispatched to retrieve endpoints
// During operation construction, the endpoint resolver is configured to be `rx` instead static endpoint
// resolver provided by the service.
let (endpoint_req, req) = GetRecord::builder().endpoint_disco(rx).build_with_endpoint();
// depending on the duration of endpoint expiration, this may be spawned into a separate task to continuously
// refresh endpoints.
if tx.needs(endpoint_req) {
    let new_endpoint = client.
        call(endpoint_req)
        .await;
    tx.send(new_endpoint)
}
let rsp = client.call(req).await?;
<span class="boring">}
</span></code></pre></pre>
<p>We believe that this design results in an SDK that both offers customers more control &amp; reduces the likelihood of bugs from nested operation dispatch. Endpoint resolution is currently extremely rare in AWS services so this design may remain a prototype while we solidify other behaviors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfcs"><a class="header" href="#rfcs">RFCs</a></h1>
<ul>
<li><a href="rfcs/./rfc0001_shared_config.html">RFC-0001: AWS Configuration</a></li>
<li><a href="rfcs/./rfc0002_http_versions.html">RFC-0002: Supporting multiple HTTP versions for SDKs that use Event Stream</a></li>
<li><a href="rfcs/./rfc0003_presigning_api.html">RFC-0003: API for Presigned URLs</a></li>
<li><a href="rfcs/./rfc0004_retry_behavior.html">RFC-0004: Retry Behavior</a></li>
<li><a href="rfcs/./rfc0005_service_generation.html">RFC-0005: Service Generation</a></li>
<li><a href="rfcs/./rfc0006_service_specific_middleware.html">RFC-0006: Service-specific middleware</a></li>
<li><a href="rfcs/./rfc0007_split_release_process.html">RFC-0007: Split Release Process</a></li>
<li><a href="rfcs/./rfc0008_paginators.html">RFC-0008: Paginators</a></li>
<li><a href="rfcs/./rfc0009_example_consolidation.html">RFC-0009: Example Consolidation</a></li>
<li><a href="rfcs/./rfc0010_waiters.html">RFC-0010: Waiters</a></li>
<li><a href="rfcs/./rfc0011_crates_io_alpha_publishing.html">RFC-0011: Publishing Alpha to Crates.io</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aws-configuration-rfc"><a class="header" href="#aws-configuration-rfc">AWS Configuration RFC</a></h1>
<blockquote>
<p>Status: Implemented. For an ordered list of proposed changes see: <a href="rfcs/rfc0001_shared_config.html#changes-checklist">Proposed changes</a>.</p>
</blockquote>
<p>An AWS SDK loads configuration from multiple locations. Some of these locations can be loaded synchronously. Some are
async. Others may actually use AWS services such as STS or SSO.</p>
<p>This document proposes an overhaul to the configuration design to facilitate three things:</p>
<ol>
<li>Future-proof: It should be easy to add additional sources of region and credentials, sync and async, from many
sources, including code-generated AWS services.</li>
<li>Ergonomic: There should be one obvious way to create an AWS service client. Customers should be able to easily
customize the client to make common changes. It should encourage sharing of things that are expensive to create.</li>
<li>Shareable: A config object should be usable to configure multiple AWS services.</li>
</ol>
<h2 id="usage-guide"><a class="header" href="#usage-guide">Usage Guide</a></h2>
<blockquote>
<p>The following is an imagined usage guide if this RFC where implemented.</p>
</blockquote>
<h3 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h3>
<p>Using the SDK requires two crates:</p>
<ol>
<li><code>aws-sdk-&lt;someservice&gt;</code>: The service you want to use (e.g. <code>dynamodb</code>, <code>s3</code>, <code>sesv2</code>)</li>
<li><code>aws-config</code>: AWS metaconfiguration. This crate contains all the of logic to load configuration for the SDK (regions,
credentials, retry configuration, etc.)</li>
</ol>
<p>Add the following to your Cargo.toml:</p>
<pre><code class="language-toml">[dependencies]
aws-sdk-dynamo = &quot;0.1&quot;
aws-config = &quot;0.5&quot;

tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
</code></pre>
<p>Let's write a small example project to list tables:</p>
<pre><pre class="playground"><code class="language-rust">use aws_sdk_dynamodb as dynamodb;

#[tokio::main]
async fn main() -&gt; Result&lt;(), dynamodb::Error&gt; {
    let config = aws_config::load_from_env().await;
    let dynamodb = dynamodb::Client::new(&amp;config);
    let resp = dynamodb.list_tables().send().await;
    println!(&quot;my tables: {}&quot;, resp.tables.unwrap_or_default());
    Ok(())
}
</code></pre></pre>
<blockquote>
<p>Tip: Every AWS service exports a top level <code>Error</code> type (e.g. <a href="https://awslabs.github.io/aws-sdk-rust/aws_sdk_dynamodb/enum.Error.html">aws_sdk_dynamodb::Error</a>).
Individual operations return specific error types that contain only the <a href="https://awslabs.github.io/aws-sdk-rust/aws_sdk_dynamodb/error/struct.ListTablesError.html">error variants returned by the operation</a>.
Because all the individual errors implement <code>Into&lt;dynamodb::Error&gt;</code>, you can use <code>dynamodb::Error</code> as the return type along with <code>?</code>.</p>
</blockquote>
<p>Next, we'll explore some other ways to configure the SDK. Perhaps you want to override the region loaded from the
environment with your region. In this case, we'll want more control over how we load config,
using <code>aws_config::from_env()</code> directly:</p>
<pre><pre class="playground"><code class="language-rust">use aws_sdk_dynamodb as dynamodb;

#[tokio::main]
async fn main() -&gt; Result&lt;(), dynamodb::Error&gt; {
    let region_provider = RegionProviderChain::default_provider().or_else(&quot;us-west-2&quot;);
    let config = aws_config::from_env().region(region_provider).load().await;
    let dynamodb = dynamodb::Client::new(&amp;config);
    let resp = dynamodb.list_tables().send().await;
    println!(&quot;my tables: {}&quot;, resp.tables.unwrap_or_default());
    Ok(())
}
</code></pre></pre>
<h3 id="sharing-configuration-between-multiple-services"><a class="header" href="#sharing-configuration-between-multiple-services">Sharing configuration between multiple services</a></h3>
<p>The <code>Config</code> produced by <code>aws-config</code> can be used with any AWS service. If we wanted to read our Dynamodb DB tables
aloud with Polly, we could create a Polly client as well. First, we'll need to add Polly to our <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
aws-sdk-dynamo = &quot;0.1&quot;
aws-sdk-polly = &quot;0.1&quot;
aws-config = &quot;0.5&quot;

tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }
</code></pre>
<p>Then, we can use the shared configuration to build both service clients. The region override will apply to both clients:</p>
<pre><pre class="playground"><code class="language-rust">use aws_sdk_dynamodb as dynamodb;
use aws_sdk_polly as polly;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { // error type changed to `Box&lt;dyn Error&gt;` because we now have dynamo and polly errors
    let config = aws_config::env_loader().with_region(Region::new(&quot;us-west-2&quot;)).load().await;

    let dynamodb = dynamodb::Client::new(&amp;config);
    let polly = polly::Client::new(&amp;config);

    let resp = dynamodb.list_tables().send().await;
    let tables = resp.tables.unwrap_or_default();
    let table_sentence = format!(&quot;my dynamo DB tables are: {}&quot;, tables.join(&quot;, &quot;));
    let audio = polly.synthesize_speech()
        .output_format(OutputFormat::Mp3)
        .text(table_sentence)
        .voice_id(VoiceId::Joanna)
        .send()
        .await?;

    // Get MP3 data from the response and save it
    let mut blob = resp
        .audio_stream
        .collect()
        .await
        .expect(&quot;failed to read data&quot;);

    let mut file = tokio::fs::File::create(&quot;tables.mp3&quot;)
        .await
        .expect(&quot;failed to create file&quot;);

    file.write_all_buf(&amp;mut blob)
        .await
        .expect(&quot;failed to write to file&quot;);
    Ok(())
}
</code></pre></pre>
<h3 id="specifying-a-custom-credential-provider"><a class="header" href="#specifying-a-custom-credential-provider">Specifying a custom credential provider</a></h3>
<p>If you have your own source of credentials, you may opt-out of the standard credential provider chain.</p>
<p>To do this, implement the <code>ProvideCredentials</code> trait.</p>
<blockquote>
<p>NOTE: <code>aws_types::Credentials</code> already implements <code>ProvideCredentials</code>. If you want to use the SDK with static credentials, you're already done!</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use aws_types::credentials::{ProvideCredentials, provide_credentials::future, Result};

struct MyCustomProvider;

impl MyCustomProvider {
    pub async fn load_credentials(&amp;self) -&gt; Result {
        todo!() // A regular async function
    }
}

impl ProvideCredentials for MyCustomProvider {
    fn provide_credentials&lt;'a&gt;(&amp;'a self) -&gt; future::ProvideCredentials&lt;'a&gt;
        where
            Self: 'a,
    {
        future::ProvideCredentials::new(self.load_credentials())
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Hint: If your credential provider is not asynchronous, you can use <code>ProvideCredentials::ready</code> instead to save an allocation.</p>
</blockquote>
<p>After writing your custom provider, you'll use it in when constructing the configuration:</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() {
    let config = aws_config::from_env().credentials_provider(MyCustomProvider).load().await;
    let dynamodb = dynamodb::new(&amp;config);
}
</code></pre></pre>
<h2 id="proposed-design"><a class="header" href="#proposed-design">Proposed Design</a></h2>
<p>Achieving this design consists of three major changes:</p>
<ol>
<li>Add a <code>Config</code> struct to <code>aws-types</code>. This contains a config, but with no logic to <em>construct</em> it. This represents
what configuration SDKS need, but <strong>not</strong> how to load the information from the environment.</li>
<li>Create the <code>aws-config</code> crate. <code>aws-config</code> contains the logic to load configuration from the environment. No
generated service clients will depend on <code>aws-config</code>. This is critical to avoid circular dependencies and to
allow <code>aws-config</code> to depend on other AWS services. <code>aws-config</code> contains individual providers as well as a
pre-assembled default provider chain for region and credentials. It will also contain crate features to automatically
bring in HTTPS and async-sleep implementations.</li>
<li>Remove all &quot;business logic&quot; from <code>aws-types</code>. <code>aws-types</code> should be an interface-only crate that is extremely stable.
The ProvideCredentials trait should move into <code>aws-types</code>. The region provider trait which only exists to support
region-chaining will move out of aws-types into aws-config.</li>
</ol>
<p>Services will continue to generate their own <code>Config</code> structs. These will continue to be customizable as they are today,
however, they won't have any default resolvers built in. Each AWS config will implement <code>From&lt;&amp;aws_types::SharedConfig&gt;</code>
. A convenience method to <code>new()</code> a fluent client directly from a shared config will also be generated.</p>
<h3 id="shared-config-implementation"><a class="header" href="#shared-config-implementation">Shared Config Implementation</a></h3>
<p>This RFC proposes adding region and credentials providers support to the shared config. A future RFC will propose
integration with HTTP settings, HTTPs connectors, and async sleep.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Config {
    // private fields
    ...
}

impl Config {
    pub fn region(&amp;self) -&gt; Option&lt;&amp;Region&gt; {
        self.region.as_ref()
    }

    pub fn credentials_provider(&amp;self) -&gt; Option&lt;SharedCredentialsProvider&gt; {
        self.credentials_provider.clone()
    }

    pub fn builder() -&gt; Builder {
        Builder::default()
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>The <code>Builder</code> for <code>Config</code> allows customers to provide individual overrides and handles the insertion of the default
chain for regions and credentials.</p>
<h3 id="sleep--connectors"><a class="header" href="#sleep--connectors">Sleep + Connectors</a></h3>
<p>Sleep and Connector are both runtime dependent features. <code>aws-config</code> will define <code>rt-tokio</code> and <code>rustls</code>
and <code>native-tls</code> optional features. <strong>This centralizes the Tokio/Hyper dependency</strong> eventually removing the need for
each service to maintain their own Tokio/Hyper features.</p>
<p>Although not proposed in this RFC, shared config will eventually gain support for creating an HTTPs client from HTTP
settings.</p>
<h2 id="the-build-method-on-config"><a class="header" href="#the-build-method-on-config">The <code>.build()</code> method on <service>::Config</a></h2>
<p>Currently, the <code>.build()</code> method on service config will fill in defaults. As part of this change, <code>.build()</code> called on
the service config with missing properties will fill in &quot;empty&quot; defaults. If no credentials provider is given,
a <code>NoCredentials</code> provider will be set, and <code>Region</code> will remain as <code>None</code>.</p>
<h2 id="stability-and-versioning"><a class="header" href="#stability-and-versioning">Stability and Versioning</a></h2>
<p>The introduction of <code>Config</code> to aws-types is not without risks. If a customer depends on a version aws-config that
uses <code>Config</code> that is incompatible, they will get confusing compiler errors.</p>
<p>An example of a problematic set of dependent versions:</p>
<pre><code>┌─────────────────┐                 ┌───────────────┐
│ aws-types = 0.1 │                 │aws-types= 0.2 │
└─────────────────┘                 └───────────────┘
           ▲                                 ▲
           │                                 │
           │                                 │
           │                                 │
 ┌─────────┴─────────────┐          ┌────────┴───────┐
 │aws-sdk-dynamodb = 0.5 │          │aws-config = 0.6│
 └───────────┬───────────┘          └───────┬────────┘
             │                              │
             │                              │
             │                              │
             │                              │
             │                              │
             ├─────────────────────┬────────┘
             │ my-lambda-function  │
             └─────────────────────┘
</code></pre>
<p>To mitigate this risk, we will need to make <code>aws-types</code> essentially permanently stable. Changes to <code>aws-types</code> need to
be made with extreme care. This will ensure that two versions of <code>aws-types</code> never end up in a customer's dependency
tree.</p>
<p>We will dramatically reduce the surface area of <code>aws-types</code> to contain only interfaces.</p>
<p>Several breaking changes will be made as part of this, notably, the profile file parsing will be moved out of aws-types.</p>
<p>Finally, to mitigate this risk even further, services will <code>pub use</code> items from <code>aws-types</code> directly which means that
even if a dependency mismatch exists, it is still possible for customers to work around it.</p>
<h2 id="changes-checklist"><a class="header" href="#changes-checklist">Changes Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
ProvideRegion becomes async using a newtype'd future.</li>
<li><input disabled="" type="checkbox" checked=""/>
AsyncProvideCredentials is removed. ProvideCredentials becomes async using a newtype'd future.</li>
<li><input disabled="" type="checkbox" checked=""/>
ProvideCredentials moved into <code>aws-types</code>. <code>Credentials</code> moved into <code>aws-types</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Create <code>aws-config</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
Profile-file parsing moved into <code>aws-config</code>, region chain &amp; region environment loaders moved to <code>aws-config</code>.</li>
<li><input disabled="" type="checkbox"/>
os_shim_internal moved to ??? <code>aws-smithy-types</code>?</li>
<li><input disabled="" type="checkbox" checked=""/>
Add <code>Config</code> to <code>aws-types</code>. Ensure that it's set up to add new members while remaining backwards
compatible.</li>
<li><input disabled="" type="checkbox" checked=""/>
Code generate <code>From&lt;&amp;SharedConfig&gt; for &lt;everyservice&gt;::Config</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Code generate <code>&lt;everservice&gt;::Client::new(&amp;shared_config)</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Remove <code>&lt;everyservice&gt;::from_env</code></li>
</ul>
<h2 id="open-issues"><a class="header" href="#open-issues">Open Issues</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Connector construction needs to be a function of HTTP settings</li>
<li><input disabled="" type="checkbox"/>
An AsyncSleep should be added to <code>aws-types::Config</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-supporting-multiple-http-versions-for-sdks-that-use-event-stream"><a class="header" href="#rfc-supporting-multiple-http-versions-for-sdks-that-use-event-stream">RFC: Supporting multiple HTTP versions for SDKs that use Event Stream</a></h1>
<blockquote>
<p>Status: Accepted</p>
</blockquote>
<p>For a summarized list of proposed changes, see the <a href="rfcs/rfc0002_http_versions.html#changes-checklist">Changes Checklist</a> section.</p>
<p>Most AWS SDK operations use HTTP/1.1, but bi-directional streaming operations that use the Event Stream
message framing format need to use HTTP/2 (h2).</p>
<p>Smithy models can also customize which HTTP versions are used in each individual protocol trait.
For example,
<a href="https://awslabs.github.io/smithy/1.0/spec/aws/aws-restjson1-protocol.html#aws-protocols-restjson1-trait"><code>@restJson1</code> has attributes <code>http</code> and <code>eventStreamHttp</code></a>
to list out the versions that should be used in a priority order.</p>
<p>There are two problems in play that this doc attempts to solve:</p>
<ol>
<li><strong>Connector Creation</strong>: Customers need to be able to create connectors with the HTTP settings they desire,
and these custom connectors must align with what the Smithy model requires.</li>
<li><strong>Connector Selection</strong>: The generated code must be able to select the connector that best matches the requirements
from the Smithy model.</li>
</ol>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p>Today, there are three layers of <code>Client</code> that are easy to confuse, so to make the following easier to follow,
the following terms will be used:</p>
<ul>
<li><strong>Connector</strong>: An implementor of Tower's <code>Service</code> trait that converts a request into a response. This is typically
a thin wrapper around a Hyper client.</li>
<li><strong>Smithy Client</strong>: A <code>aws_smithy_client::Client&lt;C, M, R&gt;</code> struct that is responsible for gluing together
the connector, middleware, and retry policy. This isn't intended to be used directly.</li>
<li><strong>Fluent Client</strong>: A code generated <code>Client&lt;C, M, R&gt;</code> that has methods for each service operation on it.
A fluent builder is generated alongside it to make construction easier.</li>
<li><strong>AWS Client</strong>: A specialized Fluent Client that uses a <code>DynConnector</code>, <code>DefaultMiddleware</code>,
and <code>Standard</code> retry policy.</li>
</ul>
<p>All of these are just called <code>Client</code> in code today. This is something that could be clarified in a separate refactor.</p>
<h2 id="how-clients-work-today"><a class="header" href="#how-clients-work-today">How Clients Work Today</a></h2>
<p>Fluent clients currently keep a handle to a single Smithy client, which is a wrapper
around the underlying connector. When constructing operation builders, this handle is <code>Arc</code> cloned and
given to the new builder instances so that their <code>send()</code> calls can initiate a request.</p>
<p>The generated fluent client code ends up looking like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Handle&lt;C, M, R&gt; {
    client: aws_smithy_client::Client&lt;C, M, R&gt;,
    conf: crate::Config,
}

pub struct Client&lt;C, M, R = Standard&gt; {
    handle: Arc&lt;Handle&lt;C, M, R&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Functions are generated per operation on the fluent client to gain access to the individual operation builders.
For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn assume_role(&amp;self) -&gt; fluent_builders::AssumeRole&lt;C, M, R&gt; {
    fluent_builders::AssumeRole::new(self.handle.clone())
}
<span class="boring">}
</span></code></pre></pre>
<p>The fluent operation builders ultimately implement <code>send()</code>, which chooses the one and only Smithy client out
of the handle to make the request with:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AssumeRole&lt;C, M, R&gt; {
    handle: std::sync::Arc&lt;super::Handle&lt;C, M, R&gt;&gt;,
    inner: crate::input::assume_role_input::Builder,
}

impl&lt;C, M, R&gt; AssumeRole&lt;C, M, R&gt; where ...{
    pub async fn send(self) -&gt; Result&lt;AssumeRoleOutput, SdkError&lt;AssumeRoleError&gt;&gt; where ... {
        // Setup code omitted ...

        // Make the actual request
        self.handle.client.call(op).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Smithy clients are constructed from a connector, as shown:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let connector = Builder::new()
    .https()
    .middleware(...)
    .build();
let client = Client::with_config(connector, Config::builder().build());
<span class="boring">}
</span></code></pre></pre>
<p>The <code>https()</code> method on the Builder constructs the actual Hyper client, and is driven off Cargo features to
select the correct TLS implementation. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;rustls&quot;)]
pub fn https() -&gt; Https {
    let https = hyper_rustls::HttpsConnector::with_native_roots();
    let client = hyper::Client::builder().build::&lt;_, SdkBody&gt;(https);
    // HyperAdapter is a Tower `Service` request -&gt; response connector that just calls the Hyper client
    crate::hyper_impls::HyperAdapter::from(client)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="solving-the-connector-creation-problem"><a class="header" href="#solving-the-connector-creation-problem">Solving the Connector Creation Problem</a></h2>
<p>Customers need to be able to provide HTTP settings, such as timeouts, for all connectors that the clients use.
These should come out of the <code>SharedConfig</code> when it is used. Connector creation also needs to be customizable
so that alternate HTTP implementations can be used, or so that a fake implementation can be used for tests.</p>
<p>To accomplish this, <code>SharedConfig</code> will have a <code>make_connector</code> member. A customer would configure
it as such:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = some_shared_config_loader()
    .with_http_settings(my_http_settings)
    .with_make_connector(|reqs: &amp;MakeConnectorRequirements| {
        Some(MyCustomConnector::new(reqs))
    })
    .await;
<span class="boring">}
</span></code></pre></pre>
<p>The passed in <code>MakeConnectorRequirements</code> will hold the customer-provided <code>HttpSettings</code> as well
as any Smithy-modeled requirements, which will just be <code>HttpVersion</code> for now. The <code>MakeConnectorRequirements</code>
struct will be marked <code>non_exhaustive</code> so that new requirements can be added to it as the SDK evolves.</p>
<p>A default <code>make_connector</code> implementation would be provided that creates a Hyper connector based on the
Cargo feature flags. This might look something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;rustls&quot;)]
pub fn default_connector(reqs: &amp;HttpRequirements) -&gt; HyperAdapter {
    let https = hyper_rustls::HttpsConnector::with_native_roots();
    let mut builder = hyper::Client::builder();
    builder = configure_settings(builder, &amp;reqs.http_settings);
    if let Http2 = &amp;reqs.http_version {
        builder = builder.http2_only(true);
    }
    HyperAdapter::from(builder.build::&lt;_, SdkBody&gt;(https))
}
<span class="boring">}
</span></code></pre></pre>
<p>For any given service, <code>make_connector</code> could be called multiple times to create connectors
for all required HTTP versions and settings.</p>
<p><strong>Note:</strong> the <code>make_connector</code> returns an <code>Option</code> since an HTTP version may not be required, but rather, preferred
according to a Smithy model. For operations that list out <code>[&quot;h2&quot;, &quot;HTTP/1.1&quot;]</code> as the desired versions,
a customer could choose to provide only an HTTP 1 connector, and the operation should still succeed.</p>
<h2 id="solving-the-connector-selection-problem"><a class="header" href="#solving-the-connector-selection-problem">Solving the Connector Selection Problem</a></h2>
<p>Each service operation needs to be able to select a connector that meets its requirements best
from the customer provided connectors. Initially, the only selection criteria will be the HTTP version,
but later when per-operation HTTP settings are implemented, the connector will also need to be keyed off of those
settings. Since connector creation is not a cheap process, connectors will need to be cached after they are
created.</p>
<p>This caching is currently handled by the <code>Handle</code> in the fluent client, which holds on to the
Smithy client. This cache needs to be adjusted to:</p>
<ul>
<li>Support multiple connectors, keyed off of the customer provided <code>HttpSettings</code>, and also off of the Smithy modeled requirements.</li>
<li>Be lazy initialized. Services that have a mix of Event Stream and non-streaming operations shouldn't create
an HTTP/2 client if the customer doesn't intend to use the Event Stream operations that require it.</li>
</ul>
<p>To accomplish this, the <code>Handle</code> will hold a cache that is optimized for many reads and few writes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Hash, Eq, PartialEq)]
struct ConnectorKey {
    http_settings: HttpSettings,
    http_version: HttpVersion,
}

struct Handle&lt;C, M, R&gt; {
    clients: RwLock&lt;HashMap&lt;HttpRequirements&lt;'static&gt;, aws_smithy_client::Client&lt;C, M, R&gt;&gt;&gt;,
    conf: crate::Config,
}

pub struct Client&lt;C, M, R = Standard&gt; {
    handle: Arc&lt;Handle&lt;C, M, R&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>With how the generics are organized, the connector type will have to be the same between HTTP implementations,
but this should be fine since it is generally a thin wrapper around a separate HTTP implementor.
For cases where it is not, the custom connector type can host its own <code>dyn Trait</code> solution.</p>
<p>The <code>HttpRequirements</code> struct will hold <code>HttpSettings</code> as copy-on-write so that it can be used
for cache lookup without having to clone <code>HttpSettings</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HttpRequirements&lt;'a&gt; {
    http_settings: Cow&lt;'a, HttpSettings&gt;,
    http_version: HttpVersion,
}

impl&lt;'a&gt; HttpRequirements&lt;'a&gt; {
    // Needed for converting a borrowed HttpRequirements into an owned cache key for cache population
    pub fn into_owned(self) -&gt; HttpRequirements&lt;'static&gt; {
        Self {
            http_settings: Cow::Owned(self.http_settings.into_owned()),
            http_version: self.http_version,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>With the cache established, each operation needs to be aware of its requirements. The code generator will be
updated to store a prioritized list of <code>HttpVersion</code> in the property bag in an input's <code>make_operation()</code> method.
This prioritized list will come from the Smithy protocol trait's <code>http</code> or <code>eventStreamHttp</code> attribute, depending
on the operation. The fluent client will then pull this list out of the property bag so that it can determine which
connector to use. This indirection is necessary so that an operation still holds all information
needed to make a service call from the Smithy client directly.</p>
<p><strong>Note:</strong> This may be extended in the future to be more than just <code>HttpVersion</code>, for example, when per-operation
HTTP setting overrides are implemented. This doc is not attempting to solve that problem.</p>
<p>In the fluent client, this will look as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C, M, R&gt; AssumeRole&lt;C, M, R&gt; where ... {
    pub async fn send(self) -&gt; Result&lt;AssumeRoleOutput, SdkError&lt;AssumeRoleError&gt;&gt; where ... {
        let input = self.create_input()?;
        let op = input.make_operation(&amp;self.handle.conf)?;

        // Grab the `make_connector` implementation
        let make_connector = self.config.make_connector();

        // Acquire the prioritized HttpVersion list
        let http_versions = op.properties().get::&lt;HttpVersionList&gt;();

        // Make the actual request (using default HttpSettings until modifying those is implemented)
        let client = self.handle
            .get_or_create_client(make_connector, &amp;default_http_settings(), &amp;http_versions)
            .await?;
        client.call(op).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If an operation requires a specific protocol version, and if the <code>make_connection</code> implementation can't
provide that it, then the <code>get_or_create_client()</code> function will return <code>SdkError::ConstructionFailure</code>
indicating the error.</p>
<h2 id="changes-checklist-1"><a class="header" href="#changes-checklist-1">Changes Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Create <code>HttpVersion</code> in <code>aws-smithy-http</code> with <code>Http1_1</code> and <code>Http2</code></li>
<li><input disabled="" type="checkbox"/>
Refactor existing <code>https()</code> connector creation functions to take <code>HttpVersion</code></li>
<li><input disabled="" type="checkbox"/>
Add <code>make_connector</code> to <code>SharedConfig</code>, and wire up the <code>https()</code> functions as a default</li>
<li><input disabled="" type="checkbox"/>
Create <code>HttpRequirements</code> in <code>aws-smithy-http</code></li>
<li><input disabled="" type="checkbox"/>
Implement the connector cache on <code>Handle</code></li>
<li><input disabled="" type="checkbox"/>
Implement function to calculate a minimum required set of HTTP versions from a Smithy model in the code generator</li>
<li><input disabled="" type="checkbox"/>
Update the <code>make_operation</code> code gen to put an <code>HttpVersionList</code> into the operation property bag</li>
<li><input disabled="" type="checkbox"/>
Update the fluent client <code>send()</code> function code gen grab the HTTP version list and acquire the correct connector with it</li>
<li><input disabled="" type="checkbox"/>
Add required defaulting for models that don't set the optional <code>http</code> and <code>eventStreamHttp</code> protocol trait attributes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-api-for-presigned-urls"><a class="header" href="#rfc-api-for-presigned-urls">RFC: API for Presigned URLs</a></h1>
<blockquote>
<p>Status: Implemented</p>
</blockquote>
<p>For a summarized list of proposed changes, see the <a href="rfcs/rfc0003_presigning_api.html#changes-checklist">Changes Checklist</a> section.</p>
<p>Several AWS services allow for presigned requests in URL form, which is described well by
<a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-query-string-auth.html">S3's documentation on authenticating requests using query parameters</a>.</p>
<p>This doc establishes the customer-facing API for creating these presigned URLs and how they will
be implemented in a generic fashion in the SDK codegen.</p>
<h2 id="terminology-1"><a class="header" href="#terminology-1">Terminology</a></h2>
<p>To differentiate between the clients that are present in the generated SDK today, the following
terms will be used throughout this doc:</p>
<ul>
<li><strong>Smithy Client</strong>: A <code>aws_smithy_client::Client&lt;C, M, R&gt;</code> struct that is responsible for gluing together
the connector, middleware, and retry policy. This is not generated and lives in the <code>aws-smithy-client</code> crate.</li>
<li><strong>Fluent Client</strong>: A code-generated <code>Client&lt;C, M, R&gt;</code> that has methods for each service operation on it.
A fluent builder is generated alongside it to make construction easier.</li>
</ul>
<h2 id="presigned-url-config"><a class="header" href="#presigned-url-config">Presigned URL config</a></h2>
<p>Today, presigned URLs take an expiration time that's not part of the service API.
The SDK will make this configurable as a separate struct so that there's no chance of name collisions, and so
that additional fields can be added in the future. Fields added later will require defaulting for
backwards compatibility.</p>
<p>Customers should also be able to set a start time on the presigned URL's expiration so that they can
generate URLs that become active in the future. An optional <code>start_time</code> option will be available and
default to <code>SystemTime::now()</code>.</p>
<p>Construction <code>PresigningConfig</code> can be done with a builder, but a <code>PresigningConfig::expires_in</code>
convenience function will be provided to bypass the builder for the most frequent use-case.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[non_exhaustive]
#[derive(Debug, Clone)]
pub struct PresigningConfig {
    start_time: SystemTime,
    expires_in: Duration,
}

#[non_exhaustive]
#[derive(Debug)]
pub struct Builder {
    start_time: Option&lt;SystemTime&gt;,
    expires_in: Option&lt;Duration&gt;,
}

impl Builder {
    pub fn start_time(self, start_time: SystemTime) -&gt; Self { ... }
    pub fn set_start_time(&amp;mut self, start_time: Option&lt;SystemTime&gt;) { ... }

    pub fn expires_in(self, expires_in: Duration) -&gt; Self { ... }
    pub fn set_expires_in(&amp;mut self, expires_in: Option&lt;Duration&gt;) { ... }

    // Validates `expires_in` is no greater than one week
    pub fn build(self) -&gt; Result&lt;PresigningConfig, Error&gt; { ... }
}

impl PresigningConfig {
    pub fn expires_in(expires_in: Duration) -&gt; PresigningConfig {
        Self::builder().expires(expires).build().unwrap()
    }

    pub fn builder() -&gt; Builder { ... }
}
<span class="boring">}
</span></code></pre></pre>
<p>Construction of <code>PresigningConfig</code> will validate that <code>expires_in</code> is no greater than one week, as this
is the longest supported expiration time for SigV4. This validation will result in a panic.</p>
<p>It's not inconceivable that <code>PresigningConfig</code> will need additional service-specific parameters as customizations,
so it will be code generated with each service rather than living a shared location.</p>
<h2 id="fluent-presigned-url-api"><a class="header" href="#fluent-presigned-url-api">Fluent Presigned URL API</a></h2>
<p>The generated fluent builders for operations that support presigning will have a <code>presigned()</code> method
in addition to <code>send()</code> that will return a presigned URL rather than sending the request. For S3's GetObject,
the usage of this will look as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = aws_config::load_config_from_environment().await;
let client = s3::Client::new(&amp;config);
let presigning_config = PresigningConfig::expires_in(Duration::from_secs(86400));
let presigned: PresignedRequest = client.get_object()
    .bucket(&quot;example-bucket&quot;)
    .key(&quot;example-object&quot;)
    .presigned(presigning_config)
    .await?;
<span class="boring">}
</span></code></pre></pre>
<p>This API requires a client, and for use-cases where no actual service calls need to be made,
customers should be able to create presigned URLs without the overhead of an HTTP client.
Once the <a href="rfcs/./rfc0002_http_versions.html">HTTP Versions RFC</a> is implemented, the underlying HTTP client
won't be created until the first service call, so there will be no HTTP client overhead to
this approach.</p>
<p>In a step away from the general pattern of keeping fluent client capabilities in line with Smithy client capabilities,
creating presigned URLs directly from the Smithy client will not be supported. This is for two reasons:</p>
<ul>
<li>The Smithy client is not code generated, so adding a method to do presigning would apply to all operations,
but not all operations can be presigned.</li>
<li>Presigned URLs are not currently a Smithy concept (<a href="https://github.com/awslabs/smithy/pull/897">although this may change soon</a>).</li>
</ul>
<p>The result of calling <code>presigned()</code> is a <code>PresignedRequest</code>, which is a wrapper with delegating functions
around <code>http::Request&lt;()&gt;</code> so that the request method and additional signing headers are also made available.
This is necessary since there are some presignable POST operations that require the signature to be in the
headers rather than the query.</p>
<p><strong>Note:</strong> Presigning <em>needs</em> to be <code>async</code> because the underlying credentials provider used to sign the
request <em>may</em> need to make service calls to acquire the credentials.</p>
<h2 id="input-presigned-url-api"><a class="header" href="#input-presigned-url-api">Input Presigned URL API</a></h2>
<p>Even though generating a presigned URL through the fluent client doesn't necessitate an HTTP client,
it will be clearer that this is the case by allowing the creation of presigned URLs directly from an input.
This would look as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = aws_config::load_config_from_environment().await;
let presigning_config = PresigningConfig::expires_in(Duration::from_secs(86400));
let presigned: PresignedRequest = GetObjectInput::builder()
    .bucket(&quot;example-bucket&quot;)
    .key(&quot;example-bucket&quot;)
    .presigned(&amp;config, presigning_config)
    .await?;
<span class="boring">}
</span></code></pre></pre>
<p>Creating the URL through the input will exercise the same code path as creating it through the client,
but it will be more apparent that the overhead of a client isn't present.</p>
<h2 id="behind-the-scenes"><a class="header" href="#behind-the-scenes">Behind the scenes</a></h2>
<p>From an SDK's perspective, the following are required to make a presigned URL:</p>
<ul>
<li>Valid request input</li>
<li>Endpoint</li>
<li>Credentials to sign with</li>
<li>Signing implementation</li>
</ul>
<p>The AWS middleware provides everything except the request, and the request is provided as part
of the fluent builder API. The generated code needs to be able to run the middleware to fully populate
a request property bag, but not actually dispatch it.  The <code>expires_in</code> value from the presigning config
needs to be piped all the way through to the signer. Additionally, the SigV4 signing needs to adjusted
to do query param signing, which is slightly different than its header signing.</p>
<p>Today, request dispatch looks as follows:</p>
<ol>
<li>The customer creates a new fluent builder by calling <code>client.operation_name()</code>, fills in inputs, and then calls <code>send()</code>.</li>
<li><code>send()</code>:
<ol>
<li>Builds the final input struct, and then calls its <code>make_operation()</code> method with the stored config to create a Smithy <code>Operation</code>.</li>
<li>Calls the underlying Smithy client with the operation.</li>
</ol>
</li>
<li>The Smithy client constructs a Tower Service with AWS middleware and a dispatcher at the bottom, and then executes it.</li>
<li>The middleware acquire and add required signing parameters (region, credentials, endpoint, etc) to the request property bag.</li>
<li>The SigV4 signing middleware signs the request by adding HTTP headers to it.</li>
<li>The dispatcher makes the actual HTTP request and returns the response all the way back up the Tower.</li>
</ol>
<p>Presigning will take advantage of a lot of these same steps, but will cut out the <code>Operation</code> and
replace the dispatcher with a presigned URL generator:</p>
<ol>
<li>The customer creates a new fluent builder by calling <code>client.operation_name()</code>, fills in inputs, and then calls <code>presigned()</code>.</li>
<li><code>presigned()</code>:
<ol>
<li>Builds the final input struct, calls the <code>make_operation()</code> method with the stored config, and then extracts
the request from the operation (discarding the rest).</li>
<li>Mutates the <code>OperationSigningConfig</code> in the property bag to:
<ul>
<li>Change the <code>signature_type</code> to <code>HttpRequestQueryParams</code> so that the signer runs the correct signing logic.</li>
<li>Set <code>expires_in</code> to the value given by the customer in the presigning config.</li>
</ul>
</li>
<li>Constructs a Tower Service with <code>AwsMiddleware</code> layered in, and a <code>PresignedUrlGeneratorLayer</code> at the bottom.</li>
<li>Calls the Tower Service and returns its result</li>
</ol>
</li>
<li>The <code>AwsMiddleware</code> will sign the request.</li>
<li>The <code>PresignedUrlGeneratorLayer</code> directly returns the request since all of the work is done by the middleware.</li>
</ol>
<p>It should be noted that the <code>presigned()</code> function above is on the generated input struct, so implementing this for
the input API is identical to implementing it for the fluent client.</p>
<p>All the code for the new <code>make_request()</code> is already in the existing <code>make_operation()</code> and will just need to be split out.</p>
<h3 id="modeling-presigning"><a class="header" href="#modeling-presigning">Modeling Presigning</a></h3>
<p>AWS models don't currently have any information about which operations can be presigned.
To work around this, the Rust SDK will create a synthetic trait to model presigning with, and
apply this trait to known presigned operations via customization. The code generator will
look for this synthetic trait when creating the fluent builders and inputs to know if a
<code>presigned()</code> method should be added.</p>
<h3 id="avoiding-name-collision"><a class="header" href="#avoiding-name-collision">Avoiding name collision</a></h3>
<p>If a presignable operation input has a member named <code>presigned</code>, then there will be a name collision with
the function to generate a presigned URL. To mitigate this, <code>RustReservedWords</code> will be updated
to rename the <code>presigned</code> member to <code>presigned_value</code>
<a href="https://github.com/awslabs/smithy-rs/blob/3d61226b5d446f4cc20bf4969f0e56d106cf478b/codegen/src/main/kotlin/software/amazon/smithy/rust/codegen/rustlang/RustReservedWords.kt#L28">similar to how <code>send</code> is renamed</a>.</p>
<h2 id="changes-checklist-2"><a class="header" href="#changes-checklist-2">Changes Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Update <code>aws-sigv4</code> to support query param signing</li>
<li><input disabled="" type="checkbox" checked=""/>
Create <code>PresignedOperationSyntheticTrait</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Customize models for known presigned operations</li>
<li><input disabled="" type="checkbox" checked=""/>
Create <code>PresigningConfig</code> and its builder</li>
<li><input disabled="" type="checkbox" checked=""/>
Implement <code>PresignedUrlGeneratorLayer</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Create new AWS codegen decorator to:
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Add new <code>presigned()</code> method to input code generator</li>
<li><input disabled="" type="checkbox" checked=""/>
Add new <code>presigned()</code> method to fluent client generator</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Update <code>RustReservedWords</code> to reserve <code>presigned()</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Add integration test to S3</li>
<li><input disabled="" type="checkbox" checked=""/>
Add integration test to Polly</li>
<li><input disabled="" type="checkbox" checked=""/>
Add examples for using presigning for:
<ul>
<li><input disabled="" type="checkbox" checked=""/>
S3 GetObject and PutObject</li>
<li><input disabled="" type="checkbox" checked=""/>
Polly SynthesizeSpeech</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-retry-behavior"><a class="header" href="#rfc-retry-behavior">RFC: Retry Behavior</a></h1>
<blockquote>
<p>Status: Implemented</p>
</blockquote>
<p>For a summarized list of proposed changes, see the <a href="rfcs/rfc0004_retry_behavior.html#changes-checklist">Changes Checklist</a> section.</p>
<p>It is not currently possible for users of the SDK to configure a client's maximum number of retry attempts. This RFC establishes a method for users to set the number of retries to attempt when calling a service and would allow users to disable retries entirely. This RFC would introduce breaking changes to the <code>retry</code> module of the <code>aws-smithy-client</code> crate.</p>
<h2 id="terminology-2"><a class="header" href="#terminology-2">Terminology</a></h2>
<ul>
<li><strong>Smithy Client</strong>: A <code>aws_smithy_client::Client&lt;C, M, R&gt;</code> struct that is responsible for gluing together
the connector, middleware, and retry policy. This is not generated and lives in the <code>aws-smithy-client</code> crate.</li>
<li><strong>Fluent Client</strong>: A code-generated <code>Client&lt;C, M, R&gt;</code> that has methods for each service operation on it.
A fluent builder is generated alongside it to make construction easier.</li>
<li><strong>AWS Client</strong>: A specialized Fluent Client that defaults to using a <code>DynConnector</code>, <code>AwsMiddleware</code>,
and <code>Standard</code> retry policy.</li>
<li><strong>Shared Config</strong>: An <code>aws_types::Config</code> struct that is responsible for storing shared configuration data that is used across all services. This is not generated and lives in the <code>aws-types</code> crate.</li>
<li><strong>Service-specific Config</strong>: A code-generated <code>Config</code> that has methods for setting service-specific configuration. Each <code>Config</code> is defined in the <code>config</code> module of its parent service. For example, the S3-specific config struct is <code>use</code>able from <code>aws_sdk_s3::config::Config</code> and re-exported as <code>aws_sdk_s3::Config</code>.</li>
<li><strong>Standard retry behavior</strong>: The standard set of retry rules across AWS SDKs. This mode includes a standard set of errors that are retried, and support for retry quotas. The default maximum number of attempts with this mode is three, unless <code>max_attempts</code> is explicitly configured.</li>
<li><strong>Adaptive retry behavior</strong>: Adaptive retry mode dynamically limits the rate of AWS requests to maximize success rate. This may be at the expense of request latency. Adaptive retry mode is not recommended when predictable latency is important.
<ul>
<li><em>Note: supporting the &quot;adaptive&quot; retry behavior is considered outside the scope of this RFC</em></li>
</ul>
</li>
</ul>
<h2 id="configuring-the-maximum-number-of-retries"><a class="header" href="#configuring-the-maximum-number-of-retries">Configuring the maximum number of retries</a></h2>
<p>This RFC will demonstrate <em>(with examples)</em> the following ways that Users can set the maximum number of retry attempts:</p>
<ul>
<li>By calling the <code>Config::retry_config(..)</code> or <code>Config::disable_retries()</code> methods when building a service-specific config</li>
<li>By calling the <code>Config::retry_config(..)</code> or <code>Config::disable_retries()</code> methods when building a shared config</li>
<li>By setting the <code>AWS_MAX_ATTEMPTS</code> environment variable</li>
</ul>
<p>The above list is in order of decreasing precedence e.g. setting maximum retry attempts with the <code>max_attempts</code> builder method will override a value set by <code>AWS_MAX_ATTEMPTS</code>.</p>
<p><em>The default number of retries is 3 as specified in the <a href="https://docs.aws.amazon.com/sdkref/latest/guide/setting-global-max_attempts.html">AWS SDKs and Tools Reference Guide</a>.</em></p>
<h3 id="setting-an-environment-variable"><a class="header" href="#setting-an-environment-variable">Setting an environment variable</a></h3>
<p>Here's an example app that logs your AWS user's identity</p>
<pre><pre class="playground"><code class="language-rust">use aws_sdk_sts as sts;

#[tokio::main]
async fn main() -&gt; Result&lt;(), sts::Error&gt; {
    let config = aws_config::load_from_env().await;

    let sts = sts::Client::new(&amp;config);
    let resp = sts.get_caller_identity().send().await?;
    println!(&quot;your user id: {}&quot;, resp.user_id.unwrap_or_default());
    Ok(())
}
</code></pre></pre>
<p>Then, in your terminal:</p>
<pre><code class="language-sh"># Set the env var before running the example program
export AWS_MAX_ATTEMPTS=5
# Run the example program
cargo run
</code></pre>
<h3 id="calling-a-method-on-an-aws-shared-config"><a class="header" href="#calling-a-method-on-an-aws-shared-config">Calling a method on an AWS shared config</a></h3>
<p>Here's an example app that creates a shared config with custom retry behavior and then logs your AWS user's identity</p>
<pre><pre class="playground"><code class="language-rust">use aws_sdk_sts as sts;
use aws_types::retry_config::StandardRetryConfig;

#[tokio::main]
async fn main() -&gt; Result&lt;(), sts::Error&gt; {
    let retry_config = StandardRetryConfig::builder().max_attempts(5).build();
    let config = aws_config::from_env().retry_config(retry_config).load().await;

    let sts = sts::Client::new(&amp;config);
    let resp = sts.get_caller_identity().send().await?;
    println!(&quot;your user id: {}&quot;, resp.user_id.unwrap_or_default());
    Ok(())
}
</code></pre></pre>
<h3 id="calling-a-method-on-service-specific-config"><a class="header" href="#calling-a-method-on-service-specific-config">Calling a method on service-specific config</a></h3>
<p>Here's an example app that creates a service-specific config with custom retry behavior and then logs your AWS user's identity</p>
<pre><pre class="playground"><code class="language-rust">use aws_sdk_sts as sts;
use aws_types::retry_config::StandardRetryConfig;

#[tokio::main]
async fn main() -&gt; Result&lt;(), sts::Error&gt; {
    let config = aws_config::load_from_env().await;
    let retry_config = StandardRetryConfig::builder().max_attempts(5).build();
    let sts_config = sts::config::Config::from(&amp;config).retry_config(retry_config).build();

    let sts = sts::Client::new(&amp;sts_config);
    let resp = sts.get_caller_identity().send().await?;
    println!(&quot;your user id: {}&quot;, resp.user_id.unwrap_or_default());
    Ok(())
}
</code></pre></pre>
<h3 id="disabling-retries"><a class="header" href="#disabling-retries">Disabling retries</a></h3>
<p>Here's an example app that creates a shared config that disables retries and then logs your AWS user's identity</p>
<pre><pre class="playground"><code class="language-rust">use aws_sdk_sts as sts;
use aws_types::config::Config;

#[tokio::main]
async fn main() -&gt; Result&lt;(), sts::Error&gt; {
    let config = aws_config::from_env().disable_retries().load().await;
    let sts_config = sts::config::Config::from(&amp;config).build();

    let sts = sts::Client::new(&amp;sts_config);
    let resp = sts.get_caller_identity().send().await?;
    println!(&quot;your user id: {}&quot;, resp.user_id.unwrap_or_default());
    Ok(())
}
</code></pre></pre>
<p>Retries can also be disabled by explicitly passing the <code>RetryConfig::NoRetries</code> enum variant to the <code>retry_config</code> builder method:</p>
<pre><pre class="playground"><code class="language-rust">use aws_sdk_sts as sts;
use aws_types::retry_config::RetryConfig;

#[tokio::main]
async fn main() -&gt; Result&lt;(), sts::Error&gt; {
    let config = aws_config::load_from_env().await;
    let sts_config = sts::config::Config::from(&amp;config).retry_config(RetryConfig::NoRetries).build();

    let sts = sts::Client::new(&amp;sts_config);
    let resp = sts.get_caller_identity().send().await?;
    println!(&quot;your user id: {}&quot;, resp.user_id.unwrap_or_default());
    Ok(())
}
</code></pre></pre>
<h2 id="behind-the-scenes-1"><a class="header" href="#behind-the-scenes-1">Behind the scenes</a></h2>
<p>Currently, when users want to send a request, the following occurs:</p>
<ol>
<li>The user creates either a shared config or a service-specific config</li>
<li>The user creates a fluent client for the service they want to interact with and passes the config they created. Internally, this creates an AWS client with a default retry policy</li>
<li>The user calls an operation builder method on the client which constructs a request</li>
<li>The user sends the request by awaiting the <code>send()</code> method</li>
<li>The smithy client creates a new <code>Service</code> and attaches a copy of its retry policy</li>
<li>The <code>Service</code> is <code>call</code>ed, sending out the request and retrying it according to the retry policy</li>
</ol>
<p>After this change, the process will work like this:</p>
<ol>
<li>The user creates either a shared config or a service-specific config
<ul>
<li>If <code>AWS_MAX_ATTEMPTS</code> is set to zero, this is invalid and we will log it with <code>tracing::warn</code>. However, this will not error until a request is made</li>
<li>If <code>AWS_MAX_ATTEMPTS</code> is 1, retries will be disabled</li>
<li>If <code>AWS_MAX_ATTEMPTS</code> is greater than 1, retries will be attempted at most as many times as is specified</li>
<li>If the user creates the config with the <code>.disable_retries</code> builder method, retries will be disabled</li>
<li>If the user creates the config with the <code>retry_config</code> builder method, retry behavior will be set according to the <code>RetryConfig</code> they passed</li>
</ul>
</li>
<li>The user creates a fluent client for the service they want to interact with and passes the config they created
<ul>
<li>Provider precedence will determine what retry behavior is actually set, working like how <code>Region</code> is set</li>
</ul>
</li>
<li>The user calls an operation builder method on the client which constructs a request</li>
<li>The user sends the request by awaiting the <code>send()</code> method</li>
<li>The smithy client creates a new <code>Service</code> and attaches a copy of its retry policy</li>
<li>The <code>Service</code> is <code>call</code>ed, sending out the request and retrying it according to the retry policy</li>
</ol>
<p>These changes will be made in such a way that they enable us to add the &quot;adaptive&quot; retry behavior at a later date without introducing a breaking change.</p>
<h2 id="changes-checklist-3"><a class="header" href="#changes-checklist-3">Changes checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Create new Kotlin decorator <code>RetryConfigDecorator</code>
<ul>
<li>Based on <a href="https://github.com/awslabs/smithy-rs/blob/main/aws/sdk-codegen/src/main/kotlin/software/amazon/smithy/rustsdk/RegionDecorator.kt">RegionDecorator.kt</a></li>
<li>This decorator will live in the <code>codegen</code> project because it has relevance outside the SDK</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<strong>Breaking changes:</strong>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Rename <code>aws_smithy_client::retry::Config</code> to <code>StandardRetryConfig</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Rename <code>aws_smithy_client::retry::Config::with_max_retries</code> method to <code>with_max_attempts</code> in order to follow AWS convention</li>
<li><input disabled="" type="checkbox" checked=""/>
Passing 0 to <code>with_max_attempts</code> will panic with a helpful, descriptive error message</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Create non-exhaustive <code>aws_types::retry_config::RetryConfig</code> enum wrapping structs that represent specific retry behaviors
<ul>
<li><input disabled="" type="checkbox" checked=""/>
A <code>NoRetry</code> variant that disables retries. Doesn't wrap a struct since it doesn't need to contain any data</li>
<li><input disabled="" type="checkbox" checked=""/>
A <code>Standard</code> variant that enables the standard retry behavior. Wraps a <code>StandardRetryConfig</code> struct.</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Create <code>aws_config::meta::retry_config::RetryConfigProviderChain</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Create <code>aws_config::meta::retry_config::ProvideRetryConfig</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Create <code>EnvironmentVariableMaxAttemptsProvider</code> struct
<ul>
<li>Setting AWS_MAX_ATTEMPTS=0 and trying to load from env will panic with a helpful, descriptive error message</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Add <code>retry_config</code> method to <code>aws_config::ConfigLoader</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Update <code>AwsFluentClientDecorator</code> to correctly configure the max retry attempts of its inner <code>aws_hyper::Client</code> based on the passed-in <code>Config</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Add tests
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Test that setting retry_config to 1 disables retries</li>
<li><input disabled="" type="checkbox" checked=""/>
Test that setting retry_config to <code>n</code> limits retries to <code>n</code> where <code>n</code> is a non-zero integer</li>
<li><input disabled="" type="checkbox" checked=""/>
Test that correct precedence is respected when overriding retry behavior in a service-specific config</li>
<li><input disabled="" type="checkbox" checked=""/>
Test that correct precedence is respected when overriding retry behavior in a shared config</li>
<li><input disabled="" type="checkbox" checked=""/>
Test that creating a config from env if AWS_MAX_ATTEMPTS=0 will panic with a helpful, descriptive error message</li>
<li><input disabled="" type="checkbox" checked=""/>
Test that setting invalid <code>max_attempts=0</code> with a <code>StandardRetryConfig</code> will panic with a helpful, descriptive error message</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-smithy-rust-service-framework"><a class="header" href="#rfc-smithy-rust-service-framework">RFC: Smithy Rust Service Framework</a></h1>
<blockquote>
<p>Status: RFC</p>
</blockquote>
<p>The Rust Smithy Framework is a full-fledged service framework whose main
responsibility is to handle request lifecycles from beginning to end. It takes
care of input de-serialization, operation execution, output serialization,
error handling, and provides facilities to fulfill the requirements below.</p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<h3 id="smithy-model-driven-code-generation"><a class="header" href="#smithy-model-driven-code-generation">Smithy model-driven code generation</a></h3>
<p>Server side code is generated from Smithy models and implements operations,
input and output structures, and errors defined in the service model.</p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>This new framework is built with performance in mind. It refrains from
allocating memory when not needed and tries to use a majority of
<a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">borrowed</a> types,
handling their memory lifetimes so that a request body can be stored in memory
only once and not
<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html">cloned</a> if possible.</p>
<p>The code is implemented on solid and widely used foundations. It uses
<a href="https://hyper.rs/">Hyper</a> to handle the HTTP requests, the
<a href="https://tokio.rs/">Tokio</a> ecosystem for asynchronous (non-blocking) operations
and <a href="https://docs.rs/tower/">Tower</a> to implement middleware such as timeouts,
rate limiting, retries, and more. CPU intensive operations are scheduled on a
separated thread-pool to avoid blocking the event loop.</p>
<p>It uses Tokio <a href="https://tokio.rs/blog/2021-07-announcing-axum">axum</a>, an HTTP
framework built on top of the technologies mentioned above which handles
routing, request extraction, response building, and workers lifecycle. Axum is
a relatively thin layer on top of Hyper and adds very little overhead, so its
<a href="https://github.com/programatik29/rust-web-benchmarks/blob/master/results/hello-world.md">performance is comparable</a>
to Hyper.</p>
<p>The framework should allow customers to use the built-in HTTP server or
select other transport implementations that can be more performant or better
suited than HTTP for their use case.</p>
<h3 id="extensibility"><a class="header" href="#extensibility">Extensibility</a></h3>
<p>We want to deliver an extensible framework that can plugin components possibly
during code generation and at runtime for specific scenarios that cannot be
covered during generation. These components are developed using a standard
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">interface</a> provided by the
framework itself.</p>
<h3 id="observability"><a class="header" href="#observability">Observability</a></h3>
<p>Being able to report and trace the status of the service is vital for the
success of any product. The framework is integrated with tracing and allows
non-blocking I/O through the asynchronous
<a href="https://tracing.rs/tracing_appender/index.html#non-blocking-writer">tracing appender</a>.</p>
<p>Metrics and logging are built with extensibility in mind, allowing customers to
plug their own handlers following a well defined interface provided by the
framework.</p>
<h3 id="client-generation"><a class="header" href="#client-generation">Client generation</a></h3>
<p>Client generation is deferred to the various Smithy implementations.</p>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<p>Benchmarking the framework is key and customers can't use anything that
compromises the fundamental business objectives of latency and performance.</p>
<h3 id="model-validation"><a class="header" href="#model-validation">Model validation</a></h3>
<p>The generated service code is responsible for validating the model constraints of input structures.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-service-specific-middleware"><a class="header" href="#rfc-service-specific-middleware">RFC: Service-specific middleware</a></h1>
<blockquote>
<p>Status: <a href="https://github.com/awslabs/smithy-rs/pull/959">Implemented</a></p>
</blockquote>
<p>For a summarized list of proposed changes, see the <a href="rfcs/rfc0006_service_specific_middleware.html#changes-checklist">Changes Checklist</a> section.</p>
<p>Currently, all services use a centralized <code>AwsMiddleware</code> that is defined in the (poorly named) <code>aws-hyper</code> crate. This
poses a number of long term risks and limitations:</p>
<ol>
<li>When creating a Smithy Client directly for a given service, customers are forced to implicitly assume that the
service uses stock <code>AwsMiddleware</code>. This prevents us from <em>ever</em> changing the middleware stack for a service in the
future.</li>
<li>It is impossible / impractical in the current situation to alter the middleware stack for a given service. For
services like S3, we will almost certainly want to customize endpoint middleware in a way that is currently
impossible.</li>
</ol>
<p>In light of these limitations, this RFC proposes moving middleware into each generated service. <code>aws-inlineable</code> will be
used to host and test the middleware stack. Each service will then define a public <code>middleware</code> module containing their
middleware stack.</p>
<h2 id="terminology-3"><a class="header" href="#terminology-3">Terminology</a></h2>
<ul>
<li><strong>Middleware</strong>: A tower layer that augments <code>operation::Request -&gt; operation::Response</code> for things like signing and
endpoint resolution.</li>
<li><strong>Aws Middleware</strong>: A specific middleware stack that meets the requirements for AWS services.</li>
<li><strong>Smithy Client</strong>: A <code>aws_smithy_client::Client&lt;C, M, R&gt;</code> struct that is responsible for gluing together the
connector, middleware, and retry policy. This is not generated and lives in the <code>aws-smithy-client</code> crate.</li>
<li><strong>Fluent Client</strong>: A code-generated <code>Client&lt;C, M, R&gt;</code> that has methods for each service operation on it. A fluent
builder is generated alongside it to make construction easier.</li>
<li><strong>AWS Client</strong>: A specialized Fluent Client that defaults to using a <code>DynConnector</code>, <code>AwsMiddleware</code>, and <code>Standard</code>
retry policy.</li>
<li><strong>Shared Config</strong>: An <code>aws_types::Config</code> struct that is responsible for storing shared configuration data that is
used across all services. This is not generated and lives in the <code>aws-types</code> crate.</li>
<li><strong>Service-specific Config</strong>: A code-generated <code>Config</code> that has methods for setting service-specific configuration.
Each <code>Config</code> is defined in the <code>config</code> module of its parent service. For example, the S3-specific config struct
is <code>use</code>able from <code>aws_sdk_s3::config::Config</code> and re-exported as <code>aws_sdk_s3::Config</code>.</li>
</ul>
<h1 id="detailed-design"><a class="header" href="#detailed-design">Detailed Design</a></h1>
<p>Currently, <code>AwsMiddleware</code> is defined in <code>aws-hyper</code>. As part of this change, an <code>aws-inlineable</code> dependency will be
added containing code that is largely identical. This will be exposed in a public <code>middleware</code> module in all generated
services. At some future point, we could even expose a baseline set of default middleware for whitelabel Smithy services
to make them easier to use out-of-the-box.</p>
<p>The <code>ClientGenerics</code> parameter of the <code>AwsFluentClientGenerator</code> will be updated to become a <code>RuntimeType</code>, enabling
loading the type directly. This has the advantage of making it fairly easy to do per-service middleware stacks since we
can easily configure <code>AwsFluentClientGenerator</code> to insert different types based on the service id.</p>
<h1 id="changes-checklist-4"><a class="header" href="#changes-checklist-4">Changes Checklist</a></h1>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Move aws-hyper into aws-inlineable. Update comments as needed including with a usage example about how customers can augment it.</li>
<li><input disabled="" type="checkbox" checked=""/>
Refactor <code>ClientGenerics</code> to contain a RuntimeType instead of a string and configure. Update <code>AwsFluentClientDecorator</code>.</li>
<li><input disabled="" type="checkbox" checked=""/>
Update all code and examples that use <code>aws-hyper</code> to use service-specific middleware.</li>
<li><input disabled="" type="checkbox" checked=""/>
Push an updated README to aws-hyper deprecating the package, explaining what happened. Do <em>not</em> yank previous versions since those will be relied on by older SDK versions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-split-release-process"><a class="header" href="#rfc-split-release-process">RFC: Split Release Process</a></h1>
<blockquote>
<p>Status: Implemented in <a href="https://github.com/awslabs/smithy-rs/pull/986">smithy-rs#986</a> and <a href="https://github.com/awslabs/aws-sdk-rust/pull/351">aws-sdk-rust#351</a></p>
</blockquote>
<p>At the time of writing, the <code>aws-sdk-rust</code> repository is used exclusively
for the entire release process of both the Rust runtime crates from <code>smithy-rs</code> as
well as the AWS runtime crates and the AWS SDK. This worked well when <code>smithy-rs</code> was
only used for the AWS SDK, but now that it's also used for server codegen, there
are issues around publishing the server-specific runtime crates since they don't
belong to the SDK.</p>
<p>This RFC proposes a new split-release process so that the entire <code>smithy-rs</code> runtime
can be published separately before the AWS SDK is published.</p>
<h2 id="terminology-4"><a class="header" href="#terminology-4">Terminology</a></h2>
<ul>
<li><strong>Smithy Runtime Crate</strong>: A crate that gets published to crates.io and supports
the code generated by <code>smithy-rs</code>. These crates don't provide any SDK-only functionality.
These crates can support client and/or server code, and clients or servers may use
only a subset of them.</li>
<li><strong>AWS Runtime Crate</strong>: A crate of SDK-specific code that supports the code generated
by the <code>aws/codegen</code> module in <code>smithy-rs</code>. These also get published to crates.io.</li>
<li><strong>Publish-ready Bundle</strong>: A build artifact that is ready to publish to crates.io without
additional steps (such as running the publisher tool's <code>fix-manifests</code> subcommand). Publishing
one group of crates before another is not considered an additional step for this definition.</li>
<li><strong>Releaser</strong>: A developer, automated process, or combination of the two that performs the actual release.</li>
</ul>
<h2 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h2>
<p>At a high level, the requirements are: publish from both <code>smithy-rs</code> and <code>aws-sdk-rust</code>
while preserving our current level of confidence in the quality of the release. This
can be enumerated as:</p>
<ol>
<li>All Smithy runtime crates must be published together from <code>smithy-rs</code></li>
<li>AWS runtime crates and the SDK must be published together from <code>aws-sdk-rust</code></li>
<li>CI on <code>smithy-rs</code> must give confidence that the Smithy runtime crates,
AWS runtime crates, and SDK are all at the right quality bar for publish.</li>
<li>CI on the <code>aws-sdk-rust</code> repository must give confidence that the AWS SDK and its
runtime crates are at the right quality bar for publish. To do this successfully,
it must run against the exact versions of the Smithy runtime crates the code was
generated against <em>both before AND after they have been published to crates.io</em>.</li>
</ol>
<h2 id="background-how-publishing-worked-before"><a class="header" href="#background-how-publishing-worked-before">Background: How Publishing Worked Before</a></h2>
<p>The publish process to crates.io relied on copying all the Smithy runtime crates
into the final <code>aws-sdk-rust</code> repository. Overall, the process looked as follows:</p>
<ol>
<li><code>smithy-rs</code> generates a complete <code>aws-sdk-rust</code> source bundle at CI time</li>
<li>The releaser copies the generated bundle over to <code>aws-sdk-rust</code></li>
<li>The releaser runs the <code>publisher fix-manifests</code> subcommand to correct the
<code>Cargo.toml</code> files generated by <code>smithy-rs</code></li>
<li>The <code>aws-sdk-rust</code> CI performs one last pass on the code to verify it's sound</li>
<li>The releaser runs the <code>publisher publish</code> subcommand to push all the crates up to crates.io</li>
</ol>
<h2 id="proposed-solution"><a class="header" href="#proposed-solution">Proposed Solution</a></h2>
<p>CI in <code>smithy-rs</code> will be revised to generate two separate build artifacts where it generates
just an SDK artifact previously. Now, it will have two build targets that get executed from CI
to generate these artifacts:</p>
<ul>
<li><code>rust-runtime:assemble</code> - Generates a publish-ready bundle of Smithy runtime crates.</li>
<li><code>aws:sdk:assemble</code> - Generates a publish-ready bundle of AWS runtime crates, SDK crates,
and just the Smithy runtime crates that are used by the SDK.</li>
</ul>
<p>The <code>aws-sdk-rust</code> repository will have a new <code>next</code> branch that has its own set of CI workflows
and branch protection rules. The releaser will take the <code>aws:sdk:assemble</code> artifact and apply it
directly to this <code>next</code> branch as would have previously been done against the <code>main</code> branch.
The <code>main</code> branch will continue to have the same CI as <code>next</code>.</p>
<p>When it's time to cut a release, the releaser will do the following:</p>
<ol>
<li>Tag <code>smithy-rs</code> with the desired version number</li>
<li>Wait for CI to build artifacts for the tagged release</li>
<li>Pull-request the SDK artifacts over to <code>aws-sdk-rust/next</code> (this will be automated in the future)</li>
<li>Pull-request merge <code>aws-sdk-rust/next</code> into <code>aws-sdk-rust/main</code></li>
<li>Wait for successful CI in <code>main</code></li>
<li>Tag release for <code>main</code></li>
<li>Publish SDK with publisher tool</li>
</ol>
<p>The server team can then download the <code>rust-runtime:assemble</code> build artifact for the tagged release
in <code>smithy-rs</code>, and publish the <code>aws-smithy-http-server</code> crate from there.</p>
<h3 id="avoiding-mistakes-by-disallowing-creation-of-publish-ready-bundles-outside-of-ci"><a class="header" href="#avoiding-mistakes-by-disallowing-creation-of-publish-ready-bundles-outside-of-ci">Avoiding mistakes by disallowing creation of publish-ready bundles outside of CI</a></h3>
<p>It should be difficult to accidentally publish a locally built set of crates. To add friction to this,
the <code>smithy-rs</code> build process will look for the existence of the <code>GITHUB_ACTIONS=true</code> environment variable.
If this environment variable is not set, then it will pass a flag to the Rust codegen plugin that tells it to
emit a <code>publish = false</code> under <code>[package]</code> in the generated <code>Cargo.toml</code>.</p>
<p>This could be easily circumvented, but the goal is to reduce the chances of accidentally publishing
crates rather than making it impossible.</p>
<h2 id="alternatives-considered"><a class="header" href="#alternatives-considered">Alternatives Considered</a></h2>
<h3 id="publish-smithy-runtime-crates-from-smithy-rs-build-artifacts"><a class="header" href="#publish-smithy-runtime-crates-from-smithy-rs-build-artifacts">Publish Smithy runtime crates from <code>smithy-rs</code> build artifacts</a></h3>
<p>This approach is similar to the proposed solution, except that the SDK would not publish
the Smithy runtime crates. The <code>aws-sdk-rust/main</code> branch would have a small tweak to its CI
so that the SDK is tested against the Smithy runtime crates that are published to crates.io
This CI process would look as follows:</p>
<ol>
<li>Shallow clone <code>aws-sdk-rust</code> with the revision being tested</li>
<li>Run a script to remove the <code>path</code> argument for the Smithy runtime crate dependencies for every crate
in <code>aws-sdk-rust</code>. For example,</li>
</ol>
<pre><code class="language-toml">aws-smithy-types = { version = &quot;0.33.0&quot;, path = &quot;../aws-smithy-types&quot; }
</code></pre>
<p>Would become:</p>
<pre><code class="language-toml">aws-smithy-types = { version = &quot;0.33.0&quot; }
</code></pre>
<ol start="3">
<li>Run the tests as usual</li>
</ol>
<p>When it's time to cut a release, the releaser will do the following:</p>
<ol>
<li>Tag <code>smithy-rs</code> with the desired version number</li>
<li>Wait for CI to build artifacts for the tagged release</li>
<li>Pull-request the SDK artifacts over to <code>aws-sdk-rust/next</code></li>
<li>Wait for successful CI in <code>aws-sdk-rust/next</code></li>
<li>Download the Smithy runtime crates build artifact and publish it to crates.io</li>
<li>Pull-request merge <code>aws-sdk-rust/next</code> into <code>aws-sdk-rust/main</code></li>
<li>Wait for successful CI in <code>main</code> (this time actually running against the crates.io Smithy runtime crates)</li>
<li>Tag release for <code>main</code></li>
<li>Publish SDK with publisher tool</li>
</ol>
<h3 id="keep-smithy-runtime-crates-in-smithy-rs"><a class="header" href="#keep-smithy-runtime-crates-in-smithy-rs">Keep Smithy runtime crates in <code>smithy-rs</code></a></h3>
<p>This approach is similar to the previous alternative, except that the <code>aws-sdk-rust</code> repository
won't have a snapshot of the Smithy runtime crates, and an additional step needs to be performed
during CI for the <code>next</code> branch so that it looks as follows:</p>
<ol>
<li>Make a shallow clone of <code>aws-sdk-rust/next</code></li>
<li>Retrieve the <code>smithy-rs</code> commit hash that was used to generate the SDK from a file
that was generated alongside the rest of the build artifacts from <code>smithy-rs</code> and
copied into <code>aws-sdk-rust</code>.</li>
<li>Make a shallow clone of <code>smithy-rs</code> at the correct commit hash</li>
<li>Use a script to add a <code>[patch]</code> section to all the AWS SDK crates to point to the
Smithy runtime crates from the local clone of <code>smithy-rs</code>.
For example:</li>
</ol>
<pre><code class="language-toml"># The dependencies section is left alone, but is here for context
[dependencies]
# Some version of aws-smithy-types that isn't on crates.io yet, referred to as `&lt;unreleased&gt;` below
aws-smithy-types = &quot;&lt;unreleased&gt;&quot;

# This patch section gets added by the script
[patch.crates-io]
aws-smithy-types = { version = &quot;&lt;unreleased&gt;&quot;, path = &quot;path/to/local/smithy-rs/rust-runtime/aws-smithy-types&quot;}
</code></pre>
<ol start="5">
<li>Run CI as normal.</li>
</ol>
<p><strong>Note:</strong> <code>smithy-rs</code> would need to do the same patching in CI as <code>aws-sdk-rust/next</code> since the generated
SDK would not have path dependencies for the Smithy runtime crates (since they are a publish-ready bundle
intended for landing in <code>aws-sdk-rust</code>). The script that does this patching could live in <code>smithy-rs</code> and be
reused by <code>aws-sdk-rust</code>.</p>
<p>The disadvantage of this approach is that a customer having an issue with the current release wouldn't be able
to get a fix sooner by patching their own project's crate manifest to use the <code>aws-sdk-rust/next</code> branch before
a release is cut since their project wouldn't be able to find the unreleased Smithy runtime crates.</p>
<h2 id="changes-checklist-5"><a class="header" href="#changes-checklist-5">Changes Checklist</a></h2>
<ul>
<li>In <code>smithy-rs</code>:
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Move publisher tool from <code>aws-sdk-rust</code> into <code>smithy-rs</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Modify <code>aws:sdk:assemble</code> target to run the publisher <code>fix-manifests</code> subcommand</li>
<li><input disabled="" type="checkbox" checked=""/>
Add <code>rust-runtime:assemble</code> target that generates publish-ready Smithy runtime crates</li>
<li><input disabled="" type="checkbox" checked=""/>
Add CI step to create Smithy runtime bundle artifact</li>
<li><input disabled="" type="checkbox" checked=""/>
Add <code>GITHUB_ACTIONS=true</code> env var check for setting the <code>publish</code> flag in generated AND runtime manifests</li>
<li><input disabled="" type="checkbox" checked=""/>
Revise publisher tool to publish from an arbitrary directory</li>
</ul>
</li>
<li>In <code>aws-sdk-rust</code>:
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Implement CI for the <code>aws-sdk-rust/next</code> branch</li>
<li><input disabled="" type="checkbox" checked=""/>
Remove the publisher tool</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
Update release process documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<blockquote>
<p>Status: Implemented</p>
</blockquote>
<p>Smithy <a href="https://awslabs.github.io/smithy/1.0/spec/core/behavior-traits.html#paginated-trait">models paginated responses</a>
. Customers of Smithy generated code &amp; the Rust SDK will have an improved user experience if code is generated to
support this. Fundamentally, paginators are a way to automatically make a series of requests with the SDK, where subsequent
requests automatically forward output from the previous responses. There is nothing a paginator does that a user could not do manually,
they merely simplify the common task of interacting with paginated APIs. **Specifically, a paginator will resend the orginal request
but with <code>inputToken</code> updated to the value of the previous <code>outputToken</code>.</p>
<p>In this RFC, we propose modeling paginated data as
a  <a href="https://docs.rs/tokio-stream/0.1.5/tokio_stream/#traits"><code>Stream</code></a> of output shapes.</p>
<ul>
<li>When an output is paginated, a <code>paginate()</code> method will be added to the high level builder</li>
<li>An <code>&lt;OperationName&gt;Paginator</code> struct will be generated into the <code>paginator</code> module.</li>
<li>If <code>items</code> is modeled, <code>paginate().items()</code> will be added to produce the paginated
items. <code>&lt;OperationName&gt;PaginatorItems</code> will be generated into the <code>paginator</code> module.</li>
</ul>
<p>The <a href="https://docs.rs/tokio-stream/latest/tokio_stream/index.html"><code>Stream</code></a> trait enables customers to use a number of
abstractions including simple looping, and <code>collect()</code>ing all data in a single call. A paginator will resend the
original input, but with the field marked <code>inputToken</code> to the value of <code>outputToken</code> in the previous output.</p>
<p>Usage example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let paginator = client
    .list_tables()
    .paginate()
    .items()
    .page_size(10)
    .send()
    .await;
let tables: Result&lt;Vec&lt;_ &gt;, _ &gt; = paginator.collect().await;
<span class="boring">}
</span></code></pre></pre>
<p>Paginators are lazy and only retrieve pages when polled by a client.</p>
<h3 id="details"><a class="header" href="#details">Details</a></h3>
<p>Paginators will be generated into the <code>paginator</code> module of service crates. Currently, paginators are <em>not</em> feature gated, but this
could be considered in the future. A <code>paginator</code> struct captures 2 pieces of data:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// dynamodb/src/paginator.rs
struct ListTablesPaginator&lt;C, M, R&gt; {
    // holds the low-level client and configuration
    handle: Arc&lt;Handle&lt;C, M, R&gt;&gt;,

    // input builder to construct the actual input on demand
    input: ListTablesInputBuilder
}
<span class="boring">}
</span></code></pre></pre>
<p>In addition to the basic usage example above, when <code>pageSize</code> is modeled, customers can specify the page size during
pagination:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut tables = vec![];
let mut pages = client
    .list_tables()
    .paginate()
    .page_size(20)
    .send();
while let Some(next_page) = pages.try_next().await? {
    // pages of 20 items requested from DynamoDb
    tables.extend(next_page.table_names.unwrap_or_default().into_iter());
}
<span class="boring">}
</span></code></pre></pre>
<p>Paginators define a public method <code>send()</code>. This method
returns <code>impl Stream&lt;Item=Result&lt;OperationOutput, OperationError&gt;</code>. This uses <code>FnStream</code> defined in the <code>aws-smithy-async</code> crate which
enables demand driven execution of a closure. A rendezvous channel is used which will block on <code>send</code> until demand exists.</p>
<p>When modeled by Smithy, <code>page_size</code> which automatically sets the appropriate page_size parameter and <code>items()</code> which returns an
automatically flattened paginator are also generated. <strong>Note</strong>: <code>page_size</code> directly sets the modeled parameter on the internal builder.
This means that a value set for page size will override any previously set value for that field.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Generated paginator for ListTables
impl&lt;C, M, R&gt; ListTablesPaginator&lt;C, M, R&gt;
{
  /// Set the page size
  pub fn page_size(mut self, limit: i32) -&gt; Self {
    self.builder.limit = Some(limit);
    self
  }

  /// Create a flattened paginator
  ///
  /// This paginator automatically flattens results using `table_names`. Queries to the underlying service
  /// are dispatched lazily.
  pub fn items(self) -&gt; crate::paginator::ListTablesPaginatorItems&lt;C, M, R&gt; {
    crate::paginator::ListTablesPaginatorItems(self)
  }

  /// Create the pagination stream
  ///
  /// _Note:_ No requests will be dispatched until the stream is used (eg. with [`.next().await`](tokio_stream::StreamExt::next)).
  pub async fn send(
    self,
  ) -&gt; impl tokio_stream::Stream&lt;
    Item = std::result::Result&lt;
      crate::output::ListTablesOutput,
      aws_smithy_http::result::SdkError&lt;crate::error::ListTablesError&gt;,
    &gt;,
  &gt; + Unpin
  {
    // Move individual fields out of self for the borrow checker
    let builder = self.builder;
    let handle = self.handle;
    fn_stream::FnStream::new(move |tx| {
      Box::pin(async move {
        // Build the input for the first time. If required fields are missing, this is where we'll produce an early error.
        let mut input = match builder.build().map_err(|err| {
          SdkError::ConstructionFailure(err.into())
        }) {
          Ok(input) =&gt; input,
          Err(e) =&gt; {
            let _ = tx.send(Err(e)).await;
            return;
          }
        };
        loop {
          let op = match input.make_operation(&amp;handle.conf).await.map_err(|err| {
            SdkError::ConstructionFailure(err.into())
          }) {
            Ok(op) =&gt; op,
            Err(e) =&gt; {
              let _ = tx.send(Err(e)).await;
              return;
            }
          };
          let resp = handle.client.call(op).await;
          // If the input member is None or it was an error
          let done = match resp {
            Ok(ref resp) =&gt; {
              input.exclusive_start_table_name = crate::lens::reflens_structure_crate_output_list_tables_output_last_evaluated_table_name(resp).cloned();
              input.exclusive_start_table_name.is_none()
            }
            Err(_) =&gt; true,
          };
          if let Err(_) = tx.send(resp).await {
            // receiving end was dropped
            return;
          }
          if done {
            return;
          }
        }
      })
    })
  }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>On Box::pin</strong>: The stream returned by <code>AsyncStream</code> does not implement <code>Unpin</code>. Unfortunately, this makes iteration
require an invocation of <code>pin_mut!</code> and generates several hundred lines of compiler errors. Box::pin seems a worthwhile
trade off to improve the user experience.</p>
<p><strong>On the <code>+ Unpin</code> bound</strong>: Because auto-traits leak across <code>impl Trait</code> boundaries, <code>+ Unpin</code> prevents accidental
regressions in the generated code which would break users.</p>
<p><strong>On the crate::reflens::...</strong>: We use <code>LensGenerator.kt</code> to generate potentially complex accessors to deeply nested fields.</p>
<h3 id="updates-to-ergonomic-clients"><a class="header" href="#updates-to-ergonomic-clients">Updates to ergonomic clients</a></h3>
<p>The <code>builders</code> generated by ergonomic clients will gain the following method, if they represent an operation that implements the <code>Paginated</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Create a paginator for this request
///
/// Paginators are used by calling [`send().await`](crate::paginator::ListTablesPaginator::send) which returns a [`Stream`](tokio_stream::Stream).
pub fn paginate(self) -&gt; crate::paginator::ListTablesPaginator&lt;C, M, R&gt; {
  crate::paginator::ListTablesPaginator::new(self.handle, self.inner)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="discussion-areas"><a class="header" href="#discussion-areas">Discussion Areas</a></h2>
<h3 id="on-sendawait"><a class="header" href="#on-sendawait">On <code>send().await</code></a></h3>
<p>Calling <code>send().await</code> is not necessary from an API perspective—we could have the paginators impl-stream directly. However,
it enables using <code>impl Trait</code> syntax and also makes the API consistent with other SDK APIs.</p>
<h3 id="on-tokio_streamstream"><a class="header" href="#on-tokio_streamstream">On <code>tokio_stream::Stream</code></a></h3>
<p>Currently, the core trait we use is <code>tokio_stream::Stream</code>. This is a re-export from futures-util. There are a few other choices:</p>
<ol>
<li>Re-export <code>Stream</code> from tokio_stream.</li>
<li>Use <code>futures_util</code> directly</li>
</ol>
<h3 id="on-generics"><a class="header" href="#on-generics">On Generics</a></h3>
<p>Currently, the paginators forward the generics from the client (<code>C, M, R</code>) along with their fairly annoying bounds.
However, if we wanted to we <em>could</em> simplify this and erase all the generics when the paginator was created. Since everything
is code generated, there isn't actually much duplicated code in the generator, just in the generated code.</p>
<h2 id="changes-checklist-6"><a class="header" href="#changes-checklist-6">Changes Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Create and test <code>FnStream</code> abstraction</li>
<li><input disabled="" type="checkbox" checked=""/>
Generate page-level paginators</li>
<li><input disabled="" type="checkbox" checked=""/>
Generate <code>.items()</code> paginators</li>
<li><input disabled="" type="checkbox" checked=""/>
Generate doc hints pointing people to paginators</li>
<li><input disabled="" type="checkbox" checked=""/>
Integration test using mocked HTTP traffic against a generated paginator for a real service</li>
<li><input disabled="" type="checkbox"/>
Integration test using real traffic</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-examples-consolidation"><a class="header" href="#rfc-examples-consolidation">RFC: Examples Consolidation</a></h1>
<blockquote>
<p>Status: Implemented</p>
</blockquote>
<p>Currently, the AWS Rust SDK's examples are duplicated across
<a href="https://github.com/awslabs/aws-sdk-rust"><code>awslabs/aws-sdk-rust</code></a>,
<a href="https://github.com/awslabs/smithy-rs"><code>awslabs/smithy-rs</code></a>,
and <a href="https://github.com/awsdocs/aws-doc-sdk-examples"><code>awsdocs/aws-doc-sdk-examples</code></a>.
The <code>smithy-rs</code> repository was formerly the source of truth for examples,
with the examples being copied over to <code>aws-sdk-rust</code> as part of the release
process, and examples were manually copied over to <code>aws-doc-sdk-examples</code> so that
they could be included in the developer guide.</p>
<p>Now that the SDK is more stable with less frequent breaking changes,
the <code>aws-doc-sdk-examples</code> repository can become the source of truth
so long as the examples are tested against <code>smithy-rs</code> and continue to be
copied into <code>aws-sdk-rust</code>.</p>
<h2 id="requirements-3"><a class="header" href="#requirements-3">Requirements</a></h2>
<ol>
<li>Examples are authored and maintained in <code>aws-doc-sdk-examples</code></li>
<li>Examples are no longer present in <code>smithy-rs</code></li>
<li>CI in <code>smithy-rs</code> checks out examples from <code>aws-doc-sdk-examples</code> and
builds them against the generated SDK. Success for this CI job is optional for merging
since there can be a time lag between identifying that examples are broken and fixing them.</li>
<li>Examples must be copied into <code>aws-sdk-rust</code> so that the examples for a specific
version of the SDK can be easily referenced.</li>
<li>Examples must be verified in <code>aws-sdk-rust</code> prior to merging into the <code>main</code> branch.</li>
</ol>
<h2 id="example-ci-in-smithy-rs"><a class="header" href="#example-ci-in-smithy-rs">Example CI in <code>smithy-rs</code></a></h2>
<p>A CI job will be added to <code>smithy-rs</code> that:</p>
<ol>
<li>Depends on the CI job that generates the full AWS SDK</li>
<li>Checks out the <code>aws-doc-sdk-examples</code> repository</li>
<li>Modifies example <strong>Cargo.toml</strong> files to point to the newly generated AWS SDK crates</li>
<li>Runs <code>cargo check</code> on each example</li>
</ol>
<p>This job will not be required to pass for branch protection, but will
let us know that examples need to be updated before the next release.</p>
<h2 id="auto-sync-to-aws-sdk-rust-from-smithy-rs-changes"><a class="header" href="#auto-sync-to-aws-sdk-rust-from-smithy-rs-changes">Auto-sync to <code>aws-sdk-rust</code> from <code>smithy-rs</code> changes</a></h2>
<p>The auto-sync job that copies generated code from <code>smithy-rs</code> into the
<code>aws-sdk-rust/next</code> branch will be updated to check out the <code>aws-doc-sdk-examples</code>
repository and copy the examples into <code>aws-sdk-rust</code>. The example <strong>Cargo.toml</strong> files
will also be updated to point to the local crate paths as part of this process.</p>
<p>The <code>aws-sdk-rust</code> CI already requires examples to compile, so merging <code>next</code> into <code>main</code>,
the step required to perform a release, will be blocked until the examples are fixed.</p>
<p>In the event the examples don't work on the <code>next</code> branch, developers and example writers
will need to be able to point the examples in <code>aws-doc-sdk-examples</code> to the generated
SDK in <code>next</code> so that they can verify their fixes. This can be done by hand, or a tool
can be written to automate it if a significant number of examples need to be fixed.</p>
<h2 id="process-risks"><a class="header" href="#process-risks">Process Risks</a></h2>
<p>There are a couple of risks with this approach:</p>
<ol>
<li>
<p><strong>Risk:</strong> Examples are broken and an urgent fix needs to be released.</p>
<p><strong>Possible mitigations:</strong></p>
<ol>
<li>Revert the change that broke the examples and then add the urgent fix</li>
<li>Create a patch branch in <code>aws-sdk-rust</code>, apply the fix to that based off an older
version of <code>smithy-rs</code> with the fix applied, and merge that into <code>main</code>.</li>
</ol>
</li>
<li>
<p><strong>Risk:</strong> A larger project requires changes to examples prior to GA, but multiple releases
need to occur before the project completion.</p>
<p><strong>Possible mitigations:</strong></p>
<ol>
<li>If the required changes compile against the older SDK, then just make the changes
to the examples.</li>
<li>Feature gate any incremental new functionality in <code>smithy-rs</code>, and work on example
changes on a branch in <code>aws-doc-sdk-examples</code>. When wrapping up the project,
remove the feature gating and merge the examples into the <code>main</code> branch.</li>
</ol>
</li>
</ol>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<h3 id="aws-sdk-rust-as-the-source-of-truth"><a class="header" href="#aws-sdk-rust-as-the-source-of-truth"><code>aws-sdk-rust</code> as the source of truth</a></h3>
<p>Alternatively, the examples could reside in <code>aws-sdk-rust</code>, be referenced
from <code>smithy-rs</code> CI, and get copied into <code>aws-doc-sdk-examples</code> for inclusion
in the user guide.</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Prior to GA, fixing examples after making breaking changes to the SDK would be easier.
Otherwise, <strong>Cargo.toml</strong> files have to be temporarily modified to point to the
<code>aws-sdk-rust/next</code> branch in order to make fixes.</li>
<li>If a customer discovers examples via the <code>aws-sdk-rust</code> repository rather than via the
SDK user guide, then it would be more obvious how to make changes to examples. At time
of writing, the examples in the user guide link to the <code>aws-doc-sdk-examples</code> repository,
so if the examples are discovered that way, then updating them should already be clear.</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Tooling would need to be built to sync examples from <code>aws-sdk-rust</code> into
<code>aws-doc-sdk-examples</code> so that they could be incorporated into the user guide.</li>
<li>Creates a circular dependency between the <code>aws-sdk-rust</code> and <code>smithy-rs</code> repositories.
CI in <code>smithy-rs</code> needs to exercise examples, which would be in <code>aws-sdk-rust</code>, and
<code>aws-sdk-rust</code> has its code generated by <code>smithy-rs</code>. This is workable, but may lead
to problems later on.</li>
</ul>
<p>The tooling to auto-sync from <code>aws-sdk-rust</code> into <code>aws-doc-sdk-examples</code> will likely cost
more than tooling to temporarily update <strong>Cargo.toml</strong> files to make example fixes (if
that tooling is even necessary).</p>
<h2 id="changes-checklist-7"><a class="header" href="#changes-checklist-7">Changes Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Add example CI job to <code>smithy-rs</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Diff examples in <code>smithy-rs</code> and <code>aws-doc-sdk-examples</code> and move desired differences into <code>aws-doc-sdk-examples</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Apply example fix PRs from <code>aws-sdk-rust</code> into <code>aws-doc-sdk-examples</code></li>
<li><input disabled="" type="checkbox" checked=""/>
Update <code>smithy-rs</code> CI to copy examples from <code>aws-doc-sdk-examples</code> rather than from smithy-rs</li>
<li><input disabled="" type="checkbox" checked=""/>
Delete examples from <code>smithy-rs</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-waiters"><a class="header" href="#rfc-waiters">RFC: Waiters</a></h1>
<blockquote>
<p>Status: Accepted</p>
</blockquote>
<p>Waiters are a convenient polling mechanism to wait for a resource to become available or to
be deleted. For example, a waiter could be used to wait for a S3 bucket to be created after
a call to the <code>CreateBucket</code> API, and this would only require a small amount of code rather
than building out an entire polling mechanism manually.</p>
<p>At the highest level, a waiter is a simple polling loop (pseudo-Rust):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Track state that contains the number of attempts made and the previous delay
let mut state = initial_state();

loop {
    // Poll the service
    let result = poll_service().await;

    // Classify the action that needs to be taken based on the Smithy model
    match classify(result) {
        // If max attempts hasn't been exceeded, then retry after a delay. Otherwise, error.
        Retry =&gt; if state.should_retry() {
            let delay = state.next_retry();
            sleep(delay).await;
        } else {
            return error_max_attempts();
        }
        // Otherwise, if the termination condition was met, return the output
        Terminate(result) =&gt; return result,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In the AWS SDK for Rust, waiters can be added without making any backwards breaking changes
to the current API. This doc outlines the approach to add them in this fashion, but does <em>NOT</em>
examine code generating response classification from JMESPath expressions, which can be left
to the implementer without concern for the overall API.</p>
<h2 id="terminology-5"><a class="header" href="#terminology-5">Terminology</a></h2>
<p>Today, there are three layers of <code>Client</code> that are easy to confuse, so to make the following easier to follow,
the following terms will be used:</p>
<ul>
<li><strong>Connector</strong>: An implementor of Tower's <code>Service</code> trait that converts a request into a response. This is typically
a thin wrapper around a Hyper client.</li>
<li><strong>Smithy Client</strong>: A <code>aws_smithy_client::Client&lt;C, M, R&gt;</code> struct that is responsible for gluing together
the connector, middleware, and retry policy. This isn't intended to be used directly.</li>
<li><strong>Fluent Client</strong>: A code generated <code>Client&lt;C, M, R&gt;</code> that has methods for each service operation on it.
A fluent builder is generated alongside it to make construction easier.</li>
<li><strong>AWS Client</strong>: A specialized Fluent Client that uses a <code>DynConnector</code>, <code>DefaultMiddleware</code>,
and <code>Standard</code> retry policy.</li>
</ul>
<p>All of these are just called <code>Client</code> in code today. This is something that could be clarified in a separate refactor.</p>
<h2 id="requirements-4"><a class="header" href="#requirements-4">Requirements</a></h2>
<p>Waiters must adhere to the <a href="https://awslabs.github.io/smithy/1.0/spec/waiters.html">Smithy waiter specification</a>. To summarize:</p>
<ol>
<li>Waiters are specified by the Smithy <code>@waitable</code> trait</li>
<li>Retry during polling must be exponential backoff with jitter, with the min/max delay times and
max attempts configured by the <code>@waitable</code> trait</li>
<li>The SDK's built-in retry needs to be replaced by the waiter's retry since the Smithy model
can specify retry conditions that are contrary to the defaults. For example, an error that
would otherwise be retried by default might be the termination condition for the waiter.</li>
<li>Classification of the response must be code generated based on the JMESPath expression in the model.</li>
</ol>
<h2 id="waiter-api"><a class="header" href="#waiter-api">Waiter API</a></h2>
<p>To invoke a waiter, customers will only need to invoke a single function on the AWS Client. For example,
if waiting for a S3 bucket to exist, it would look like the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Request bucket creation
client.create_bucket()
    .bucket_name(&quot;my-bucket&quot;)
    .send()
    .await()?;

// Wait for it to be created
client.wait_until_bucket_exists()
    .bucket_name(&quot;my-bucket&quot;)
    .send()
    .await?;
<span class="boring">}
</span></code></pre></pre>
<p>The call to <code>wait_until_bucket_exists()</code> will return a waiter-specific fluent builder with a <code>send()</code> function
that will start the polling and return a future.</p>
<p>To avoid name conflicts with other API methods, the waiter functions can be added to the client via trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait WaitUntilBucketExists {
    fn wait_until_bucket_exists(&amp;self) -&gt; crate::waiter::bucket_exists::Builder;
}
<span class="boring">}
</span></code></pre></pre>
<p>This trait would be implemented for the service's fluent client (which will necessitate making the fluent client's
<code>handle</code> field <code>pub(crate)</code>).</p>
<h2 id="waiter-implementation"><a class="header" href="#waiter-implementation">Waiter Implementation</a></h2>
<p>A waiter trait implementation will merely return a fluent builder:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WaitUntilBucketExists for Client {
    fn wait_until_bucket_exists(&amp;self) -&gt; crate::waiter::bucket_exists::Builder {
        crate::waiter::bucket_exists::Builder::new()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This builder will have a short <code>send()</code> function to kick off the actual waiter implementation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Builder {
    // ... existing fluent builder codegen can be reused to create all the setters and constructor

    pub async fn send(self) -&gt; Result&lt;HeadBucketOutput, SdkError&lt;HeadBucketError&gt;&gt; {
        // Builds an input from this builder
        let input = self.inner.build().map_err(|err| aws_smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
        // Passes in the client's handle, which contains a Smithy client and client config
        crate::waiter::bucket_exists::wait(self.handle, input).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This wait function needs to, in a loop similar to the pseudo-code in the beginning,
convert the given input into an operation, replace the default response classifier on it
with a no-retry classifier, and then determine what to do next based on that classification:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub async fn wait(
    handle: Arc&lt;Handle&lt;DynConnector, DynMiddleware&lt;DynConnector&gt;, retry::Standard&gt;&gt;,
    input: HeadBucketInput,
) -&gt; Result&lt;HeadBucketOutput, SdkError&lt;HeadBucketError&gt;&gt; {
    loop {
        let operation = input
            .make_operation(&amp;handle.conf)
            .await
            .map_err(|err| {
                aws_smithy_http::result::SdkError::ConstructionFailure(err.into())
            })?;
        // The `ClassifyResponse` trait is implemented for `()` as never retry,
        // so this disables the default retry for the operation
        let operation = operation.with_retry_policy(());

        let result = handle.client.call(operation).await;
        match classify_result(&amp;input, result) {
            AcceptorState::Retry =&gt; {
                // The sleep implementation is available here from `handle.conf.sleep_impl`
                unimplemented!(&quot;Check if another attempt should be made and calculate delay time if so&quot;)
            }
            AcceptorState::Terminate(output) =&gt; return output,
        }
    }
}

fn classify_result(
    input: &amp;HeadBucketInput,
    result: Result&lt;HeadBucketOutput, SdkError&lt;HeadBucketError&gt;&gt;,
) -&gt; AcceptorState&lt;HeadBucketOutput, SdkError&lt;HeadBucketError&gt;&gt; {
    unimplemented!(
        &quot;The Smithy model would dictate conditions to check here to produce an `AcceptorState`&quot;
    )
}
<span class="boring">}
</span></code></pre></pre>
<p>The retry delay time should be calculated by the same exponential backoff with jitter code that the
<a href="https://github.com/awslabs/smithy-rs/blob/main/rust-runtime/aws-smithy-client/src/retry.rs#L252-L292">default <code>RetryHandler</code> uses in <code>aws-smithy-client</code></a>. This function will need to be split up and made
available to the waiter implementations so that just the delay can be calculated.</p>
<h2 id="changes-checklist-8"><a class="header" href="#changes-checklist-8">Changes Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Codegen fluent builders for waiter input and their <code>send()</code> functions</li>
<li><input disabled="" type="checkbox"/>
Codegen waiter invocation traits</li>
<li><input disabled="" type="checkbox"/>
Commonize exponential backoff with jitter delay calculation</li>
<li><input disabled="" type="checkbox"/>
Codegen <code>wait()</code> functions with delay and max attempts configuration from Smithy model</li>
<li><input disabled="" type="checkbox"/>
Codegen <code>classify_result()</code> functions based on JMESPath expressions in Smithy model</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rfc-publishing-the-alpha-sdk-to-cratesio"><a class="header" href="#rfc-publishing-the-alpha-sdk-to-cratesio">RFC: Publishing the Alpha SDK to Crates.io</a></h1>
<blockquote>
<p>Status: Implemented</p>
</blockquote>
<p>The AWS SDK for Rust and its supporting Smithy crates need to be published to <a href="https://crates.io/">crates.io</a>
so that customers can include them in their projects and also publish crates of their own that depend on them.</p>
<p>This doc proposes a short-term solution for publishing to crates.io. This approach is intended to be executed
manually by a developer using scripts and an SOP no more than once per week, and should require less than a
dev week to implement.</p>
<h2 id="terminology-6"><a class="header" href="#terminology-6">Terminology</a></h2>
<ul>
<li><strong>AWS SDK Crate</strong>: A crate that provides a client for calling a given AWS service, such as <code>aws-sdk-s3</code> for calling S3.</li>
<li><strong>AWS Runtime Crate</strong>: Any runtime crate that the AWS SDK generated code relies on, such as <code>aws-types</code>.</li>
<li><strong>Smithy Runtime Crate</strong>: Any runtime crate that the smithy-rs generated code relies on, such as <code>smithy-types</code>.</li>
</ul>
<h2 id="requirements-5"><a class="header" href="#requirements-5">Requirements</a></h2>
<h3 id="versioning"><a class="header" href="#versioning">Versioning</a></h3>
<p>Cargo uses <a href="https://github.com/dtolnay/semver#requirements">semver</a> for versioning,
with a <code>major.minor.patch-pre</code> format:</p>
<ul>
<li><code>major</code>: Incompatible API changes</li>
<li><code>minor</code>: Added functionality in backwards compatible manner</li>
<li><code>patch</code>: Backwards compatible bug fixes</li>
<li><code>pre</code>: Pre-release version tag (omitted for normal releases)</li>
</ul>
<p>For now, AWS SDK crates (including <code>aws-config</code>) will maintain a consistent <code>major</code> and <code>minor</code> version number
across all services. The latest version of <code>aws-sdk-s3</code> will always have the same <code>major.minor</code> version as the
latest <code>aws-sdk-dynamodb</code>, for example. The <code>patch</code> version is allowed to be different between service crates,
but it is unlikely that we will make use of <code>patch</code> versions throughout alpha and dev preview.
Smithy runtime crates will have different version numbers from the AWS SDK crates, but will also maintain
a consistent <code>major.minor</code>.</p>
<p>The <code>pre</code> version tag will be <code>alpha</code> during the Rust SDK alpha, and will be removed once the SDK is in
dev preview.</p>
<p>During alpha, the <code>major</code> version will always be 0, and the <code>minor</code> will be bumped for all published
crates for every release. A later RFC may change the process during dev preview.</p>
<h3 id="yanking"><a class="header" href="#yanking">Yanking</a></h3>
<p>Mistakes will inevitably be made, and a mechanism is needed to yank packages while keeping the latest version
of the SDK successfully consumable from crates.io. To keep this simple, the entire published batch of crates
will be yanked if any crate in that batch needs to be yanked. For example, if 260 crates were published in a batch,
and it turns out there's a problem that requires yanking one of them, then all 260 will be yanked. Attempting to do
partial yanking will require a lot of effort and be difficult to get right. Yanking should be a last resort.</p>
<h2 id="concrete-scenarios"><a class="header" href="#concrete-scenarios">Concrete Scenarios</a></h2>
<p>The following changes will be bundled together as a <code>minor</code> version bump during weekly releases:</p>
<ul>
<li>AWS model updates</li>
<li>New features</li>
<li>Bug fixes in runtime crates or codegen</li>
</ul>
<p>In exceptional circumstances, a <code>patch</code> version will be issued if the fix doesn't require API breaking changes:</p>
<ul>
<li>CVE discovered in a runtime crate</li>
<li>Buggy update to a runtime crate</li>
</ul>
<p>In the event of a CVE being discovered in an external dependency, if the external dependency is
internal to a crate, then a <code>patch</code> revision can be issued for that crate to correct it. Otherwise if the CVE
is in a dependency that is part of the public API, a <code>minor</code> revision will be issued with an expedited release.</p>
<p>For a CVE in generated code, a <code>minor</code> revision will be issued with an expedited release.</p>
<h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<p>The short-term approach builds off our pre-crates.io weekly release process. That process was the following:</p>
<ol>
<li>Run script to update AWS models</li>
<li>Manually update AWS SDK version in <code>aws/sdk/gradle.properties</code> in smithy-rs</li>
<li>Tag smithy-rs</li>
<li>Wait for GitHub actions to generate AWS SDK using newly released smithy-rs</li>
<li>Check out aws-sdk-rust, delete existing SDK code, unzip generated SDK in place, and update readme</li>
<li>Tag aws-sdk-rust</li>
</ol>
<p>To keep things simple:</p>
<ul>
<li>The Smithy runtime crates will have the same smithy-rs version</li>
<li>All AWS crates will have the same AWS SDK version</li>
<li><code>patch</code> revisions are exceptional and will be one-off manually published by a developer</li>
</ul>
<p>All runtime crate version numbers in smithy-rs will be locked at <code>0.0.0-smithy-rs-head</code>. This is a fake
version number that gets replaced when generating the SDK.</p>
<p>The SDK generator script in smithy-rs will be updated to:</p>
<ul>
<li>Replace Smithy runtime crate versions with the smithy-rs version from <code>aws/sdk/gradle.properties</code></li>
<li>Replace AWS runtime crate versions with AWS SDK version from <code>aws/sdk/gradle.properties</code></li>
<li>Add correct version numbers to all path dependencies in all the final crates that end up in the build artifacts</li>
</ul>
<p>This will result in all the crates having the correct version and manifests when imported into aws-sdk-rust.
From there, a script needs to be written to determine crate dependency order, and publish crates (preferably
with throttling and retry) in the correct order. This script needs to be able to recover from an interruption
part way through publishing all the crates, and it also needs to output a list of all crate versions published
together. This crate list will be commented on the release issue so that yanking the batch can be done if
necessary.</p>
<p>The new release process would be:</p>
<ol>
<li>Run script to update AWS models</li>
<li>Manually update <em>both</em> the AWS SDK version <em>and</em> the smithy-rs version in <code>aws/sdk/gradle.properties</code> in smithy-rs</li>
<li>Tag smithy-rs</li>
<li>Wait for automation to sync changes to <code>aws-sdk-rust/next</code></li>
<li>Cut a PR to merge <code>aws-sdk-rust/next</code> into <code>aws-sdk-rust/main</code></li>
<li>Tag aws-sdk-rust</li>
<li>Run publish script</li>
</ol>
<h3 id="short-term-changes-checklist"><a class="header" href="#short-term-changes-checklist">Short-term Changes Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Prepare runtime crate manifests for publication to crates.io (https://github.com/awslabs/smithy-rs/pull/755)</li>
<li><input disabled="" type="checkbox" checked=""/>
Update SDK generator to set correct crate versions (https://github.com/awslabs/smithy-rs/pull/755)</li>
<li><input disabled="" type="checkbox" checked=""/>
Write bulk publish script</li>
<li><input disabled="" type="checkbox" checked=""/>
Write bulk yank script</li>
<li><input disabled="" type="checkbox" checked=""/>
Write automation to sync smithy-rs to aws-sdk-rust</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
