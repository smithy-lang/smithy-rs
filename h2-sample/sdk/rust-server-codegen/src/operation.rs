// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
const CONTENT_TYPE_SAMPLEOPERATION: ::mime::Mime = ::mime::APPLICATION_JSON;
::pin_project_lite::pin_project! {
    /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
    /// [`SampleOperationInput`](crate::input::SampleOperationInput) using modelled bindings.
    pub struct SampleOperationInputFuture {
        inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::SampleOperationInput, ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError>> + Send>>
    }
}

impl std::future::Future for SampleOperationInputFuture {
    type Output = Result<
        crate::input::SampleOperationInput,
        ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError,
    >;

    fn poll(
        self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        let this = self.project();
        this.inner.as_mut().poll(cx)
    }
}

impl<B>
    ::aws_smithy_http_server::request::FromRequest<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
        B,
    > for crate::input::SampleOperationInput
where
    B: ::aws_smithy_http_server::body::HttpBody + Send,
    B: 'static,

    B::Data: Send,
    ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection:
        From<<B as ::aws_smithy_http_server::body::HttpBody>::Error>,
{
    type Rejection = ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError;
    type Future = SampleOperationInputFuture;

    fn from_request(request: ::http::Request<B>) -> Self::Future {
        let fut = async move {
            if !::aws_smithy_http_server::protocol::accept_header_classifier(
                request.headers(),
                &CONTENT_TYPE_SAMPLEOPERATION,
            ) {
                return Err(::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection::NotAcceptable);
            }
            crate::protocol_serde::shape_sample_operation::de_sample_operation_http_request(request)
                .await
        };
        use ::futures_util::future::TryFutureExt;
        let fut = fut.map_err(
            |e: ::aws_smithy_http_server::protocol::rest_json_1::rejection::RequestRejection| {
                ::tracing::debug!(error = %e, "failed to deserialize request");
                ::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(
                    e,
                )
            },
        );
        SampleOperationInputFuture {
            inner: Box::pin(fut),
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::output::SampleOperationOutput
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_sample_operation::ser_sample_operation_http_response(
            self,
        ) {
            Ok(response) => response,
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
impl
    ::aws_smithy_http_server::response::IntoResponse<
        ::aws_smithy_http_server::protocol::rest_json_1::RestJson1,
    > for crate::error::SampleOperationError
{
    fn into_response(self) -> ::aws_smithy_http_server::response::Response {
        match crate::protocol_serde::shape_sample_operation::ser_sample_operation_http_error(&self)
        {
            Ok(mut response) => {
                response.extensions_mut().insert(
                    ::aws_smithy_http_server::extension::ModeledErrorExtension::new(self.name()),
                );
                response
            }
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_http_server::response::IntoResponse::<::aws_smithy_http_server::protocol::rest_json_1::RestJson1>::into_response(::aws_smithy_http_server::protocol::rest_json_1::runtime_error::RuntimeError::from(e))
            }
        }
    }
}
