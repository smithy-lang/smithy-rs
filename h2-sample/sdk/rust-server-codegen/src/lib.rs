#![allow(deprecated)]
#![allow(unknown_lints)]
#![allow(clippy::module_inception)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::wrong_self_convention)]
#![allow(clippy::should_implement_trait)]
#![allow(clippy::disallowed_names)]
#![allow(clippy::vec_init_then_push)]
#![allow(clippy::type_complexity)]
#![allow(clippy::needless_return)]
#![allow(clippy::derive_partial_eq_without_eq)]
#![allow(clippy::result_large_err)]
#![allow(clippy::unnecessary_map_on_constructor)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::invalid_html_tags)]
#![forbid(unsafe_code)]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
//! sdk

// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
//! A fast and customizable Rust implementation of the SampleService Smithy service.
//!
//! # Using SampleService
//!
//! The primary entrypoint is [`SampleService`]: it satisfies the [`Service<http::Request, Response = http::Response>`](::tower::Service)
//! trait and therefore can be handed to a [`hyper` server](https://github.com/hyperium/hyper) via [`SampleService::into_make_service`]
//! or used in AWS Lambda
#![cfg_attr(
    feature = "aws-lambda",
    doc = " via [`LambdaHandler`](crate::server::routing::LambdaHandler)."
)]
#![cfg_attr(
    not(feature = "aws-lambda"),
    doc = " by enabling the `aws-lambda` feature flag and utilizing the `LambdaHandler`."
)]
//! The [`crate::input`], [`crate::output`], and [`crate::error`]
//! modules provide the types used in each operation.
//!
//! ### Running on Hyper
//!
//! ```rust,no_run
//! # use std::net::SocketAddr;
//! # async fn dummy() {
//! use sdk::{SampleService, SampleServiceConfig};
//!
//! # let app = SampleService::builder(
//! #     SampleServiceConfig::builder()
//! #         .build()
//! # ).build_unchecked();
//! let server = app.into_make_service();
//! let bind: SocketAddr = "127.0.0.1:6969".parse()
//!     .expect("unable to parse the server bind address and port");
//! ::hyper::Server::bind(&bind).serve(server).await.unwrap();
//! # }
//! ```
//!
//! ### Running on Lambda
//!
//! ```rust,ignore
//! use sdk::server::routing::LambdaHandler;
//! use sdk::SampleService;
//!
//! # async fn dummy() {
//! # let app = SampleService::builder(
//! #     SampleServiceConfig::builder()
//! #         .build()
//! # ).build_unchecked();
//! let handler = LambdaHandler::new(app);
//! lambda_http::run(handler).await.unwrap();
//! # }
//! ```
//!
//! # Building the SampleService
//!
//! To construct [`SampleService`] we use [`SampleServiceBuilder`] returned by [`SampleService::builder`].
//!
//! ## Plugins
//!
//! The [`SampleService::builder`] method, returning [`SampleServiceBuilder`],
//! accepts a config object on which plugins can be registered.
//! Plugins allow you to build middleware which is aware of the operation it is being applied to.
//!
//! ```rust,no_run
//! # use sdk::server::plugin::IdentityPlugin as LoggingPlugin;
//! # use sdk::server::plugin::IdentityPlugin as MetricsPlugin;
//! # use ::hyper::Body;
//! use sdk::server::plugin::HttpPlugins;
//! use sdk::{SampleService, SampleServiceConfig, SampleServiceBuilder};
//!
//! let http_plugins = HttpPlugins::new()
//!         .push(LoggingPlugin)
//!         .push(MetricsPlugin);
//! let config = SampleServiceConfig::builder().build();
//! let builder: SampleServiceBuilder<Body, _, _, _> = SampleService::builder(config);
//! ```
//!
//! Check out [`crate::server::plugin`] to learn more about plugins.
//!
//! ## Handlers
//!
//! [`SampleServiceBuilder`] provides a setter method for each operation in your Smithy model. The setter methods expect an async function as input, matching the signature for the corresponding operation in your Smithy model.
//! We call these async functions **handlers**. This is where your application business logic lives.
//!
//! Every handler must take an `Input`, and optional [`extractor arguments`](crate::server::request), while returning:
//!
//! * A `Result<Output, Error>` if your operation has modeled errors, or
//! * An `Output` otherwise.
//!
//! ```rust,no_run
//! # struct Input;
//! # struct Output;
//! # struct Error;
//! async fn infallible_handler(input: Input) -> Output { todo!() }
//!
//! async fn fallible_handler(input: Input) -> Result<Output, Error> { todo!() }
//! ```
//!
//! Handlers can accept up to 8 extractors:
//!
//! ```rust,no_run
//! # struct Input;
//! # struct Output;
//! # struct Error;
//! # struct State;
//! # use std::net::SocketAddr;
//! use sdk::server::request::{extension::Extension, connect_info::ConnectInfo};
//!
//! async fn handler_with_no_extensions(input: Input) -> Output {
//!     todo!()
//! }
//!
//! async fn handler_with_one_extractor(input: Input, ext: Extension<State>) -> Output {
//!     todo!()
//! }
//!
//! async fn handler_with_two_extractors(
//!     input: Input,
//!     ext0: Extension<State>,
//!     ext1: ConnectInfo<SocketAddr>,
//! ) -> Output {
//!     todo!()
//! }
//! ```
//!
//! See the [`operation module`](crate::operation) for information on precisely what constitutes a handler.
//!
//! ## Build
//!
//! You can convert [`SampleServiceBuilder`] into [`SampleService`] using either [`SampleServiceBuilder::build`] or [`SampleServiceBuilder::build_unchecked`].
//!
//! [`SampleServiceBuilder::build`] requires you to provide a handler for every single operation in your Smithy model. It will return an error if that is not the case.
//!
//! [`SampleServiceBuilder::build_unchecked`], instead, does not require exhaustiveness. The server will automatically return 500 Internal Server Error to all requests for operations that do not have a registered handler.
//! [`SampleServiceBuilder::build_unchecked`] is particularly useful if you are deploying your Smithy service as a collection of Lambda functions, where each Lambda is only responsible for a subset of the operations in the Smithy service (or even a single one!).
//!
//! # Example
//!
//! ```rust,no_run
//! # use std::net::SocketAddr;
//! use sdk::{SampleService, SampleServiceConfig};
//!
//! #[::tokio::main]
//! pub async fn main() {
//!    let config = SampleServiceConfig::builder().build();
//!    let app = SampleService::builder(config)
//!        .sample_operation(sample_operation)
//!        .build()
//!        .expect("failed to build an instance of SampleService");
//!
//!    let bind: SocketAddr = "127.0.0.1:6969".parse()
//!        .expect("unable to parse the server bind address and port");
//!    let server = ::hyper::Server::bind(&bind).serve(app.into_make_service());
//!    # let server = async { Ok::<_, ()>(()) };
//!
//!    // Run your service!
//!    if let Err(err) = server.await {
//!        eprintln!("server error: {:?}", err);
//!    }
//! }
//!
//! use sdk::{input, output, error};
//!
//! async fn sample_operation(input: input::SampleOperationInput) -> Result<output::SampleOperationOutput, error::SampleOperationError> {
//!     todo!()
//! }
//!
//! ```
//!
//! [`serve`]: https://docs.rs/hyper/0.14.16/hyper/server/struct.Builder.html#method.serve
//! [`tower::make::MakeService`]: https://docs.rs/tower/latest/tower/make/trait.MakeService.html
//! [HTTP binding traits]: https://smithy.io/2.0/spec/http-bindings.html
//! [operations]: https://smithy.io/2.0/spec/service-types.html#operation
//! [hyper server]: https://docs.rs/hyper/latest/hyper/server/index.html
//! [Service]: https://docs.rs/tower-service/latest/tower_service/trait.Service.html
pub use crate::service::{
    MissingOperationsError, SampleService, SampleServiceBuilder, SampleServiceConfig,
    SampleServiceConfigBuilder,
};

/// Contains the types that are re-exported from the `aws-smithy-http-server` crate.
pub mod server {
    // Re-export all types from the `aws-smithy-http-server` crate.
    pub use ::aws_smithy_http_server::*;
}

/// Crate version number.
pub static PKG_VERSION: &str = env!("CARGO_PKG_VERSION");

/// All error types that operations can return. Documentation on these types is copied from the model.
pub mod error;

/// Input structures for operations. Documentation on these types is copied from the model.
pub mod input;

/// Data structures used by operation inputs/outputs. Documentation on these types is copied from the model.
pub mod model;

/// All operations that this crate can perform.
pub mod operation;

/// A collection of types representing each operation defined in the service closure.
///
/// The [plugin system](::aws_smithy_http_server::plugin) makes use of these
/// [zero-sized types](https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts) (ZSTs) to
/// parameterize [`Plugin`](::aws_smithy_http_server::plugin::Plugin) implementations. Their traits, such as
/// [`OperationShape`](::aws_smithy_http_server::operation::OperationShape), can be used to provide
/// operation specific information to the [`Layer`](::tower::Layer) being applied.
pub mod operation_shape;

/// Output structures for operations. Documentation on these types is copied from the model.
pub mod output;

mod service;

/// Data primitives referenced by other data types.
pub mod types;

/// Constrained types for constrained shapes.
mod constrained;

pub(crate) mod protocol_serde;
