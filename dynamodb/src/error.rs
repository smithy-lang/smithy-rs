// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use crate::model::CancellationReason;
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum BatchExecuteStatementError {
    InternalServerError(InternalServerError),
    RequestLimitExceeded(RequestLimitExceeded),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for BatchExecuteStatementError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            BatchExecuteStatementError::InternalServerError(_inner) => _inner.fmt(f),
            BatchExecuteStatementError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            BatchExecuteStatementError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl BatchExecuteStatementError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        BatchExecuteStatementError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            BatchExecuteStatementError::InternalServerError(_inner) => _inner.message(),
            BatchExecuteStatementError::RequestLimitExceeded(_inner) => _inner.message(),
            BatchExecuteStatementError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            BatchExecuteStatementError::InternalServerError(_inner) => Some(_inner.code()),
            BatchExecuteStatementError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            BatchExecuteStatementError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for BatchExecuteStatementError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            BatchExecuteStatementError::InternalServerError(_inner) => Some(_inner),
            BatchExecuteStatementError::RequestLimitExceeded(_inner) => Some(_inner),
            BatchExecuteStatementError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum BatchGetItemError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for BatchGetItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            BatchGetItemError::InternalServerError(_inner) => _inner.fmt(f),
            BatchGetItemError::InvalidEndpointError(_inner) => _inner.fmt(f),
            BatchGetItemError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            BatchGetItemError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            BatchGetItemError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            BatchGetItemError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl BatchGetItemError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        BatchGetItemError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            BatchGetItemError::InternalServerError(_inner) => _inner.message(),
            BatchGetItemError::InvalidEndpointError(_inner) => _inner.message(),
            BatchGetItemError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            BatchGetItemError::RequestLimitExceeded(_inner) => _inner.message(),
            BatchGetItemError::ResourceNotFoundError(_inner) => _inner.message(),
            BatchGetItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            BatchGetItemError::InternalServerError(_inner) => Some(_inner.code()),
            BatchGetItemError::InvalidEndpointError(_inner) => Some(_inner.code()),
            BatchGetItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            BatchGetItemError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            BatchGetItemError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            BatchGetItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for BatchGetItemError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            BatchGetItemError::InternalServerError(_inner) => Some(_inner),
            BatchGetItemError::InvalidEndpointError(_inner) => Some(_inner),
            BatchGetItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            BatchGetItemError::RequestLimitExceeded(_inner) => Some(_inner),
            BatchGetItemError::ResourceNotFoundError(_inner) => Some(_inner),
            BatchGetItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum BatchWriteItemError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ItemCollectionSizeLimitExceededError(ItemCollectionSizeLimitExceededError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for BatchWriteItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            BatchWriteItemError::InternalServerError(_inner) => _inner.fmt(f),
            BatchWriteItemError::InvalidEndpointError(_inner) => _inner.fmt(f),
            BatchWriteItemError::ItemCollectionSizeLimitExceededError(_inner) => _inner.fmt(f),
            BatchWriteItemError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            BatchWriteItemError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            BatchWriteItemError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            BatchWriteItemError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl BatchWriteItemError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        BatchWriteItemError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            BatchWriteItemError::InternalServerError(_inner) => _inner.message(),
            BatchWriteItemError::InvalidEndpointError(_inner) => _inner.message(),
            BatchWriteItemError::ItemCollectionSizeLimitExceededError(_inner) => _inner.message(),
            BatchWriteItemError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            BatchWriteItemError::RequestLimitExceeded(_inner) => _inner.message(),
            BatchWriteItemError::ResourceNotFoundError(_inner) => _inner.message(),
            BatchWriteItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            BatchWriteItemError::InternalServerError(_inner) => Some(_inner.code()),
            BatchWriteItemError::InvalidEndpointError(_inner) => Some(_inner.code()),
            BatchWriteItemError::ItemCollectionSizeLimitExceededError(_inner) => {
                Some(_inner.code())
            }
            BatchWriteItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            BatchWriteItemError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            BatchWriteItemError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            BatchWriteItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for BatchWriteItemError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            BatchWriteItemError::InternalServerError(_inner) => Some(_inner),
            BatchWriteItemError::InvalidEndpointError(_inner) => Some(_inner),
            BatchWriteItemError::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner),
            BatchWriteItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            BatchWriteItemError::RequestLimitExceeded(_inner) => Some(_inner),
            BatchWriteItemError::ResourceNotFoundError(_inner) => Some(_inner),
            BatchWriteItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateBackupError {
    BackupInUseError(BackupInUseError),
    ContinuousBackupsUnavailableError(ContinuousBackupsUnavailableError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    TableInUseError(TableInUseError),
    TableNotFoundError(TableNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for CreateBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CreateBackupError::BackupInUseError(_inner) => _inner.fmt(f),
            CreateBackupError::ContinuousBackupsUnavailableError(_inner) => _inner.fmt(f),
            CreateBackupError::InternalServerError(_inner) => _inner.fmt(f),
            CreateBackupError::InvalidEndpointError(_inner) => _inner.fmt(f),
            CreateBackupError::LimitExceededError(_inner) => _inner.fmt(f),
            CreateBackupError::TableInUseError(_inner) => _inner.fmt(f),
            CreateBackupError::TableNotFoundError(_inner) => _inner.fmt(f),
            CreateBackupError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl CreateBackupError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        CreateBackupError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            CreateBackupError::BackupInUseError(_inner) => _inner.message(),
            CreateBackupError::ContinuousBackupsUnavailableError(_inner) => _inner.message(),
            CreateBackupError::InternalServerError(_inner) => _inner.message(),
            CreateBackupError::InvalidEndpointError(_inner) => _inner.message(),
            CreateBackupError::LimitExceededError(_inner) => _inner.message(),
            CreateBackupError::TableInUseError(_inner) => _inner.message(),
            CreateBackupError::TableNotFoundError(_inner) => _inner.message(),
            CreateBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            CreateBackupError::BackupInUseError(_inner) => Some(_inner.code()),
            CreateBackupError::ContinuousBackupsUnavailableError(_inner) => Some(_inner.code()),
            CreateBackupError::InternalServerError(_inner) => Some(_inner.code()),
            CreateBackupError::InvalidEndpointError(_inner) => Some(_inner.code()),
            CreateBackupError::LimitExceededError(_inner) => Some(_inner.code()),
            CreateBackupError::TableInUseError(_inner) => Some(_inner.code()),
            CreateBackupError::TableNotFoundError(_inner) => Some(_inner.code()),
            CreateBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for CreateBackupError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            CreateBackupError::BackupInUseError(_inner) => Some(_inner),
            CreateBackupError::ContinuousBackupsUnavailableError(_inner) => Some(_inner),
            CreateBackupError::InternalServerError(_inner) => Some(_inner),
            CreateBackupError::InvalidEndpointError(_inner) => Some(_inner),
            CreateBackupError::LimitExceededError(_inner) => Some(_inner),
            CreateBackupError::TableInUseError(_inner) => Some(_inner),
            CreateBackupError::TableNotFoundError(_inner) => Some(_inner),
            CreateBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateGlobalTableError {
    GlobalTableAlreadyExistsError(GlobalTableAlreadyExistsError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    TableNotFoundError(TableNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for CreateGlobalTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CreateGlobalTableError::GlobalTableAlreadyExistsError(_inner) => _inner.fmt(f),
            CreateGlobalTableError::InternalServerError(_inner) => _inner.fmt(f),
            CreateGlobalTableError::InvalidEndpointError(_inner) => _inner.fmt(f),
            CreateGlobalTableError::LimitExceededError(_inner) => _inner.fmt(f),
            CreateGlobalTableError::TableNotFoundError(_inner) => _inner.fmt(f),
            CreateGlobalTableError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl CreateGlobalTableError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        CreateGlobalTableError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            CreateGlobalTableError::GlobalTableAlreadyExistsError(_inner) => _inner.message(),
            CreateGlobalTableError::InternalServerError(_inner) => _inner.message(),
            CreateGlobalTableError::InvalidEndpointError(_inner) => _inner.message(),
            CreateGlobalTableError::LimitExceededError(_inner) => _inner.message(),
            CreateGlobalTableError::TableNotFoundError(_inner) => _inner.message(),
            CreateGlobalTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            CreateGlobalTableError::GlobalTableAlreadyExistsError(_inner) => Some(_inner.code()),
            CreateGlobalTableError::InternalServerError(_inner) => Some(_inner.code()),
            CreateGlobalTableError::InvalidEndpointError(_inner) => Some(_inner.code()),
            CreateGlobalTableError::LimitExceededError(_inner) => Some(_inner.code()),
            CreateGlobalTableError::TableNotFoundError(_inner) => Some(_inner.code()),
            CreateGlobalTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for CreateGlobalTableError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            CreateGlobalTableError::GlobalTableAlreadyExistsError(_inner) => Some(_inner),
            CreateGlobalTableError::InternalServerError(_inner) => Some(_inner),
            CreateGlobalTableError::InvalidEndpointError(_inner) => Some(_inner),
            CreateGlobalTableError::LimitExceededError(_inner) => Some(_inner),
            CreateGlobalTableError::TableNotFoundError(_inner) => Some(_inner),
            CreateGlobalTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateTableError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for CreateTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CreateTableError::InternalServerError(_inner) => _inner.fmt(f),
            CreateTableError::InvalidEndpointError(_inner) => _inner.fmt(f),
            CreateTableError::LimitExceededError(_inner) => _inner.fmt(f),
            CreateTableError::ResourceInUseError(_inner) => _inner.fmt(f),
            CreateTableError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl CreateTableError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        CreateTableError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            CreateTableError::InternalServerError(_inner) => _inner.message(),
            CreateTableError::InvalidEndpointError(_inner) => _inner.message(),
            CreateTableError::LimitExceededError(_inner) => _inner.message(),
            CreateTableError::ResourceInUseError(_inner) => _inner.message(),
            CreateTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            CreateTableError::InternalServerError(_inner) => Some(_inner.code()),
            CreateTableError::InvalidEndpointError(_inner) => Some(_inner.code()),
            CreateTableError::LimitExceededError(_inner) => Some(_inner.code()),
            CreateTableError::ResourceInUseError(_inner) => Some(_inner.code()),
            CreateTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for CreateTableError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            CreateTableError::InternalServerError(_inner) => Some(_inner),
            CreateTableError::InvalidEndpointError(_inner) => Some(_inner),
            CreateTableError::LimitExceededError(_inner) => Some(_inner),
            CreateTableError::ResourceInUseError(_inner) => Some(_inner),
            CreateTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DeleteBackupError {
    BackupInUseError(BackupInUseError),
    BackupNotFoundError(BackupNotFoundError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DeleteBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DeleteBackupError::BackupInUseError(_inner) => _inner.fmt(f),
            DeleteBackupError::BackupNotFoundError(_inner) => _inner.fmt(f),
            DeleteBackupError::InternalServerError(_inner) => _inner.fmt(f),
            DeleteBackupError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DeleteBackupError::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteBackupError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DeleteBackupError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DeleteBackupError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DeleteBackupError::BackupInUseError(_inner) => _inner.message(),
            DeleteBackupError::BackupNotFoundError(_inner) => _inner.message(),
            DeleteBackupError::InternalServerError(_inner) => _inner.message(),
            DeleteBackupError::InvalidEndpointError(_inner) => _inner.message(),
            DeleteBackupError::LimitExceededError(_inner) => _inner.message(),
            DeleteBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DeleteBackupError::BackupInUseError(_inner) => Some(_inner.code()),
            DeleteBackupError::BackupNotFoundError(_inner) => Some(_inner.code()),
            DeleteBackupError::InternalServerError(_inner) => Some(_inner.code()),
            DeleteBackupError::InvalidEndpointError(_inner) => Some(_inner.code()),
            DeleteBackupError::LimitExceededError(_inner) => Some(_inner.code()),
            DeleteBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DeleteBackupError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DeleteBackupError::BackupInUseError(_inner) => Some(_inner),
            DeleteBackupError::BackupNotFoundError(_inner) => Some(_inner),
            DeleteBackupError::InternalServerError(_inner) => Some(_inner),
            DeleteBackupError::InvalidEndpointError(_inner) => Some(_inner),
            DeleteBackupError::LimitExceededError(_inner) => Some(_inner),
            DeleteBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DeleteItemError {
    ConditionalCheckFailedError(ConditionalCheckFailedError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ItemCollectionSizeLimitExceededError(ItemCollectionSizeLimitExceededError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),
    TransactionConflictError(TransactionConflictError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DeleteItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DeleteItemError::ConditionalCheckFailedError(_inner) => _inner.fmt(f),
            DeleteItemError::InternalServerError(_inner) => _inner.fmt(f),
            DeleteItemError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DeleteItemError::ItemCollectionSizeLimitExceededError(_inner) => _inner.fmt(f),
            DeleteItemError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            DeleteItemError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            DeleteItemError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteItemError::TransactionConflictError(_inner) => _inner.fmt(f),
            DeleteItemError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DeleteItemError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DeleteItemError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DeleteItemError::ConditionalCheckFailedError(_inner) => _inner.message(),
            DeleteItemError::InternalServerError(_inner) => _inner.message(),
            DeleteItemError::InvalidEndpointError(_inner) => _inner.message(),
            DeleteItemError::ItemCollectionSizeLimitExceededError(_inner) => _inner.message(),
            DeleteItemError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            DeleteItemError::RequestLimitExceeded(_inner) => _inner.message(),
            DeleteItemError::ResourceNotFoundError(_inner) => _inner.message(),
            DeleteItemError::TransactionConflictError(_inner) => _inner.message(),
            DeleteItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DeleteItemError::ConditionalCheckFailedError(_inner) => Some(_inner.code()),
            DeleteItemError::InternalServerError(_inner) => Some(_inner.code()),
            DeleteItemError::InvalidEndpointError(_inner) => Some(_inner.code()),
            DeleteItemError::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner.code()),
            DeleteItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            DeleteItemError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            DeleteItemError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DeleteItemError::TransactionConflictError(_inner) => Some(_inner.code()),
            DeleteItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DeleteItemError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DeleteItemError::ConditionalCheckFailedError(_inner) => Some(_inner),
            DeleteItemError::InternalServerError(_inner) => Some(_inner),
            DeleteItemError::InvalidEndpointError(_inner) => Some(_inner),
            DeleteItemError::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner),
            DeleteItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            DeleteItemError::RequestLimitExceeded(_inner) => Some(_inner),
            DeleteItemError::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteItemError::TransactionConflictError(_inner) => Some(_inner),
            DeleteItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DeleteTableError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DeleteTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DeleteTableError::InternalServerError(_inner) => _inner.fmt(f),
            DeleteTableError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DeleteTableError::LimitExceededError(_inner) => _inner.fmt(f),
            DeleteTableError::ResourceInUseError(_inner) => _inner.fmt(f),
            DeleteTableError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DeleteTableError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DeleteTableError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DeleteTableError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DeleteTableError::InternalServerError(_inner) => _inner.message(),
            DeleteTableError::InvalidEndpointError(_inner) => _inner.message(),
            DeleteTableError::LimitExceededError(_inner) => _inner.message(),
            DeleteTableError::ResourceInUseError(_inner) => _inner.message(),
            DeleteTableError::ResourceNotFoundError(_inner) => _inner.message(),
            DeleteTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DeleteTableError::InternalServerError(_inner) => Some(_inner.code()),
            DeleteTableError::InvalidEndpointError(_inner) => Some(_inner.code()),
            DeleteTableError::LimitExceededError(_inner) => Some(_inner.code()),
            DeleteTableError::ResourceInUseError(_inner) => Some(_inner.code()),
            DeleteTableError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DeleteTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DeleteTableError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DeleteTableError::InternalServerError(_inner) => Some(_inner),
            DeleteTableError::InvalidEndpointError(_inner) => Some(_inner),
            DeleteTableError::LimitExceededError(_inner) => Some(_inner),
            DeleteTableError::ResourceInUseError(_inner) => Some(_inner),
            DeleteTableError::ResourceNotFoundError(_inner) => Some(_inner),
            DeleteTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeBackupError {
    BackupNotFoundError(BackupNotFoundError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeBackupError::BackupNotFoundError(_inner) => _inner.fmt(f),
            DescribeBackupError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeBackupError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeBackupError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeBackupError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeBackupError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeBackupError::BackupNotFoundError(_inner) => _inner.message(),
            DescribeBackupError::InternalServerError(_inner) => _inner.message(),
            DescribeBackupError::InvalidEndpointError(_inner) => _inner.message(),
            DescribeBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeBackupError::BackupNotFoundError(_inner) => Some(_inner.code()),
            DescribeBackupError::InternalServerError(_inner) => Some(_inner.code()),
            DescribeBackupError::InvalidEndpointError(_inner) => Some(_inner.code()),
            DescribeBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeBackupError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeBackupError::BackupNotFoundError(_inner) => Some(_inner),
            DescribeBackupError::InternalServerError(_inner) => Some(_inner),
            DescribeBackupError::InvalidEndpointError(_inner) => Some(_inner),
            DescribeBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeContinuousBackupsError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    TableNotFoundError(TableNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeContinuousBackupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeContinuousBackupsError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeContinuousBackupsError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeContinuousBackupsError::TableNotFoundError(_inner) => _inner.fmt(f),
            DescribeContinuousBackupsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeContinuousBackupsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeContinuousBackupsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeContinuousBackupsError::InternalServerError(_inner) => _inner.message(),
            DescribeContinuousBackupsError::InvalidEndpointError(_inner) => _inner.message(),
            DescribeContinuousBackupsError::TableNotFoundError(_inner) => _inner.message(),
            DescribeContinuousBackupsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeContinuousBackupsError::InternalServerError(_inner) => Some(_inner.code()),
            DescribeContinuousBackupsError::InvalidEndpointError(_inner) => Some(_inner.code()),
            DescribeContinuousBackupsError::TableNotFoundError(_inner) => Some(_inner.code()),
            DescribeContinuousBackupsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeContinuousBackupsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeContinuousBackupsError::InternalServerError(_inner) => Some(_inner),
            DescribeContinuousBackupsError::InvalidEndpointError(_inner) => Some(_inner),
            DescribeContinuousBackupsError::TableNotFoundError(_inner) => Some(_inner),
            DescribeContinuousBackupsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeContributorInsightsError {
    InternalServerError(InternalServerError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeContributorInsightsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeContributorInsightsError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeContributorInsightsError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeContributorInsightsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeContributorInsightsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeContributorInsightsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeContributorInsightsError::InternalServerError(_inner) => _inner.message(),
            DescribeContributorInsightsError::ResourceNotFoundError(_inner) => _inner.message(),
            DescribeContributorInsightsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeContributorInsightsError::InternalServerError(_inner) => Some(_inner.code()),
            DescribeContributorInsightsError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DescribeContributorInsightsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeContributorInsightsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeContributorInsightsError::InternalServerError(_inner) => Some(_inner),
            DescribeContributorInsightsError::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeContributorInsightsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeEndpointsError {
    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeEndpointsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeEndpointsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeEndpointsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeEndpointsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeEndpointsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeEndpointsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeEndpointsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeEndpointsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeExportError {
    ExportNotFoundError(ExportNotFoundError),
    InternalServerError(InternalServerError),
    LimitExceededError(LimitExceededError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeExportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeExportError::ExportNotFoundError(_inner) => _inner.fmt(f),
            DescribeExportError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeExportError::LimitExceededError(_inner) => _inner.fmt(f),
            DescribeExportError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeExportError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeExportError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeExportError::ExportNotFoundError(_inner) => _inner.message(),
            DescribeExportError::InternalServerError(_inner) => _inner.message(),
            DescribeExportError::LimitExceededError(_inner) => _inner.message(),
            DescribeExportError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeExportError::ExportNotFoundError(_inner) => Some(_inner.code()),
            DescribeExportError::InternalServerError(_inner) => Some(_inner.code()),
            DescribeExportError::LimitExceededError(_inner) => Some(_inner.code()),
            DescribeExportError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeExportError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeExportError::ExportNotFoundError(_inner) => Some(_inner),
            DescribeExportError::InternalServerError(_inner) => Some(_inner),
            DescribeExportError::LimitExceededError(_inner) => Some(_inner),
            DescribeExportError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeGlobalTableError {
    GlobalTableNotFoundError(GlobalTableNotFoundError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeGlobalTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeGlobalTableError::GlobalTableNotFoundError(_inner) => _inner.fmt(f),
            DescribeGlobalTableError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeGlobalTableError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeGlobalTableError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeGlobalTableError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeGlobalTableError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeGlobalTableError::GlobalTableNotFoundError(_inner) => _inner.message(),
            DescribeGlobalTableError::InternalServerError(_inner) => _inner.message(),
            DescribeGlobalTableError::InvalidEndpointError(_inner) => _inner.message(),
            DescribeGlobalTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeGlobalTableError::GlobalTableNotFoundError(_inner) => Some(_inner.code()),
            DescribeGlobalTableError::InternalServerError(_inner) => Some(_inner.code()),
            DescribeGlobalTableError::InvalidEndpointError(_inner) => Some(_inner.code()),
            DescribeGlobalTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeGlobalTableError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeGlobalTableError::GlobalTableNotFoundError(_inner) => Some(_inner),
            DescribeGlobalTableError::InternalServerError(_inner) => Some(_inner),
            DescribeGlobalTableError::InvalidEndpointError(_inner) => Some(_inner),
            DescribeGlobalTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeGlobalTableSettingsError {
    GlobalTableNotFoundError(GlobalTableNotFoundError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeGlobalTableSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeGlobalTableSettingsError::GlobalTableNotFoundError(_inner) => _inner.fmt(f),
            DescribeGlobalTableSettingsError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeGlobalTableSettingsError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeGlobalTableSettingsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeGlobalTableSettingsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeGlobalTableSettingsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeGlobalTableSettingsError::GlobalTableNotFoundError(_inner) => _inner.message(),
            DescribeGlobalTableSettingsError::InternalServerError(_inner) => _inner.message(),
            DescribeGlobalTableSettingsError::InvalidEndpointError(_inner) => _inner.message(),
            DescribeGlobalTableSettingsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeGlobalTableSettingsError::GlobalTableNotFoundError(_inner) => {
                Some(_inner.code())
            }
            DescribeGlobalTableSettingsError::InternalServerError(_inner) => Some(_inner.code()),
            DescribeGlobalTableSettingsError::InvalidEndpointError(_inner) => Some(_inner.code()),
            DescribeGlobalTableSettingsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeGlobalTableSettingsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeGlobalTableSettingsError::GlobalTableNotFoundError(_inner) => Some(_inner),
            DescribeGlobalTableSettingsError::InternalServerError(_inner) => Some(_inner),
            DescribeGlobalTableSettingsError::InvalidEndpointError(_inner) => Some(_inner),
            DescribeGlobalTableSettingsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeKinesisStreamingDestinationError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeKinesisStreamingDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeKinesisStreamingDestinationError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeKinesisStreamingDestinationError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => {
                _inner.fmt(f)
            }
            DescribeKinesisStreamingDestinationError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeKinesisStreamingDestinationError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeKinesisStreamingDestinationError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeKinesisStreamingDestinationError::InternalServerError(_inner) => {
                _inner.message()
            }
            DescribeKinesisStreamingDestinationError::InvalidEndpointError(_inner) => {
                _inner.message()
            }
            DescribeKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => {
                _inner.message()
            }
            DescribeKinesisStreamingDestinationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeKinesisStreamingDestinationError::InternalServerError(_inner) => {
                Some(_inner.code())
            }
            DescribeKinesisStreamingDestinationError::InvalidEndpointError(_inner) => {
                Some(_inner.code())
            }
            DescribeKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => {
                Some(_inner.code())
            }
            DescribeKinesisStreamingDestinationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeKinesisStreamingDestinationError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeKinesisStreamingDestinationError::InternalServerError(_inner) => Some(_inner),
            DescribeKinesisStreamingDestinationError::InvalidEndpointError(_inner) => Some(_inner),
            DescribeKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeKinesisStreamingDestinationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeLimitsError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeLimitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeLimitsError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeLimitsError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeLimitsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeLimitsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeLimitsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeLimitsError::InternalServerError(_inner) => _inner.message(),
            DescribeLimitsError::InvalidEndpointError(_inner) => _inner.message(),
            DescribeLimitsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeLimitsError::InternalServerError(_inner) => Some(_inner.code()),
            DescribeLimitsError::InvalidEndpointError(_inner) => Some(_inner.code()),
            DescribeLimitsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeLimitsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeLimitsError::InternalServerError(_inner) => Some(_inner),
            DescribeLimitsError::InvalidEndpointError(_inner) => Some(_inner),
            DescribeLimitsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeTableError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeTableError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeTableError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeTableError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeTableError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeTableError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeTableError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeTableError::InternalServerError(_inner) => _inner.message(),
            DescribeTableError::InvalidEndpointError(_inner) => _inner.message(),
            DescribeTableError::ResourceNotFoundError(_inner) => _inner.message(),
            DescribeTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeTableError::InternalServerError(_inner) => Some(_inner.code()),
            DescribeTableError::InvalidEndpointError(_inner) => Some(_inner.code()),
            DescribeTableError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DescribeTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeTableError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeTableError::InternalServerError(_inner) => Some(_inner),
            DescribeTableError::InvalidEndpointError(_inner) => Some(_inner),
            DescribeTableError::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeTableReplicaAutoScalingError {
    InternalServerError(InternalServerError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeTableReplicaAutoScalingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeTableReplicaAutoScalingError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeTableReplicaAutoScalingError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeTableReplicaAutoScalingError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeTableReplicaAutoScalingError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeTableReplicaAutoScalingError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeTableReplicaAutoScalingError::InternalServerError(_inner) => _inner.message(),
            DescribeTableReplicaAutoScalingError::ResourceNotFoundError(_inner) => _inner.message(),
            DescribeTableReplicaAutoScalingError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeTableReplicaAutoScalingError::InternalServerError(_inner) => {
                Some(_inner.code())
            }
            DescribeTableReplicaAutoScalingError::ResourceNotFoundError(_inner) => {
                Some(_inner.code())
            }
            DescribeTableReplicaAutoScalingError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeTableReplicaAutoScalingError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeTableReplicaAutoScalingError::InternalServerError(_inner) => Some(_inner),
            DescribeTableReplicaAutoScalingError::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeTableReplicaAutoScalingError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DescribeTimeToLiveError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DescribeTimeToLiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DescribeTimeToLiveError::InternalServerError(_inner) => _inner.fmt(f),
            DescribeTimeToLiveError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DescribeTimeToLiveError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DescribeTimeToLiveError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DescribeTimeToLiveError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DescribeTimeToLiveError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DescribeTimeToLiveError::InternalServerError(_inner) => _inner.message(),
            DescribeTimeToLiveError::InvalidEndpointError(_inner) => _inner.message(),
            DescribeTimeToLiveError::ResourceNotFoundError(_inner) => _inner.message(),
            DescribeTimeToLiveError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DescribeTimeToLiveError::InternalServerError(_inner) => Some(_inner.code()),
            DescribeTimeToLiveError::InvalidEndpointError(_inner) => Some(_inner.code()),
            DescribeTimeToLiveError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            DescribeTimeToLiveError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DescribeTimeToLiveError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DescribeTimeToLiveError::InternalServerError(_inner) => Some(_inner),
            DescribeTimeToLiveError::InvalidEndpointError(_inner) => Some(_inner),
            DescribeTimeToLiveError::ResourceNotFoundError(_inner) => Some(_inner),
            DescribeTimeToLiveError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum DisableKinesisStreamingDestinationError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for DisableKinesisStreamingDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DisableKinesisStreamingDestinationError::InternalServerError(_inner) => _inner.fmt(f),
            DisableKinesisStreamingDestinationError::InvalidEndpointError(_inner) => _inner.fmt(f),
            DisableKinesisStreamingDestinationError::LimitExceededError(_inner) => _inner.fmt(f),
            DisableKinesisStreamingDestinationError::ResourceInUseError(_inner) => _inner.fmt(f),
            DisableKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            DisableKinesisStreamingDestinationError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl DisableKinesisStreamingDestinationError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        DisableKinesisStreamingDestinationError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            DisableKinesisStreamingDestinationError::InternalServerError(_inner) => {
                _inner.message()
            }
            DisableKinesisStreamingDestinationError::InvalidEndpointError(_inner) => {
                _inner.message()
            }
            DisableKinesisStreamingDestinationError::LimitExceededError(_inner) => _inner.message(),
            DisableKinesisStreamingDestinationError::ResourceInUseError(_inner) => _inner.message(),
            DisableKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => {
                _inner.message()
            }
            DisableKinesisStreamingDestinationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            DisableKinesisStreamingDestinationError::InternalServerError(_inner) => {
                Some(_inner.code())
            }
            DisableKinesisStreamingDestinationError::InvalidEndpointError(_inner) => {
                Some(_inner.code())
            }
            DisableKinesisStreamingDestinationError::LimitExceededError(_inner) => {
                Some(_inner.code())
            }
            DisableKinesisStreamingDestinationError::ResourceInUseError(_inner) => {
                Some(_inner.code())
            }
            DisableKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => {
                Some(_inner.code())
            }
            DisableKinesisStreamingDestinationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for DisableKinesisStreamingDestinationError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            DisableKinesisStreamingDestinationError::InternalServerError(_inner) => Some(_inner),
            DisableKinesisStreamingDestinationError::InvalidEndpointError(_inner) => Some(_inner),
            DisableKinesisStreamingDestinationError::LimitExceededError(_inner) => Some(_inner),
            DisableKinesisStreamingDestinationError::ResourceInUseError(_inner) => Some(_inner),
            DisableKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => Some(_inner),
            DisableKinesisStreamingDestinationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum EnableKinesisStreamingDestinationError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for EnableKinesisStreamingDestinationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EnableKinesisStreamingDestinationError::InternalServerError(_inner) => _inner.fmt(f),
            EnableKinesisStreamingDestinationError::InvalidEndpointError(_inner) => _inner.fmt(f),
            EnableKinesisStreamingDestinationError::LimitExceededError(_inner) => _inner.fmt(f),
            EnableKinesisStreamingDestinationError::ResourceInUseError(_inner) => _inner.fmt(f),
            EnableKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            EnableKinesisStreamingDestinationError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl EnableKinesisStreamingDestinationError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        EnableKinesisStreamingDestinationError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            EnableKinesisStreamingDestinationError::InternalServerError(_inner) => _inner.message(),
            EnableKinesisStreamingDestinationError::InvalidEndpointError(_inner) => {
                _inner.message()
            }
            EnableKinesisStreamingDestinationError::LimitExceededError(_inner) => _inner.message(),
            EnableKinesisStreamingDestinationError::ResourceInUseError(_inner) => _inner.message(),
            EnableKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => {
                _inner.message()
            }
            EnableKinesisStreamingDestinationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            EnableKinesisStreamingDestinationError::InternalServerError(_inner) => {
                Some(_inner.code())
            }
            EnableKinesisStreamingDestinationError::InvalidEndpointError(_inner) => {
                Some(_inner.code())
            }
            EnableKinesisStreamingDestinationError::LimitExceededError(_inner) => {
                Some(_inner.code())
            }
            EnableKinesisStreamingDestinationError::ResourceInUseError(_inner) => {
                Some(_inner.code())
            }
            EnableKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => {
                Some(_inner.code())
            }
            EnableKinesisStreamingDestinationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for EnableKinesisStreamingDestinationError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            EnableKinesisStreamingDestinationError::InternalServerError(_inner) => Some(_inner),
            EnableKinesisStreamingDestinationError::InvalidEndpointError(_inner) => Some(_inner),
            EnableKinesisStreamingDestinationError::LimitExceededError(_inner) => Some(_inner),
            EnableKinesisStreamingDestinationError::ResourceInUseError(_inner) => Some(_inner),
            EnableKinesisStreamingDestinationError::ResourceNotFoundError(_inner) => Some(_inner),
            EnableKinesisStreamingDestinationError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ExecuteStatementError {
    ConditionalCheckFailedError(ConditionalCheckFailedError),
    DuplicateItemError(DuplicateItemError),
    InternalServerError(InternalServerError),
    ItemCollectionSizeLimitExceededError(ItemCollectionSizeLimitExceededError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),
    TransactionConflictError(TransactionConflictError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ExecuteStatementError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ExecuteStatementError::ConditionalCheckFailedError(_inner) => _inner.fmt(f),
            ExecuteStatementError::DuplicateItemError(_inner) => _inner.fmt(f),
            ExecuteStatementError::InternalServerError(_inner) => _inner.fmt(f),
            ExecuteStatementError::ItemCollectionSizeLimitExceededError(_inner) => _inner.fmt(f),
            ExecuteStatementError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            ExecuteStatementError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            ExecuteStatementError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ExecuteStatementError::TransactionConflictError(_inner) => _inner.fmt(f),
            ExecuteStatementError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ExecuteStatementError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ExecuteStatementError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ExecuteStatementError::ConditionalCheckFailedError(_inner) => _inner.message(),
            ExecuteStatementError::DuplicateItemError(_inner) => _inner.message(),
            ExecuteStatementError::InternalServerError(_inner) => _inner.message(),
            ExecuteStatementError::ItemCollectionSizeLimitExceededError(_inner) => _inner.message(),
            ExecuteStatementError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            ExecuteStatementError::RequestLimitExceeded(_inner) => _inner.message(),
            ExecuteStatementError::ResourceNotFoundError(_inner) => _inner.message(),
            ExecuteStatementError::TransactionConflictError(_inner) => _inner.message(),
            ExecuteStatementError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ExecuteStatementError::ConditionalCheckFailedError(_inner) => Some(_inner.code()),
            ExecuteStatementError::DuplicateItemError(_inner) => Some(_inner.code()),
            ExecuteStatementError::InternalServerError(_inner) => Some(_inner.code()),
            ExecuteStatementError::ItemCollectionSizeLimitExceededError(_inner) => {
                Some(_inner.code())
            }
            ExecuteStatementError::ProvisionedThroughputExceededError(_inner) => {
                Some(_inner.code())
            }
            ExecuteStatementError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            ExecuteStatementError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            ExecuteStatementError::TransactionConflictError(_inner) => Some(_inner.code()),
            ExecuteStatementError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ExecuteStatementError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ExecuteStatementError::ConditionalCheckFailedError(_inner) => Some(_inner),
            ExecuteStatementError::DuplicateItemError(_inner) => Some(_inner),
            ExecuteStatementError::InternalServerError(_inner) => Some(_inner),
            ExecuteStatementError::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner),
            ExecuteStatementError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            ExecuteStatementError::RequestLimitExceeded(_inner) => Some(_inner),
            ExecuteStatementError::ResourceNotFoundError(_inner) => Some(_inner),
            ExecuteStatementError::TransactionConflictError(_inner) => Some(_inner),
            ExecuteStatementError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ExecuteTransactionError {
    IdempotentParameterMismatchError(IdempotentParameterMismatchError),
    InternalServerError(InternalServerError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),
    TransactionCanceledError(TransactionCanceledError),
    TransactionInProgressError(TransactionInProgressError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ExecuteTransactionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ExecuteTransactionError::IdempotentParameterMismatchError(_inner) => _inner.fmt(f),
            ExecuteTransactionError::InternalServerError(_inner) => _inner.fmt(f),
            ExecuteTransactionError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            ExecuteTransactionError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            ExecuteTransactionError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ExecuteTransactionError::TransactionCanceledError(_inner) => _inner.fmt(f),
            ExecuteTransactionError::TransactionInProgressError(_inner) => _inner.fmt(f),
            ExecuteTransactionError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ExecuteTransactionError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ExecuteTransactionError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ExecuteTransactionError::IdempotentParameterMismatchError(_inner) => _inner.message(),
            ExecuteTransactionError::InternalServerError(_inner) => _inner.message(),
            ExecuteTransactionError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            ExecuteTransactionError::RequestLimitExceeded(_inner) => _inner.message(),
            ExecuteTransactionError::ResourceNotFoundError(_inner) => _inner.message(),
            ExecuteTransactionError::TransactionCanceledError(_inner) => _inner.message(),
            ExecuteTransactionError::TransactionInProgressError(_inner) => _inner.message(),
            ExecuteTransactionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ExecuteTransactionError::IdempotentParameterMismatchError(_inner) => {
                Some(_inner.code())
            }
            ExecuteTransactionError::InternalServerError(_inner) => Some(_inner.code()),
            ExecuteTransactionError::ProvisionedThroughputExceededError(_inner) => {
                Some(_inner.code())
            }
            ExecuteTransactionError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            ExecuteTransactionError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            ExecuteTransactionError::TransactionCanceledError(_inner) => Some(_inner.code()),
            ExecuteTransactionError::TransactionInProgressError(_inner) => Some(_inner.code()),
            ExecuteTransactionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ExecuteTransactionError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ExecuteTransactionError::IdempotentParameterMismatchError(_inner) => Some(_inner),
            ExecuteTransactionError::InternalServerError(_inner) => Some(_inner),
            ExecuteTransactionError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            ExecuteTransactionError::RequestLimitExceeded(_inner) => Some(_inner),
            ExecuteTransactionError::ResourceNotFoundError(_inner) => Some(_inner),
            ExecuteTransactionError::TransactionCanceledError(_inner) => Some(_inner),
            ExecuteTransactionError::TransactionInProgressError(_inner) => Some(_inner),
            ExecuteTransactionError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ExportTableToPointInTimeError {
    ExportConflictError(ExportConflictError),
    InternalServerError(InternalServerError),
    InvalidExportTimeError(InvalidExportTimeError),
    LimitExceededError(LimitExceededError),
    PointInTimeRecoveryUnavailableError(PointInTimeRecoveryUnavailableError),
    TableNotFoundError(TableNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ExportTableToPointInTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ExportTableToPointInTimeError::ExportConflictError(_inner) => _inner.fmt(f),
            ExportTableToPointInTimeError::InternalServerError(_inner) => _inner.fmt(f),
            ExportTableToPointInTimeError::InvalidExportTimeError(_inner) => _inner.fmt(f),
            ExportTableToPointInTimeError::LimitExceededError(_inner) => _inner.fmt(f),
            ExportTableToPointInTimeError::PointInTimeRecoveryUnavailableError(_inner) => {
                _inner.fmt(f)
            }
            ExportTableToPointInTimeError::TableNotFoundError(_inner) => _inner.fmt(f),
            ExportTableToPointInTimeError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ExportTableToPointInTimeError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ExportTableToPointInTimeError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ExportTableToPointInTimeError::ExportConflictError(_inner) => _inner.message(),
            ExportTableToPointInTimeError::InternalServerError(_inner) => _inner.message(),
            ExportTableToPointInTimeError::InvalidExportTimeError(_inner) => _inner.message(),
            ExportTableToPointInTimeError::LimitExceededError(_inner) => _inner.message(),
            ExportTableToPointInTimeError::PointInTimeRecoveryUnavailableError(_inner) => {
                _inner.message()
            }
            ExportTableToPointInTimeError::TableNotFoundError(_inner) => _inner.message(),
            ExportTableToPointInTimeError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ExportTableToPointInTimeError::ExportConflictError(_inner) => Some(_inner.code()),
            ExportTableToPointInTimeError::InternalServerError(_inner) => Some(_inner.code()),
            ExportTableToPointInTimeError::InvalidExportTimeError(_inner) => Some(_inner.code()),
            ExportTableToPointInTimeError::LimitExceededError(_inner) => Some(_inner.code()),
            ExportTableToPointInTimeError::PointInTimeRecoveryUnavailableError(_inner) => {
                Some(_inner.code())
            }
            ExportTableToPointInTimeError::TableNotFoundError(_inner) => Some(_inner.code()),
            ExportTableToPointInTimeError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ExportTableToPointInTimeError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ExportTableToPointInTimeError::ExportConflictError(_inner) => Some(_inner),
            ExportTableToPointInTimeError::InternalServerError(_inner) => Some(_inner),
            ExportTableToPointInTimeError::InvalidExportTimeError(_inner) => Some(_inner),
            ExportTableToPointInTimeError::LimitExceededError(_inner) => Some(_inner),
            ExportTableToPointInTimeError::PointInTimeRecoveryUnavailableError(_inner) => {
                Some(_inner)
            }
            ExportTableToPointInTimeError::TableNotFoundError(_inner) => Some(_inner),
            ExportTableToPointInTimeError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum GetItemError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for GetItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GetItemError::InternalServerError(_inner) => _inner.fmt(f),
            GetItemError::InvalidEndpointError(_inner) => _inner.fmt(f),
            GetItemError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            GetItemError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            GetItemError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            GetItemError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl GetItemError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        GetItemError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            GetItemError::InternalServerError(_inner) => _inner.message(),
            GetItemError::InvalidEndpointError(_inner) => _inner.message(),
            GetItemError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            GetItemError::RequestLimitExceeded(_inner) => _inner.message(),
            GetItemError::ResourceNotFoundError(_inner) => _inner.message(),
            GetItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            GetItemError::InternalServerError(_inner) => Some(_inner.code()),
            GetItemError::InvalidEndpointError(_inner) => Some(_inner.code()),
            GetItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            GetItemError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            GetItemError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            GetItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for GetItemError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            GetItemError::InternalServerError(_inner) => Some(_inner),
            GetItemError::InvalidEndpointError(_inner) => Some(_inner),
            GetItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            GetItemError::RequestLimitExceeded(_inner) => Some(_inner),
            GetItemError::ResourceNotFoundError(_inner) => Some(_inner),
            GetItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListBackupsError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListBackupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListBackupsError::InternalServerError(_inner) => _inner.fmt(f),
            ListBackupsError::InvalidEndpointError(_inner) => _inner.fmt(f),
            ListBackupsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ListBackupsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListBackupsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListBackupsError::InternalServerError(_inner) => _inner.message(),
            ListBackupsError::InvalidEndpointError(_inner) => _inner.message(),
            ListBackupsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListBackupsError::InternalServerError(_inner) => Some(_inner.code()),
            ListBackupsError::InvalidEndpointError(_inner) => Some(_inner.code()),
            ListBackupsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListBackupsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListBackupsError::InternalServerError(_inner) => Some(_inner),
            ListBackupsError::InvalidEndpointError(_inner) => Some(_inner),
            ListBackupsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListContributorInsightsError {
    InternalServerError(InternalServerError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListContributorInsightsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListContributorInsightsError::InternalServerError(_inner) => _inner.fmt(f),
            ListContributorInsightsError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListContributorInsightsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ListContributorInsightsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListContributorInsightsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListContributorInsightsError::InternalServerError(_inner) => _inner.message(),
            ListContributorInsightsError::ResourceNotFoundError(_inner) => _inner.message(),
            ListContributorInsightsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListContributorInsightsError::InternalServerError(_inner) => Some(_inner.code()),
            ListContributorInsightsError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            ListContributorInsightsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListContributorInsightsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListContributorInsightsError::InternalServerError(_inner) => Some(_inner),
            ListContributorInsightsError::ResourceNotFoundError(_inner) => Some(_inner),
            ListContributorInsightsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListExportsError {
    InternalServerError(InternalServerError),
    LimitExceededError(LimitExceededError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListExportsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListExportsError::InternalServerError(_inner) => _inner.fmt(f),
            ListExportsError::LimitExceededError(_inner) => _inner.fmt(f),
            ListExportsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ListExportsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListExportsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListExportsError::InternalServerError(_inner) => _inner.message(),
            ListExportsError::LimitExceededError(_inner) => _inner.message(),
            ListExportsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListExportsError::InternalServerError(_inner) => Some(_inner.code()),
            ListExportsError::LimitExceededError(_inner) => Some(_inner.code()),
            ListExportsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListExportsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListExportsError::InternalServerError(_inner) => Some(_inner),
            ListExportsError::LimitExceededError(_inner) => Some(_inner),
            ListExportsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListGlobalTablesError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListGlobalTablesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListGlobalTablesError::InternalServerError(_inner) => _inner.fmt(f),
            ListGlobalTablesError::InvalidEndpointError(_inner) => _inner.fmt(f),
            ListGlobalTablesError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ListGlobalTablesError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListGlobalTablesError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListGlobalTablesError::InternalServerError(_inner) => _inner.message(),
            ListGlobalTablesError::InvalidEndpointError(_inner) => _inner.message(),
            ListGlobalTablesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListGlobalTablesError::InternalServerError(_inner) => Some(_inner.code()),
            ListGlobalTablesError::InvalidEndpointError(_inner) => Some(_inner.code()),
            ListGlobalTablesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListGlobalTablesError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListGlobalTablesError::InternalServerError(_inner) => Some(_inner),
            ListGlobalTablesError::InvalidEndpointError(_inner) => Some(_inner),
            ListGlobalTablesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListTablesError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListTablesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListTablesError::InternalServerError(_inner) => _inner.fmt(f),
            ListTablesError::InvalidEndpointError(_inner) => _inner.fmt(f),
            ListTablesError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ListTablesError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListTablesError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListTablesError::InternalServerError(_inner) => _inner.message(),
            ListTablesError::InvalidEndpointError(_inner) => _inner.message(),
            ListTablesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListTablesError::InternalServerError(_inner) => Some(_inner.code()),
            ListTablesError::InvalidEndpointError(_inner) => Some(_inner.code()),
            ListTablesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListTablesError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListTablesError::InternalServerError(_inner) => Some(_inner),
            ListTablesError::InvalidEndpointError(_inner) => Some(_inner),
            ListTablesError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ListTagsOfResourceError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ListTagsOfResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ListTagsOfResourceError::InternalServerError(_inner) => _inner.fmt(f),
            ListTagsOfResourceError::InvalidEndpointError(_inner) => _inner.fmt(f),
            ListTagsOfResourceError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ListTagsOfResourceError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ListTagsOfResourceError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ListTagsOfResourceError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ListTagsOfResourceError::InternalServerError(_inner) => _inner.message(),
            ListTagsOfResourceError::InvalidEndpointError(_inner) => _inner.message(),
            ListTagsOfResourceError::ResourceNotFoundError(_inner) => _inner.message(),
            ListTagsOfResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ListTagsOfResourceError::InternalServerError(_inner) => Some(_inner.code()),
            ListTagsOfResourceError::InvalidEndpointError(_inner) => Some(_inner.code()),
            ListTagsOfResourceError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            ListTagsOfResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for ListTagsOfResourceError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ListTagsOfResourceError::InternalServerError(_inner) => Some(_inner),
            ListTagsOfResourceError::InvalidEndpointError(_inner) => Some(_inner),
            ListTagsOfResourceError::ResourceNotFoundError(_inner) => Some(_inner),
            ListTagsOfResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum PutItemError {
    ConditionalCheckFailedError(ConditionalCheckFailedError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ItemCollectionSizeLimitExceededError(ItemCollectionSizeLimitExceededError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),
    TransactionConflictError(TransactionConflictError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for PutItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PutItemError::ConditionalCheckFailedError(_inner) => _inner.fmt(f),
            PutItemError::InternalServerError(_inner) => _inner.fmt(f),
            PutItemError::InvalidEndpointError(_inner) => _inner.fmt(f),
            PutItemError::ItemCollectionSizeLimitExceededError(_inner) => _inner.fmt(f),
            PutItemError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            PutItemError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            PutItemError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            PutItemError::TransactionConflictError(_inner) => _inner.fmt(f),
            PutItemError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl PutItemError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        PutItemError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            PutItemError::ConditionalCheckFailedError(_inner) => _inner.message(),
            PutItemError::InternalServerError(_inner) => _inner.message(),
            PutItemError::InvalidEndpointError(_inner) => _inner.message(),
            PutItemError::ItemCollectionSizeLimitExceededError(_inner) => _inner.message(),
            PutItemError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            PutItemError::RequestLimitExceeded(_inner) => _inner.message(),
            PutItemError::ResourceNotFoundError(_inner) => _inner.message(),
            PutItemError::TransactionConflictError(_inner) => _inner.message(),
            PutItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            PutItemError::ConditionalCheckFailedError(_inner) => Some(_inner.code()),
            PutItemError::InternalServerError(_inner) => Some(_inner.code()),
            PutItemError::InvalidEndpointError(_inner) => Some(_inner.code()),
            PutItemError::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner.code()),
            PutItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            PutItemError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            PutItemError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            PutItemError::TransactionConflictError(_inner) => Some(_inner.code()),
            PutItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for PutItemError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            PutItemError::ConditionalCheckFailedError(_inner) => Some(_inner),
            PutItemError::InternalServerError(_inner) => Some(_inner),
            PutItemError::InvalidEndpointError(_inner) => Some(_inner),
            PutItemError::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner),
            PutItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            PutItemError::RequestLimitExceeded(_inner) => Some(_inner),
            PutItemError::ResourceNotFoundError(_inner) => Some(_inner),
            PutItemError::TransactionConflictError(_inner) => Some(_inner),
            PutItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum QueryError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for QueryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            QueryError::InternalServerError(_inner) => _inner.fmt(f),
            QueryError::InvalidEndpointError(_inner) => _inner.fmt(f),
            QueryError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            QueryError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            QueryError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            QueryError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl QueryError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        QueryError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            QueryError::InternalServerError(_inner) => _inner.message(),
            QueryError::InvalidEndpointError(_inner) => _inner.message(),
            QueryError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            QueryError::RequestLimitExceeded(_inner) => _inner.message(),
            QueryError::ResourceNotFoundError(_inner) => _inner.message(),
            QueryError::Unhandled(_inner) => match _inner.downcast_ref::<::smithy_types::Error>() {
                Some(_inner) => _inner.message(),
                None => None,
            },
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            QueryError::InternalServerError(_inner) => Some(_inner.code()),
            QueryError::InvalidEndpointError(_inner) => Some(_inner.code()),
            QueryError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            QueryError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            QueryError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            QueryError::Unhandled(_inner) => match _inner.downcast_ref::<::smithy_types::Error>() {
                Some(_inner) => _inner.code(),
                None => None,
            },
        }
    }
}
impl ::std::error::Error for QueryError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            QueryError::InternalServerError(_inner) => Some(_inner),
            QueryError::InvalidEndpointError(_inner) => Some(_inner),
            QueryError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            QueryError::RequestLimitExceeded(_inner) => Some(_inner),
            QueryError::ResourceNotFoundError(_inner) => Some(_inner),
            QueryError::Unhandled(_inner) => match _inner.downcast_ref::<::smithy_types::Error>() {
                Some(_inner) => Some(_inner),
                None => Some(_inner.as_ref()),
            },
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum RestoreTableFromBackupError {
    BackupInUseError(BackupInUseError),
    BackupNotFoundError(BackupNotFoundError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    TableAlreadyExistsError(TableAlreadyExistsError),
    TableInUseError(TableInUseError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for RestoreTableFromBackupError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RestoreTableFromBackupError::BackupInUseError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupError::BackupNotFoundError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupError::InternalServerError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupError::InvalidEndpointError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupError::LimitExceededError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupError::TableAlreadyExistsError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupError::TableInUseError(_inner) => _inner.fmt(f),
            RestoreTableFromBackupError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl RestoreTableFromBackupError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        RestoreTableFromBackupError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            RestoreTableFromBackupError::BackupInUseError(_inner) => _inner.message(),
            RestoreTableFromBackupError::BackupNotFoundError(_inner) => _inner.message(),
            RestoreTableFromBackupError::InternalServerError(_inner) => _inner.message(),
            RestoreTableFromBackupError::InvalidEndpointError(_inner) => _inner.message(),
            RestoreTableFromBackupError::LimitExceededError(_inner) => _inner.message(),
            RestoreTableFromBackupError::TableAlreadyExistsError(_inner) => _inner.message(),
            RestoreTableFromBackupError::TableInUseError(_inner) => _inner.message(),
            RestoreTableFromBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            RestoreTableFromBackupError::BackupInUseError(_inner) => Some(_inner.code()),
            RestoreTableFromBackupError::BackupNotFoundError(_inner) => Some(_inner.code()),
            RestoreTableFromBackupError::InternalServerError(_inner) => Some(_inner.code()),
            RestoreTableFromBackupError::InvalidEndpointError(_inner) => Some(_inner.code()),
            RestoreTableFromBackupError::LimitExceededError(_inner) => Some(_inner.code()),
            RestoreTableFromBackupError::TableAlreadyExistsError(_inner) => Some(_inner.code()),
            RestoreTableFromBackupError::TableInUseError(_inner) => Some(_inner.code()),
            RestoreTableFromBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for RestoreTableFromBackupError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            RestoreTableFromBackupError::BackupInUseError(_inner) => Some(_inner),
            RestoreTableFromBackupError::BackupNotFoundError(_inner) => Some(_inner),
            RestoreTableFromBackupError::InternalServerError(_inner) => Some(_inner),
            RestoreTableFromBackupError::InvalidEndpointError(_inner) => Some(_inner),
            RestoreTableFromBackupError::LimitExceededError(_inner) => Some(_inner),
            RestoreTableFromBackupError::TableAlreadyExistsError(_inner) => Some(_inner),
            RestoreTableFromBackupError::TableInUseError(_inner) => Some(_inner),
            RestoreTableFromBackupError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum RestoreTableToPointInTimeError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    InvalidRestoreTimeError(InvalidRestoreTimeError),
    LimitExceededError(LimitExceededError),
    PointInTimeRecoveryUnavailableError(PointInTimeRecoveryUnavailableError),
    TableAlreadyExistsError(TableAlreadyExistsError),
    TableInUseError(TableInUseError),
    TableNotFoundError(TableNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for RestoreTableToPointInTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RestoreTableToPointInTimeError::InternalServerError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeError::InvalidEndpointError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeError::InvalidRestoreTimeError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeError::LimitExceededError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeError::PointInTimeRecoveryUnavailableError(_inner) => {
                _inner.fmt(f)
            }
            RestoreTableToPointInTimeError::TableAlreadyExistsError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeError::TableInUseError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeError::TableNotFoundError(_inner) => _inner.fmt(f),
            RestoreTableToPointInTimeError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl RestoreTableToPointInTimeError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        RestoreTableToPointInTimeError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            RestoreTableToPointInTimeError::InternalServerError(_inner) => _inner.message(),
            RestoreTableToPointInTimeError::InvalidEndpointError(_inner) => _inner.message(),
            RestoreTableToPointInTimeError::InvalidRestoreTimeError(_inner) => _inner.message(),
            RestoreTableToPointInTimeError::LimitExceededError(_inner) => _inner.message(),
            RestoreTableToPointInTimeError::PointInTimeRecoveryUnavailableError(_inner) => {
                _inner.message()
            }
            RestoreTableToPointInTimeError::TableAlreadyExistsError(_inner) => _inner.message(),
            RestoreTableToPointInTimeError::TableInUseError(_inner) => _inner.message(),
            RestoreTableToPointInTimeError::TableNotFoundError(_inner) => _inner.message(),
            RestoreTableToPointInTimeError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            RestoreTableToPointInTimeError::InternalServerError(_inner) => Some(_inner.code()),
            RestoreTableToPointInTimeError::InvalidEndpointError(_inner) => Some(_inner.code()),
            RestoreTableToPointInTimeError::InvalidRestoreTimeError(_inner) => Some(_inner.code()),
            RestoreTableToPointInTimeError::LimitExceededError(_inner) => Some(_inner.code()),
            RestoreTableToPointInTimeError::PointInTimeRecoveryUnavailableError(_inner) => {
                Some(_inner.code())
            }
            RestoreTableToPointInTimeError::TableAlreadyExistsError(_inner) => Some(_inner.code()),
            RestoreTableToPointInTimeError::TableInUseError(_inner) => Some(_inner.code()),
            RestoreTableToPointInTimeError::TableNotFoundError(_inner) => Some(_inner.code()),
            RestoreTableToPointInTimeError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for RestoreTableToPointInTimeError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            RestoreTableToPointInTimeError::InternalServerError(_inner) => Some(_inner),
            RestoreTableToPointInTimeError::InvalidEndpointError(_inner) => Some(_inner),
            RestoreTableToPointInTimeError::InvalidRestoreTimeError(_inner) => Some(_inner),
            RestoreTableToPointInTimeError::LimitExceededError(_inner) => Some(_inner),
            RestoreTableToPointInTimeError::PointInTimeRecoveryUnavailableError(_inner) => {
                Some(_inner)
            }
            RestoreTableToPointInTimeError::TableAlreadyExistsError(_inner) => Some(_inner),
            RestoreTableToPointInTimeError::TableInUseError(_inner) => Some(_inner),
            RestoreTableToPointInTimeError::TableNotFoundError(_inner) => Some(_inner),
            RestoreTableToPointInTimeError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum ScanError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for ScanError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ScanError::InternalServerError(_inner) => _inner.fmt(f),
            ScanError::InvalidEndpointError(_inner) => _inner.fmt(f),
            ScanError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            ScanError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            ScanError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            ScanError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ScanError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        ScanError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            ScanError::InternalServerError(_inner) => _inner.message(),
            ScanError::InvalidEndpointError(_inner) => _inner.message(),
            ScanError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            ScanError::RequestLimitExceeded(_inner) => _inner.message(),
            ScanError::ResourceNotFoundError(_inner) => _inner.message(),
            ScanError::Unhandled(_inner) => match _inner.downcast_ref::<::smithy_types::Error>() {
                Some(_inner) => _inner.message(),
                None => None,
            },
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            ScanError::InternalServerError(_inner) => Some(_inner.code()),
            ScanError::InvalidEndpointError(_inner) => Some(_inner.code()),
            ScanError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            ScanError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            ScanError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            ScanError::Unhandled(_inner) => match _inner.downcast_ref::<::smithy_types::Error>() {
                Some(_inner) => _inner.code(),
                None => None,
            },
        }
    }
}
impl ::std::error::Error for ScanError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            ScanError::InternalServerError(_inner) => Some(_inner),
            ScanError::InvalidEndpointError(_inner) => Some(_inner),
            ScanError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            ScanError::RequestLimitExceeded(_inner) => Some(_inner),
            ScanError::ResourceNotFoundError(_inner) => Some(_inner),
            ScanError::Unhandled(_inner) => match _inner.downcast_ref::<::smithy_types::Error>() {
                Some(_inner) => Some(_inner),
                None => Some(_inner.as_ref()),
            },
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum TagResourceError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TagResourceError::InternalServerError(_inner) => _inner.fmt(f),
            TagResourceError::InvalidEndpointError(_inner) => _inner.fmt(f),
            TagResourceError::LimitExceededError(_inner) => _inner.fmt(f),
            TagResourceError::ResourceInUseError(_inner) => _inner.fmt(f),
            TagResourceError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TagResourceError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl TagResourceError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        TagResourceError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            TagResourceError::InternalServerError(_inner) => _inner.message(),
            TagResourceError::InvalidEndpointError(_inner) => _inner.message(),
            TagResourceError::LimitExceededError(_inner) => _inner.message(),
            TagResourceError::ResourceInUseError(_inner) => _inner.message(),
            TagResourceError::ResourceNotFoundError(_inner) => _inner.message(),
            TagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            TagResourceError::InternalServerError(_inner) => Some(_inner.code()),
            TagResourceError::InvalidEndpointError(_inner) => Some(_inner.code()),
            TagResourceError::LimitExceededError(_inner) => Some(_inner.code()),
            TagResourceError::ResourceInUseError(_inner) => Some(_inner.code()),
            TagResourceError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            TagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            TagResourceError::InternalServerError(_inner) => Some(_inner),
            TagResourceError::InvalidEndpointError(_inner) => Some(_inner),
            TagResourceError::LimitExceededError(_inner) => Some(_inner),
            TagResourceError::ResourceInUseError(_inner) => Some(_inner),
            TagResourceError::ResourceNotFoundError(_inner) => Some(_inner),
            TagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum TransactGetItemsError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),
    TransactionCanceledError(TransactionCanceledError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for TransactGetItemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TransactGetItemsError::InternalServerError(_inner) => _inner.fmt(f),
            TransactGetItemsError::InvalidEndpointError(_inner) => _inner.fmt(f),
            TransactGetItemsError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            TransactGetItemsError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            TransactGetItemsError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TransactGetItemsError::TransactionCanceledError(_inner) => _inner.fmt(f),
            TransactGetItemsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl TransactGetItemsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        TransactGetItemsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            TransactGetItemsError::InternalServerError(_inner) => _inner.message(),
            TransactGetItemsError::InvalidEndpointError(_inner) => _inner.message(),
            TransactGetItemsError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            TransactGetItemsError::RequestLimitExceeded(_inner) => _inner.message(),
            TransactGetItemsError::ResourceNotFoundError(_inner) => _inner.message(),
            TransactGetItemsError::TransactionCanceledError(_inner) => _inner.message(),
            TransactGetItemsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            TransactGetItemsError::InternalServerError(_inner) => Some(_inner.code()),
            TransactGetItemsError::InvalidEndpointError(_inner) => Some(_inner.code()),
            TransactGetItemsError::ProvisionedThroughputExceededError(_inner) => {
                Some(_inner.code())
            }
            TransactGetItemsError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            TransactGetItemsError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            TransactGetItemsError::TransactionCanceledError(_inner) => Some(_inner.code()),
            TransactGetItemsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for TransactGetItemsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            TransactGetItemsError::InternalServerError(_inner) => Some(_inner),
            TransactGetItemsError::InvalidEndpointError(_inner) => Some(_inner),
            TransactGetItemsError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            TransactGetItemsError::RequestLimitExceeded(_inner) => Some(_inner),
            TransactGetItemsError::ResourceNotFoundError(_inner) => Some(_inner),
            TransactGetItemsError::TransactionCanceledError(_inner) => Some(_inner),
            TransactGetItemsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum TransactWriteItemsError {
    IdempotentParameterMismatchError(IdempotentParameterMismatchError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),
    TransactionCanceledError(TransactionCanceledError),
    TransactionInProgressError(TransactionInProgressError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for TransactWriteItemsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TransactWriteItemsError::IdempotentParameterMismatchError(_inner) => _inner.fmt(f),
            TransactWriteItemsError::InternalServerError(_inner) => _inner.fmt(f),
            TransactWriteItemsError::InvalidEndpointError(_inner) => _inner.fmt(f),
            TransactWriteItemsError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            TransactWriteItemsError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            TransactWriteItemsError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            TransactWriteItemsError::TransactionCanceledError(_inner) => _inner.fmt(f),
            TransactWriteItemsError::TransactionInProgressError(_inner) => _inner.fmt(f),
            TransactWriteItemsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl TransactWriteItemsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        TransactWriteItemsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            TransactWriteItemsError::IdempotentParameterMismatchError(_inner) => _inner.message(),
            TransactWriteItemsError::InternalServerError(_inner) => _inner.message(),
            TransactWriteItemsError::InvalidEndpointError(_inner) => _inner.message(),
            TransactWriteItemsError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            TransactWriteItemsError::RequestLimitExceeded(_inner) => _inner.message(),
            TransactWriteItemsError::ResourceNotFoundError(_inner) => _inner.message(),
            TransactWriteItemsError::TransactionCanceledError(_inner) => _inner.message(),
            TransactWriteItemsError::TransactionInProgressError(_inner) => _inner.message(),
            TransactWriteItemsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            TransactWriteItemsError::IdempotentParameterMismatchError(_inner) => {
                Some(_inner.code())
            }
            TransactWriteItemsError::InternalServerError(_inner) => Some(_inner.code()),
            TransactWriteItemsError::InvalidEndpointError(_inner) => Some(_inner.code()),
            TransactWriteItemsError::ProvisionedThroughputExceededError(_inner) => {
                Some(_inner.code())
            }
            TransactWriteItemsError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            TransactWriteItemsError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            TransactWriteItemsError::TransactionCanceledError(_inner) => Some(_inner.code()),
            TransactWriteItemsError::TransactionInProgressError(_inner) => Some(_inner.code()),
            TransactWriteItemsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for TransactWriteItemsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            TransactWriteItemsError::IdempotentParameterMismatchError(_inner) => Some(_inner),
            TransactWriteItemsError::InternalServerError(_inner) => Some(_inner),
            TransactWriteItemsError::InvalidEndpointError(_inner) => Some(_inner),
            TransactWriteItemsError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            TransactWriteItemsError::RequestLimitExceeded(_inner) => Some(_inner),
            TransactWriteItemsError::ResourceNotFoundError(_inner) => Some(_inner),
            TransactWriteItemsError::TransactionCanceledError(_inner) => Some(_inner),
            TransactWriteItemsError::TransactionInProgressError(_inner) => Some(_inner),
            TransactWriteItemsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UntagResourceError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UntagResourceError::InternalServerError(_inner) => _inner.fmt(f),
            UntagResourceError::InvalidEndpointError(_inner) => _inner.fmt(f),
            UntagResourceError::LimitExceededError(_inner) => _inner.fmt(f),
            UntagResourceError::ResourceInUseError(_inner) => _inner.fmt(f),
            UntagResourceError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UntagResourceError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl UntagResourceError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UntagResourceError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UntagResourceError::InternalServerError(_inner) => _inner.message(),
            UntagResourceError::InvalidEndpointError(_inner) => _inner.message(),
            UntagResourceError::LimitExceededError(_inner) => _inner.message(),
            UntagResourceError::ResourceInUseError(_inner) => _inner.message(),
            UntagResourceError::ResourceNotFoundError(_inner) => _inner.message(),
            UntagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UntagResourceError::InternalServerError(_inner) => Some(_inner.code()),
            UntagResourceError::InvalidEndpointError(_inner) => Some(_inner.code()),
            UntagResourceError::LimitExceededError(_inner) => Some(_inner.code()),
            UntagResourceError::ResourceInUseError(_inner) => Some(_inner.code()),
            UntagResourceError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            UntagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UntagResourceError::InternalServerError(_inner) => Some(_inner),
            UntagResourceError::InvalidEndpointError(_inner) => Some(_inner),
            UntagResourceError::LimitExceededError(_inner) => Some(_inner),
            UntagResourceError::ResourceInUseError(_inner) => Some(_inner),
            UntagResourceError::ResourceNotFoundError(_inner) => Some(_inner),
            UntagResourceError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateContinuousBackupsError {
    ContinuousBackupsUnavailableError(ContinuousBackupsUnavailableError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    TableNotFoundError(TableNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateContinuousBackupsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateContinuousBackupsError::ContinuousBackupsUnavailableError(_inner) => {
                _inner.fmt(f)
            }
            UpdateContinuousBackupsError::InternalServerError(_inner) => _inner.fmt(f),
            UpdateContinuousBackupsError::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateContinuousBackupsError::TableNotFoundError(_inner) => _inner.fmt(f),
            UpdateContinuousBackupsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl UpdateContinuousBackupsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateContinuousBackupsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateContinuousBackupsError::ContinuousBackupsUnavailableError(_inner) => {
                _inner.message()
            }
            UpdateContinuousBackupsError::InternalServerError(_inner) => _inner.message(),
            UpdateContinuousBackupsError::InvalidEndpointError(_inner) => _inner.message(),
            UpdateContinuousBackupsError::TableNotFoundError(_inner) => _inner.message(),
            UpdateContinuousBackupsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateContinuousBackupsError::ContinuousBackupsUnavailableError(_inner) => {
                Some(_inner.code())
            }
            UpdateContinuousBackupsError::InternalServerError(_inner) => Some(_inner.code()),
            UpdateContinuousBackupsError::InvalidEndpointError(_inner) => Some(_inner.code()),
            UpdateContinuousBackupsError::TableNotFoundError(_inner) => Some(_inner.code()),
            UpdateContinuousBackupsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateContinuousBackupsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateContinuousBackupsError::ContinuousBackupsUnavailableError(_inner) => Some(_inner),
            UpdateContinuousBackupsError::InternalServerError(_inner) => Some(_inner),
            UpdateContinuousBackupsError::InvalidEndpointError(_inner) => Some(_inner),
            UpdateContinuousBackupsError::TableNotFoundError(_inner) => Some(_inner),
            UpdateContinuousBackupsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateContributorInsightsError {
    InternalServerError(InternalServerError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateContributorInsightsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateContributorInsightsError::InternalServerError(_inner) => _inner.fmt(f),
            UpdateContributorInsightsError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateContributorInsightsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl UpdateContributorInsightsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateContributorInsightsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateContributorInsightsError::InternalServerError(_inner) => _inner.message(),
            UpdateContributorInsightsError::ResourceNotFoundError(_inner) => _inner.message(),
            UpdateContributorInsightsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateContributorInsightsError::InternalServerError(_inner) => Some(_inner.code()),
            UpdateContributorInsightsError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            UpdateContributorInsightsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateContributorInsightsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateContributorInsightsError::InternalServerError(_inner) => Some(_inner),
            UpdateContributorInsightsError::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateContributorInsightsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateGlobalTableError {
    GlobalTableNotFoundError(GlobalTableNotFoundError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ReplicaAlreadyExistsError(ReplicaAlreadyExistsError),
    ReplicaNotFoundError(ReplicaNotFoundError),
    TableNotFoundError(TableNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateGlobalTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateGlobalTableError::GlobalTableNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableError::InternalServerError(_inner) => _inner.fmt(f),
            UpdateGlobalTableError::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateGlobalTableError::ReplicaAlreadyExistsError(_inner) => _inner.fmt(f),
            UpdateGlobalTableError::ReplicaNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableError::TableNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl UpdateGlobalTableError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateGlobalTableError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateGlobalTableError::GlobalTableNotFoundError(_inner) => _inner.message(),
            UpdateGlobalTableError::InternalServerError(_inner) => _inner.message(),
            UpdateGlobalTableError::InvalidEndpointError(_inner) => _inner.message(),
            UpdateGlobalTableError::ReplicaAlreadyExistsError(_inner) => _inner.message(),
            UpdateGlobalTableError::ReplicaNotFoundError(_inner) => _inner.message(),
            UpdateGlobalTableError::TableNotFoundError(_inner) => _inner.message(),
            UpdateGlobalTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateGlobalTableError::GlobalTableNotFoundError(_inner) => Some(_inner.code()),
            UpdateGlobalTableError::InternalServerError(_inner) => Some(_inner.code()),
            UpdateGlobalTableError::InvalidEndpointError(_inner) => Some(_inner.code()),
            UpdateGlobalTableError::ReplicaAlreadyExistsError(_inner) => Some(_inner.code()),
            UpdateGlobalTableError::ReplicaNotFoundError(_inner) => Some(_inner.code()),
            UpdateGlobalTableError::TableNotFoundError(_inner) => Some(_inner.code()),
            UpdateGlobalTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateGlobalTableError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateGlobalTableError::GlobalTableNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableError::InternalServerError(_inner) => Some(_inner),
            UpdateGlobalTableError::InvalidEndpointError(_inner) => Some(_inner),
            UpdateGlobalTableError::ReplicaAlreadyExistsError(_inner) => Some(_inner),
            UpdateGlobalTableError::ReplicaNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableError::TableNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateGlobalTableSettingsError {
    GlobalTableNotFoundError(GlobalTableNotFoundError),
    IndexNotFoundError(IndexNotFoundError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    ReplicaNotFoundError(ReplicaNotFoundError),
    ResourceInUseError(ResourceInUseError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateGlobalTableSettingsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateGlobalTableSettingsError::GlobalTableNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsError::IndexNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsError::InternalServerError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsError::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsError::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsError::ReplicaNotFoundError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsError::ResourceInUseError(_inner) => _inner.fmt(f),
            UpdateGlobalTableSettingsError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl UpdateGlobalTableSettingsError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateGlobalTableSettingsError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateGlobalTableSettingsError::GlobalTableNotFoundError(_inner) => _inner.message(),
            UpdateGlobalTableSettingsError::IndexNotFoundError(_inner) => _inner.message(),
            UpdateGlobalTableSettingsError::InternalServerError(_inner) => _inner.message(),
            UpdateGlobalTableSettingsError::InvalidEndpointError(_inner) => _inner.message(),
            UpdateGlobalTableSettingsError::LimitExceededError(_inner) => _inner.message(),
            UpdateGlobalTableSettingsError::ReplicaNotFoundError(_inner) => _inner.message(),
            UpdateGlobalTableSettingsError::ResourceInUseError(_inner) => _inner.message(),
            UpdateGlobalTableSettingsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateGlobalTableSettingsError::GlobalTableNotFoundError(_inner) => Some(_inner.code()),
            UpdateGlobalTableSettingsError::IndexNotFoundError(_inner) => Some(_inner.code()),
            UpdateGlobalTableSettingsError::InternalServerError(_inner) => Some(_inner.code()),
            UpdateGlobalTableSettingsError::InvalidEndpointError(_inner) => Some(_inner.code()),
            UpdateGlobalTableSettingsError::LimitExceededError(_inner) => Some(_inner.code()),
            UpdateGlobalTableSettingsError::ReplicaNotFoundError(_inner) => Some(_inner.code()),
            UpdateGlobalTableSettingsError::ResourceInUseError(_inner) => Some(_inner.code()),
            UpdateGlobalTableSettingsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateGlobalTableSettingsError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateGlobalTableSettingsError::GlobalTableNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsError::IndexNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsError::InternalServerError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsError::InvalidEndpointError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsError::LimitExceededError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsError::ReplicaNotFoundError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsError::ResourceInUseError(_inner) => Some(_inner),
            UpdateGlobalTableSettingsError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateItemError {
    ConditionalCheckFailedError(ConditionalCheckFailedError),
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    ItemCollectionSizeLimitExceededError(ItemCollectionSizeLimitExceededError),
    ProvisionedThroughputExceededError(ProvisionedThroughputExceededError),
    RequestLimitExceeded(RequestLimitExceeded),
    ResourceNotFoundError(ResourceNotFoundError),
    TransactionConflictError(TransactionConflictError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateItemError::ConditionalCheckFailedError(_inner) => _inner.fmt(f),
            UpdateItemError::InternalServerError(_inner) => _inner.fmt(f),
            UpdateItemError::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateItemError::ItemCollectionSizeLimitExceededError(_inner) => _inner.fmt(f),
            UpdateItemError::ProvisionedThroughputExceededError(_inner) => _inner.fmt(f),
            UpdateItemError::RequestLimitExceeded(_inner) => _inner.fmt(f),
            UpdateItemError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateItemError::TransactionConflictError(_inner) => _inner.fmt(f),
            UpdateItemError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl UpdateItemError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateItemError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateItemError::ConditionalCheckFailedError(_inner) => _inner.message(),
            UpdateItemError::InternalServerError(_inner) => _inner.message(),
            UpdateItemError::InvalidEndpointError(_inner) => _inner.message(),
            UpdateItemError::ItemCollectionSizeLimitExceededError(_inner) => _inner.message(),
            UpdateItemError::ProvisionedThroughputExceededError(_inner) => _inner.message(),
            UpdateItemError::RequestLimitExceeded(_inner) => _inner.message(),
            UpdateItemError::ResourceNotFoundError(_inner) => _inner.message(),
            UpdateItemError::TransactionConflictError(_inner) => _inner.message(),
            UpdateItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateItemError::ConditionalCheckFailedError(_inner) => Some(_inner.code()),
            UpdateItemError::InternalServerError(_inner) => Some(_inner.code()),
            UpdateItemError::InvalidEndpointError(_inner) => Some(_inner.code()),
            UpdateItemError::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner.code()),
            UpdateItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner.code()),
            UpdateItemError::RequestLimitExceeded(_inner) => Some(_inner.code()),
            UpdateItemError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            UpdateItemError::TransactionConflictError(_inner) => Some(_inner.code()),
            UpdateItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateItemError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateItemError::ConditionalCheckFailedError(_inner) => Some(_inner),
            UpdateItemError::InternalServerError(_inner) => Some(_inner),
            UpdateItemError::InvalidEndpointError(_inner) => Some(_inner),
            UpdateItemError::ItemCollectionSizeLimitExceededError(_inner) => Some(_inner),
            UpdateItemError::ProvisionedThroughputExceededError(_inner) => Some(_inner),
            UpdateItemError::RequestLimitExceeded(_inner) => Some(_inner),
            UpdateItemError::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateItemError::TransactionConflictError(_inner) => Some(_inner),
            UpdateItemError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateTableError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateTableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateTableError::InternalServerError(_inner) => _inner.fmt(f),
            UpdateTableError::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateTableError::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateTableError::ResourceInUseError(_inner) => _inner.fmt(f),
            UpdateTableError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateTableError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl UpdateTableError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateTableError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateTableError::InternalServerError(_inner) => _inner.message(),
            UpdateTableError::InvalidEndpointError(_inner) => _inner.message(),
            UpdateTableError::LimitExceededError(_inner) => _inner.message(),
            UpdateTableError::ResourceInUseError(_inner) => _inner.message(),
            UpdateTableError::ResourceNotFoundError(_inner) => _inner.message(),
            UpdateTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateTableError::InternalServerError(_inner) => Some(_inner.code()),
            UpdateTableError::InvalidEndpointError(_inner) => Some(_inner.code()),
            UpdateTableError::LimitExceededError(_inner) => Some(_inner.code()),
            UpdateTableError::ResourceInUseError(_inner) => Some(_inner.code()),
            UpdateTableError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            UpdateTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateTableError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateTableError::InternalServerError(_inner) => Some(_inner),
            UpdateTableError::InvalidEndpointError(_inner) => Some(_inner),
            UpdateTableError::LimitExceededError(_inner) => Some(_inner),
            UpdateTableError::ResourceInUseError(_inner) => Some(_inner),
            UpdateTableError::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateTableError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateTableReplicaAutoScalingError {
    InternalServerError(InternalServerError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateTableReplicaAutoScalingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateTableReplicaAutoScalingError::InternalServerError(_inner) => _inner.fmt(f),
            UpdateTableReplicaAutoScalingError::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateTableReplicaAutoScalingError::ResourceInUseError(_inner) => _inner.fmt(f),
            UpdateTableReplicaAutoScalingError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateTableReplicaAutoScalingError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl UpdateTableReplicaAutoScalingError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateTableReplicaAutoScalingError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateTableReplicaAutoScalingError::InternalServerError(_inner) => _inner.message(),
            UpdateTableReplicaAutoScalingError::LimitExceededError(_inner) => _inner.message(),
            UpdateTableReplicaAutoScalingError::ResourceInUseError(_inner) => _inner.message(),
            UpdateTableReplicaAutoScalingError::ResourceNotFoundError(_inner) => _inner.message(),
            UpdateTableReplicaAutoScalingError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateTableReplicaAutoScalingError::InternalServerError(_inner) => Some(_inner.code()),
            UpdateTableReplicaAutoScalingError::LimitExceededError(_inner) => Some(_inner.code()),
            UpdateTableReplicaAutoScalingError::ResourceInUseError(_inner) => Some(_inner.code()),
            UpdateTableReplicaAutoScalingError::ResourceNotFoundError(_inner) => {
                Some(_inner.code())
            }
            UpdateTableReplicaAutoScalingError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateTableReplicaAutoScalingError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateTableReplicaAutoScalingError::InternalServerError(_inner) => Some(_inner),
            UpdateTableReplicaAutoScalingError::LimitExceededError(_inner) => Some(_inner),
            UpdateTableReplicaAutoScalingError::ResourceInUseError(_inner) => Some(_inner),
            UpdateTableReplicaAutoScalingError::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateTableReplicaAutoScalingError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum UpdateTimeToLiveError {
    InternalServerError(InternalServerError),
    InvalidEndpointError(InvalidEndpointError),
    LimitExceededError(LimitExceededError),
    ResourceInUseError(ResourceInUseError),
    ResourceNotFoundError(ResourceNotFoundError),

    /// An unexpected error, eg. invalid JSON returned by the service
    Unhandled(Box<dyn ::std::error::Error>),
}
impl ::std::fmt::Display for UpdateTimeToLiveError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UpdateTimeToLiveError::InternalServerError(_inner) => _inner.fmt(f),
            UpdateTimeToLiveError::InvalidEndpointError(_inner) => _inner.fmt(f),
            UpdateTimeToLiveError::LimitExceededError(_inner) => _inner.fmt(f),
            UpdateTimeToLiveError::ResourceInUseError(_inner) => _inner.fmt(f),
            UpdateTimeToLiveError::ResourceNotFoundError(_inner) => _inner.fmt(f),
            UpdateTimeToLiveError::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl UpdateTimeToLiveError {
    pub fn unhandled<E: Into<Box<dyn ::std::error::Error>>>(err: E) -> Self {
        UpdateTimeToLiveError::Unhandled(err.into())
    }
    pub fn message(&self) -> Option<&str> {
        match self {
            UpdateTimeToLiveError::InternalServerError(_inner) => _inner.message(),
            UpdateTimeToLiveError::InvalidEndpointError(_inner) => _inner.message(),
            UpdateTimeToLiveError::LimitExceededError(_inner) => _inner.message(),
            UpdateTimeToLiveError::ResourceInUseError(_inner) => _inner.message(),
            UpdateTimeToLiveError::ResourceNotFoundError(_inner) => _inner.message(),
            UpdateTimeToLiveError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.message(),
                    None => None,
                }
            }
        }
    }
    pub fn code(&self) -> Option<&str> {
        match self {
            UpdateTimeToLiveError::InternalServerError(_inner) => Some(_inner.code()),
            UpdateTimeToLiveError::InvalidEndpointError(_inner) => Some(_inner.code()),
            UpdateTimeToLiveError::LimitExceededError(_inner) => Some(_inner.code()),
            UpdateTimeToLiveError::ResourceInUseError(_inner) => Some(_inner.code()),
            UpdateTimeToLiveError::ResourceNotFoundError(_inner) => Some(_inner.code()),
            UpdateTimeToLiveError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => _inner.code(),
                    None => None,
                }
            }
        }
    }
}
impl ::std::error::Error for UpdateTimeToLiveError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            UpdateTimeToLiveError::InternalServerError(_inner) => Some(_inner),
            UpdateTimeToLiveError::InvalidEndpointError(_inner) => Some(_inner),
            UpdateTimeToLiveError::LimitExceededError(_inner) => Some(_inner),
            UpdateTimeToLiveError::ResourceInUseError(_inner) => Some(_inner),
            UpdateTimeToLiveError::ResourceNotFoundError(_inner) => Some(_inner),
            UpdateTimeToLiveError::Unhandled(_inner) => {
                match _inner.downcast_ref::<::smithy_types::Error>() {
                    Some(_inner) => Some(_inner),
                    None => Some(_inner.as_ref()),
                }
            }
        }
    }
}

/// <p>The operation tried to access a nonexistent table or index. The resource might not be specified
/// correctly, or its status might not be <code>ACTIVE</code>.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ResourceNotFoundError {
    /// <p>The resource which is being requested does not exist.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ResourceNotFoundError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "ResourceNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ResourceNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundError")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ResourceNotFoundError {}
/// See [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
pub mod resource_not_found_error {

    use crate::error::ResourceNotFoundError;
    /// A builder for [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>The resource which is being requested does not exist.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
        pub fn build(self) -> ResourceNotFoundError {
            ResourceNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ResourceNotFoundError {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundError`](crate::error::ResourceNotFoundError)
    pub fn builder() -> crate::error::resource_not_found_error::Builder {
        crate::error::resource_not_found_error::Builder::default()
    }
}

/// <p>The operation conflicts with the resource's availability. For example, you attempted to
/// recreate an existing table, or tried to delete a table currently in the <code>CREATING</code>
/// state.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ResourceInUseError {
    /// <p>The resource which is being attempted to be changed is in use.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ResourceInUseError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "ResourceInUseException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ResourceInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceInUseError")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ResourceInUseError {}
/// See [`ResourceInUseError`](crate::error::ResourceInUseError)
pub mod resource_in_use_error {

    use crate::error::ResourceInUseError;
    /// A builder for [`ResourceInUseError`](crate::error::ResourceInUseError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>The resource which is being attempted to be changed is in use.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ResourceInUseError`](crate::error::ResourceInUseError)
        pub fn build(self) -> ResourceInUseError {
            ResourceInUseError {
                message: self.message,
            }
        }
    }
}
impl ResourceInUseError {
    /// Creates a new builder-style object to manufacture [`ResourceInUseError`](crate::error::ResourceInUseError)
    pub fn builder() -> crate::error::resource_in_use_error::Builder {
        crate::error::resource_in_use_error::Builder::default()
    }
}

/// <p>There is no limit to the number of daily on-demand backups that can be taken. </p>
/// <p>Up to 50 simultaneous table operations are allowed per account. These operations
/// include <code>CreateTable</code>, <code>UpdateTable</code>,
/// <code>DeleteTable</code>,<code>UpdateTimeToLive</code>,
/// <code>RestoreTableFromBackup</code>, and <code>RestoreTableToPointInTime</code>. </p>
/// <p>The only exception is when you are creating a table with one or more secondary indexes. You can have up to
/// 25 such requests running at a time; however, if the table or index specifications are complex, DynamoDB might temporarily
/// reduce the number of concurrent operations.</p>
/// <p>There is a soft account quota of 256 tables.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct LimitExceededError {
    /// <p>Too many operations for a given subscriber.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl LimitExceededError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "LimitExceededException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for LimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "LimitExceededError")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for LimitExceededError {}
/// See [`LimitExceededError`](crate::error::LimitExceededError)
pub mod limit_exceeded_error {

    use crate::error::LimitExceededError;
    /// A builder for [`LimitExceededError`](crate::error::LimitExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>Too many operations for a given subscriber.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`LimitExceededError`](crate::error::LimitExceededError)
        pub fn build(self) -> LimitExceededError {
            LimitExceededError {
                message: self.message,
            }
        }
    }
}
impl LimitExceededError {
    /// Creates a new builder-style object to manufacture [`LimitExceededError`](crate::error::LimitExceededError)
    pub fn builder() -> crate::error::limit_exceeded_error::Builder {
        crate::error::limit_exceeded_error::Builder::default()
    }
}

#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct InvalidEndpointError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl InvalidEndpointError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "InvalidEndpointException"
    }
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl ::std::fmt::Display for InvalidEndpointError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEndpointError")?;
        Ok(())
    }
}
impl ::std::error::Error for InvalidEndpointError {}
/// See [`InvalidEndpointError`](crate::error::InvalidEndpointError)
pub mod invalid_endpoint_error {

    use crate::error::InvalidEndpointError;
    /// A builder for [`InvalidEndpointError`](crate::error::InvalidEndpointError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidEndpointError`](crate::error::InvalidEndpointError)
        pub fn build(self) -> InvalidEndpointError {
            InvalidEndpointError {
                message: self.message,
            }
        }
    }
}
impl InvalidEndpointError {
    /// Creates a new builder-style object to manufacture [`InvalidEndpointError`](crate::error::InvalidEndpointError)
    pub fn builder() -> crate::error::invalid_endpoint_error::Builder {
        crate::error::invalid_endpoint_error::Builder::default()
    }
}

/// <p>An error occurred on the server side.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct InternalServerError {
    /// <p>The server encountered an internal error trying to fulfill the request.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl InternalServerError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "InternalServerError"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InternalServerError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalServerError")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InternalServerError {}
/// See [`InternalServerError`](crate::error::InternalServerError)
pub mod internal_server_error {

    use crate::error::InternalServerError;
    /// A builder for [`InternalServerError`](crate::error::InternalServerError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>The server encountered an internal error trying to fulfill the request.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InternalServerError`](crate::error::InternalServerError)
        pub fn build(self) -> InternalServerError {
            InternalServerError {
                message: self.message,
            }
        }
    }
}
impl InternalServerError {
    /// Creates a new builder-style object to manufacture [`InternalServerError`](crate::error::InternalServerError)
    pub fn builder() -> crate::error::internal_server_error::Builder {
        crate::error::internal_server_error::Builder::default()
    }
}

/// <p>Operation was rejected because there is an ongoing transaction for the item.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TransactionConflictError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl TransactionConflictError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "TransactionConflictException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for TransactionConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransactionConflictError")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for TransactionConflictError {}
/// See [`TransactionConflictError`](crate::error::TransactionConflictError)
pub mod transaction_conflict_error {

    use crate::error::TransactionConflictError;
    /// A builder for [`TransactionConflictError`](crate::error::TransactionConflictError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TransactionConflictError`](crate::error::TransactionConflictError)
        pub fn build(self) -> TransactionConflictError {
            TransactionConflictError {
                message: self.message,
            }
        }
    }
}
impl TransactionConflictError {
    /// Creates a new builder-style object to manufacture [`TransactionConflictError`](crate::error::TransactionConflictError)
    pub fn builder() -> crate::error::transaction_conflict_error::Builder {
        crate::error::transaction_conflict_error::Builder::default()
    }
}

/// <p>Throughput exceeds the current throughput quota for your account. Please contact AWS Support at <a href="https://aws.amazon.com/support">AWS Support</a> to request a quota increase.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct RequestLimitExceeded {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl RequestLimitExceeded {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "RequestLimitExceeded"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for RequestLimitExceeded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestLimitExceeded")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for RequestLimitExceeded {}
/// See [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
pub mod request_limit_exceeded {

    use crate::error::RequestLimitExceeded;
    /// A builder for [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
        pub fn build(self) -> RequestLimitExceeded {
            RequestLimitExceeded {
                message: self.message,
            }
        }
    }
}
impl RequestLimitExceeded {
    /// Creates a new builder-style object to manufacture [`RequestLimitExceeded`](crate::error::RequestLimitExceeded)
    pub fn builder() -> crate::error::request_limit_exceeded::Builder {
        crate::error::request_limit_exceeded::Builder::default()
    }
}

/// <p>Your request rate is too high. The AWS SDKs for DynamoDB automatically retry requests that
/// receive this exception. Your request is eventually successful, unless your retry queue is too
/// large to finish. Reduce the frequency of requests and use exponential backoff. For more
/// information, go to <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.RetryAndBackoff">Error Retries and Exponential
/// Backoff</a> in the <i>Amazon DynamoDB Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ProvisionedThroughputExceededError {
    /// <p>You exceeded your maximum allowed provisioned throughput.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ProvisionedThroughputExceededError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "ProvisionedThroughputExceededException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ProvisionedThroughputExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ProvisionedThroughputExceededError")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ProvisionedThroughputExceededError {}
/// See [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
pub mod provisioned_throughput_exceeded_error {

    use crate::error::ProvisionedThroughputExceededError;
    /// A builder for [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>You exceeded your maximum allowed provisioned throughput.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
        pub fn build(self) -> ProvisionedThroughputExceededError {
            ProvisionedThroughputExceededError {
                message: self.message,
            }
        }
    }
}
impl ProvisionedThroughputExceededError {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughputExceededError`](crate::error::ProvisionedThroughputExceededError)
    pub fn builder() -> crate::error::provisioned_throughput_exceeded_error::Builder {
        crate::error::provisioned_throughput_exceeded_error::Builder::default()
    }
}

/// <p>An item collection is too large. This exception is only returned for tables that have one or more local secondary indexes.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ItemCollectionSizeLimitExceededError {
    /// <p>The total size of an item collection has exceeded the maximum limit of 10 gigabytes.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ItemCollectionSizeLimitExceededError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "ItemCollectionSizeLimitExceededException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ItemCollectionSizeLimitExceededError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ItemCollectionSizeLimitExceededError")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ItemCollectionSizeLimitExceededError {}
/// See [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
pub mod item_collection_size_limit_exceeded_error {

    use crate::error::ItemCollectionSizeLimitExceededError;
    /// A builder for [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>The total size of an item collection has exceeded the maximum limit of 10 gigabytes.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
        pub fn build(self) -> ItemCollectionSizeLimitExceededError {
            ItemCollectionSizeLimitExceededError {
                message: self.message,
            }
        }
    }
}
impl ItemCollectionSizeLimitExceededError {
    /// Creates a new builder-style object to manufacture [`ItemCollectionSizeLimitExceededError`](crate::error::ItemCollectionSizeLimitExceededError)
    pub fn builder() -> crate::error::item_collection_size_limit_exceeded_error::Builder {
        crate::error::item_collection_size_limit_exceeded_error::Builder::default()
    }
}

/// <p>A condition specified in the operation could not be evaluated.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ConditionalCheckFailedError {
    /// <p>The conditional request failed.</p>
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ConditionalCheckFailedError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "ConditionalCheckFailedException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ConditionalCheckFailedError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConditionalCheckFailedError")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ConditionalCheckFailedError {}
/// See [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
pub mod conditional_check_failed_error {

    use crate::error::ConditionalCheckFailedError;
    /// A builder for [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        /// <p>The conditional request failed.</p>
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
        pub fn build(self) -> ConditionalCheckFailedError {
            ConditionalCheckFailedError {
                message: self.message,
            }
        }
    }
}
impl ConditionalCheckFailedError {
    /// Creates a new builder-style object to manufacture [`ConditionalCheckFailedError`](crate::error::ConditionalCheckFailedError)
    pub fn builder() -> crate::error::conditional_check_failed_error::Builder {
        crate::error::conditional_check_failed_error::Builder::default()
    }
}

/// <p>The specified replica is no longer part of the global table.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ReplicaNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ReplicaNotFoundError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "ReplicaNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ReplicaNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplicaNotFoundError")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ReplicaNotFoundError {}
/// See [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
pub mod replica_not_found_error {

    use crate::error::ReplicaNotFoundError;
    /// A builder for [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
        pub fn build(self) -> ReplicaNotFoundError {
            ReplicaNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ReplicaNotFoundError {
    /// Creates a new builder-style object to manufacture [`ReplicaNotFoundError`](crate::error::ReplicaNotFoundError)
    pub fn builder() -> crate::error::replica_not_found_error::Builder {
        crate::error::replica_not_found_error::Builder::default()
    }
}

/// <p>The operation tried to access a nonexistent index.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct IndexNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl IndexNotFoundError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "IndexNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for IndexNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IndexNotFoundError")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for IndexNotFoundError {}
/// See [`IndexNotFoundError`](crate::error::IndexNotFoundError)
pub mod index_not_found_error {

    use crate::error::IndexNotFoundError;
    /// A builder for [`IndexNotFoundError`](crate::error::IndexNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`IndexNotFoundError`](crate::error::IndexNotFoundError)
        pub fn build(self) -> IndexNotFoundError {
            IndexNotFoundError {
                message: self.message,
            }
        }
    }
}
impl IndexNotFoundError {
    /// Creates a new builder-style object to manufacture [`IndexNotFoundError`](crate::error::IndexNotFoundError)
    pub fn builder() -> crate::error::index_not_found_error::Builder {
        crate::error::index_not_found_error::Builder::default()
    }
}

/// <p>The specified global table does not exist.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct GlobalTableNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl GlobalTableNotFoundError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "GlobalTableNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for GlobalTableNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalTableNotFoundError")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for GlobalTableNotFoundError {}
/// See [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
pub mod global_table_not_found_error {

    use crate::error::GlobalTableNotFoundError;
    /// A builder for [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
        pub fn build(self) -> GlobalTableNotFoundError {
            GlobalTableNotFoundError {
                message: self.message,
            }
        }
    }
}
impl GlobalTableNotFoundError {
    /// Creates a new builder-style object to manufacture [`GlobalTableNotFoundError`](crate::error::GlobalTableNotFoundError)
    pub fn builder() -> crate::error::global_table_not_found_error::Builder {
        crate::error::global_table_not_found_error::Builder::default()
    }
}

/// <p>A source table with the name <code>TableName</code> does not currently exist within the subscriber's account.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TableNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl TableNotFoundError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "TableNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for TableNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableNotFoundError")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for TableNotFoundError {}
/// See [`TableNotFoundError`](crate::error::TableNotFoundError)
pub mod table_not_found_error {

    use crate::error::TableNotFoundError;
    /// A builder for [`TableNotFoundError`](crate::error::TableNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TableNotFoundError`](crate::error::TableNotFoundError)
        pub fn build(self) -> TableNotFoundError {
            TableNotFoundError {
                message: self.message,
            }
        }
    }
}
impl TableNotFoundError {
    /// Creates a new builder-style object to manufacture [`TableNotFoundError`](crate::error::TableNotFoundError)
    pub fn builder() -> crate::error::table_not_found_error::Builder {
        crate::error::table_not_found_error::Builder::default()
    }
}

/// <p>The specified replica is already part of the global table.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ReplicaAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ReplicaAlreadyExistsError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "ReplicaAlreadyExistsException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ReplicaAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplicaAlreadyExistsError")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ReplicaAlreadyExistsError {}
/// See [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
pub mod replica_already_exists_error {

    use crate::error::ReplicaAlreadyExistsError;
    /// A builder for [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
        pub fn build(self) -> ReplicaAlreadyExistsError {
            ReplicaAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl ReplicaAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`ReplicaAlreadyExistsError`](crate::error::ReplicaAlreadyExistsError)
    pub fn builder() -> crate::error::replica_already_exists_error::Builder {
        crate::error::replica_already_exists_error::Builder::default()
    }
}

/// <p>Backups have not yet been enabled for this table.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ContinuousBackupsUnavailableError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ContinuousBackupsUnavailableError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "ContinuousBackupsUnavailableException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ContinuousBackupsUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ContinuousBackupsUnavailableError")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ContinuousBackupsUnavailableError {}
/// See [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
pub mod continuous_backups_unavailable_error {

    use crate::error::ContinuousBackupsUnavailableError;
    /// A builder for [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
        pub fn build(self) -> ContinuousBackupsUnavailableError {
            ContinuousBackupsUnavailableError {
                message: self.message,
            }
        }
    }
}
impl ContinuousBackupsUnavailableError {
    /// Creates a new builder-style object to manufacture [`ContinuousBackupsUnavailableError`](crate::error::ContinuousBackupsUnavailableError)
    pub fn builder() -> crate::error::continuous_backups_unavailable_error::Builder {
        crate::error::continuous_backups_unavailable_error::Builder::default()
    }
}

/// <p>The transaction with the given request token is already in progress.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TransactionInProgressError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl TransactionInProgressError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "TransactionInProgressException"
    }
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl ::std::fmt::Display for TransactionInProgressError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransactionInProgressError")?;
        Ok(())
    }
}
impl ::std::error::Error for TransactionInProgressError {}
/// See [`TransactionInProgressError`](crate::error::TransactionInProgressError)
pub mod transaction_in_progress_error {

    use crate::error::TransactionInProgressError;
    /// A builder for [`TransactionInProgressError`](crate::error::TransactionInProgressError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TransactionInProgressError`](crate::error::TransactionInProgressError)
        pub fn build(self) -> TransactionInProgressError {
            TransactionInProgressError {
                message: self.message,
            }
        }
    }
}
impl TransactionInProgressError {
    /// Creates a new builder-style object to manufacture [`TransactionInProgressError`](crate::error::TransactionInProgressError)
    pub fn builder() -> crate::error::transaction_in_progress_error::Builder {
        crate::error::transaction_in_progress_error::Builder::default()
    }
}

/// <p>The entire transaction request was canceled.</p>
/// <p>DynamoDB cancels a <code>TransactWriteItems</code> request under the following circumstances:</p>
/// <ul>
/// <li>
/// <p>A condition in one of the condition expressions is not met.</p>
/// </li>
/// <li>
/// <p>A table in the <code>TransactWriteItems</code> request is in a different account or region.</p>
/// </li>
/// <li>
/// <p>More than one action in the <code>TransactWriteItems</code> operation targets the same item.</p>
/// </li>
/// <li>
/// <p>There is insufficient provisioned capacity for the transaction to be completed.</p>
/// </li>
/// <li>
/// <p>An item size becomes too large (larger than 400 KB), or a local secondary index (LSI)
/// becomes too large, or a similar validation error occurs because of changes made by the transaction.</p>
/// </li>
/// <li>
/// <p>There is a user error, such as an invalid data format.</p>
/// </li>
/// </ul>
/// <p>DynamoDB cancels a <code>TransactGetItems</code> request under the following circumstances:</p>
/// <ul>
/// <li>
/// <p>There is an ongoing <code>TransactGetItems</code> operation that conflicts with a concurrent
/// <code>PutItem</code>, <code>UpdateItem</code>, <code>DeleteItem</code> or <code>TransactWriteItems</code> request.
/// In this case the <code>TransactGetItems</code> operation fails with a <code>TransactionCanceledException</code>.</p>
/// </li>
/// <li>
/// <p>A table in the <code>TransactGetItems</code> request is in a different account or region.</p>
/// </li>
/// <li>
/// <p>There is insufficient provisioned capacity for the transaction to be completed.</p>
/// </li>
/// <li>
/// <p>There is a user error, such as an invalid data format.</p>
/// </li>
/// </ul>
/// <note>
/// <p>If using Java, DynamoDB lists the cancellation reasons on the <code>CancellationReasons</code> property.  This property is not set for other languages.
/// Transaction cancellation reasons are ordered in the order of requested items, if an item has no error it will have <code>NONE</code> code and <code>Null</code> message.</p>
/// </note>
/// <p>Cancellation reason codes and possible error messages:</p>
/// <ul>
/// <li>
/// <p>No Errors:</p>
/// <ul>
/// <li>
/// <p>Code: <code>NONE</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: <code>null</code>
/// </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Conditional Check Failed:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ConditionalCheckFailed</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: The conditional request failed. </p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Item Collection Size Limit Exceeded:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ItemCollectionSizeLimitExceeded</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: Collection size exceeded.</p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Transaction Conflict:</p>
/// <ul>
/// <li>
/// <p>Code: <code>TransactionConflict</code>
/// </p>
/// </li>
/// <li>
/// <p>Message: Transaction is ongoing for the item.</p>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Provisioned Throughput Exceeded:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ProvisionedThroughputExceeded</code>
/// </p>
/// </li>
/// <li>
/// <p>Messages: </p>
/// <ul>
/// <li>
/// <p>The level of configured provisioned throughput for the table was exceeded. Consider increasing your provisioning level with the
/// UpdateTable API.</p>
/// <note>
/// <p>This Message is received when provisioned throughput is exceeded is on a provisioned DynamoDB table.</p>
/// </note>
/// </li>
/// <li>
/// <p>The level of configured provisioned throughput for one or more global secondary indexes of the table was exceeded.
/// Consider increasing your provisioning level for the under-provisioned global secondary indexes with the UpdateTable API.</p>
/// <note>
/// <p>This message is returned when provisioned throughput is exceeded is on a provisioned GSI.</p>
/// </note>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Throttling Error:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ThrottlingError</code>
/// </p>
/// </li>
/// <li>
/// <p>Messages: </p>
/// <ul>
/// <li>
/// <p>Throughput exceeds the current capacity of your table or index.
/// DynamoDB is automatically scaling your table or index so please try
/// again shortly. If exceptions persist, check if you have a hot key:
/// https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-design.html.</p>
/// <note>
/// <p>This message is returned when writes get throttled on an On-Demand table as DynamoDB is automatically scaling the table.</p>
/// </note>
/// </li>
/// <li>
/// <p>Throughput exceeds the current capacity for one or more global secondary indexes. DynamoDB is automatically scaling your index so
/// please try again shortly.</p>
/// <note>
/// <p>This message is returned when when writes get throttled on an On-Demand GSI as DynamoDB is automatically scaling the GSI.</p>
/// </note>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// </li>
/// <li>
/// <p>Validation Error:</p>
/// <ul>
/// <li>
/// <p>Code: <code>ValidationError</code>
/// </p>
/// </li>
/// <li>
/// <p>Messages: </p>
/// <ul>
/// <li>
/// <p>One or more parameter values were invalid.</p>
/// </li>
/// <li>
/// <p>The update expression attempted to update the secondary index key beyond allowed size limits.</p>
/// </li>
/// <li>
/// <p>The update expression attempted to update the secondary index key to unsupported type.</p>
/// </li>
/// <li>
/// <p>An operand in the update expression has an incorrect data type.</p>
/// </li>
/// <li>
/// <p>Item size to update has exceeded the maximum allowed size.</p>
/// </li>
/// <li>
/// <p>Number overflow. Attempting to store a number with magnitude larger than supported range.</p>
/// </li>
/// <li>
/// <p>Type mismatch for attribute to update.</p>
/// </li>
/// <li>
/// <p>Nesting Levels have exceeded supported limits.</p>
/// </li>
/// <li>
/// <p>The document path provided in the update expression is invalid for update.</p>
/// </li>
/// <li>
/// <p>The provided expression refers to an attribute that does not exist in the item.</p>
/// </li>
/// </ul>
/// </li>
/// </ul>
/// </li>
/// </ul>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TransactionCanceledError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
    /// <p>A list of cancellation reasons.</p>
    #[serde(rename = "CancellationReasons")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub cancellation_reasons: ::std::option::Option<::std::vec::Vec<CancellationReason>>,
}
impl TransactionCanceledError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "TransactionCanceledException"
    }
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl ::std::fmt::Display for TransactionCanceledError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TransactionCanceledError")?;
        Ok(())
    }
}
impl ::std::error::Error for TransactionCanceledError {}
/// See [`TransactionCanceledError`](crate::error::TransactionCanceledError)
pub mod transaction_canceled_error {

    use crate::error::TransactionCanceledError;
    use crate::model::CancellationReason;
    /// A builder for [`TransactionCanceledError`](crate::error::TransactionCanceledError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
        cancellation_reasons: ::std::option::Option<::std::vec::Vec<CancellationReason>>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// <p>A list of cancellation reasons.</p>
        pub fn cancellation_reasons(mut self, inp: ::std::vec::Vec<CancellationReason>) -> Self {
            self.cancellation_reasons = Some(inp);
            self
        }
        /// Consumes the builder and constructs a [`TransactionCanceledError`](crate::error::TransactionCanceledError)
        pub fn build(self) -> TransactionCanceledError {
            TransactionCanceledError {
                message: self.message,
                cancellation_reasons: self.cancellation_reasons,
            }
        }
    }
}
impl TransactionCanceledError {
    /// Creates a new builder-style object to manufacture [`TransactionCanceledError`](crate::error::TransactionCanceledError)
    pub fn builder() -> crate::error::transaction_canceled_error::Builder {
        crate::error::transaction_canceled_error::Builder::default()
    }
}

/// <p>DynamoDB rejected the request because you retried a request with a different payload but
/// with an idempotent token that was already used.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct IdempotentParameterMismatchError {
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl IdempotentParameterMismatchError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "IdempotentParameterMismatchException"
    }
    pub fn message(&self) -> Option<&str> {
        None
    }
}
impl ::std::fmt::Display for IdempotentParameterMismatchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotentParameterMismatchError")?;
        Ok(())
    }
}
impl ::std::error::Error for IdempotentParameterMismatchError {}
/// See [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
pub mod idempotent_parameter_mismatch_error {

    use crate::error::IdempotentParameterMismatchError;
    /// A builder for [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
        pub fn build(self) -> IdempotentParameterMismatchError {
            IdempotentParameterMismatchError {
                message: self.message,
            }
        }
    }
}
impl IdempotentParameterMismatchError {
    /// Creates a new builder-style object to manufacture [`IdempotentParameterMismatchError`](crate::error::IdempotentParameterMismatchError)
    pub fn builder() -> crate::error::idempotent_parameter_mismatch_error::Builder {
        crate::error::idempotent_parameter_mismatch_error::Builder::default()
    }
}

/// <p>A target table with the specified name is either being created or deleted. </p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TableInUseError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl TableInUseError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "TableInUseException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for TableInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableInUseError")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for TableInUseError {}
/// See [`TableInUseError`](crate::error::TableInUseError)
pub mod table_in_use_error {

    use crate::error::TableInUseError;
    /// A builder for [`TableInUseError`](crate::error::TableInUseError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TableInUseError`](crate::error::TableInUseError)
        pub fn build(self) -> TableInUseError {
            TableInUseError {
                message: self.message,
            }
        }
    }
}
impl TableInUseError {
    /// Creates a new builder-style object to manufacture [`TableInUseError`](crate::error::TableInUseError)
    pub fn builder() -> crate::error::table_in_use_error::Builder {
        crate::error::table_in_use_error::Builder::default()
    }
}

/// <p>A target table with the specified name already exists. </p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct TableAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl TableAlreadyExistsError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "TableAlreadyExistsException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for TableAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TableAlreadyExistsError")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for TableAlreadyExistsError {}
/// See [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
pub mod table_already_exists_error {

    use crate::error::TableAlreadyExistsError;
    /// A builder for [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
        pub fn build(self) -> TableAlreadyExistsError {
            TableAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl TableAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`TableAlreadyExistsError`](crate::error::TableAlreadyExistsError)
    pub fn builder() -> crate::error::table_already_exists_error::Builder {
        crate::error::table_already_exists_error::Builder::default()
    }
}

/// <p>Point in time recovery has not yet been enabled for this source table.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct PointInTimeRecoveryUnavailableError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl PointInTimeRecoveryUnavailableError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "PointInTimeRecoveryUnavailableException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for PointInTimeRecoveryUnavailableError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PointInTimeRecoveryUnavailableError")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for PointInTimeRecoveryUnavailableError {}
/// See [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
pub mod point_in_time_recovery_unavailable_error {

    use crate::error::PointInTimeRecoveryUnavailableError;
    /// A builder for [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
        pub fn build(self) -> PointInTimeRecoveryUnavailableError {
            PointInTimeRecoveryUnavailableError {
                message: self.message,
            }
        }
    }
}
impl PointInTimeRecoveryUnavailableError {
    /// Creates a new builder-style object to manufacture [`PointInTimeRecoveryUnavailableError`](crate::error::PointInTimeRecoveryUnavailableError)
    pub fn builder() -> crate::error::point_in_time_recovery_unavailable_error::Builder {
        crate::error::point_in_time_recovery_unavailable_error::Builder::default()
    }
}

/// <p>An invalid restore time was specified. RestoreDateTime must be between EarliestRestorableDateTime and LatestRestorableDateTime.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct InvalidRestoreTimeError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl InvalidRestoreTimeError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "InvalidRestoreTimeException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidRestoreTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRestoreTimeError")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidRestoreTimeError {}
/// See [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
pub mod invalid_restore_time_error {

    use crate::error::InvalidRestoreTimeError;
    /// A builder for [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
        pub fn build(self) -> InvalidRestoreTimeError {
            InvalidRestoreTimeError {
                message: self.message,
            }
        }
    }
}
impl InvalidRestoreTimeError {
    /// Creates a new builder-style object to manufacture [`InvalidRestoreTimeError`](crate::error::InvalidRestoreTimeError)
    pub fn builder() -> crate::error::invalid_restore_time_error::Builder {
        crate::error::invalid_restore_time_error::Builder::default()
    }
}

/// <p>Backup not found for the given BackupARN. </p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct BackupNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl BackupNotFoundError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "BackupNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for BackupNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupNotFoundError")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for BackupNotFoundError {}
/// See [`BackupNotFoundError`](crate::error::BackupNotFoundError)
pub mod backup_not_found_error {

    use crate::error::BackupNotFoundError;
    /// A builder for [`BackupNotFoundError`](crate::error::BackupNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`BackupNotFoundError`](crate::error::BackupNotFoundError)
        pub fn build(self) -> BackupNotFoundError {
            BackupNotFoundError {
                message: self.message,
            }
        }
    }
}
impl BackupNotFoundError {
    /// Creates a new builder-style object to manufacture [`BackupNotFoundError`](crate::error::BackupNotFoundError)
    pub fn builder() -> crate::error::backup_not_found_error::Builder {
        crate::error::backup_not_found_error::Builder::default()
    }
}

/// <p>There is another ongoing conflicting backup control plane operation on the table. The backup is either being created, deleted or restored to a table.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct BackupInUseError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl BackupInUseError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "BackupInUseException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for BackupInUseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BackupInUseError")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for BackupInUseError {}
/// See [`BackupInUseError`](crate::error::BackupInUseError)
pub mod backup_in_use_error {

    use crate::error::BackupInUseError;
    /// A builder for [`BackupInUseError`](crate::error::BackupInUseError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`BackupInUseError`](crate::error::BackupInUseError)
        pub fn build(self) -> BackupInUseError {
            BackupInUseError {
                message: self.message,
            }
        }
    }
}
impl BackupInUseError {
    /// Creates a new builder-style object to manufacture [`BackupInUseError`](crate::error::BackupInUseError)
    pub fn builder() -> crate::error::backup_in_use_error::Builder {
        crate::error::backup_in_use_error::Builder::default()
    }
}

/// <p>The specified <code>ExportTime</code> is outside of the point in time recovery
/// window.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct InvalidExportTimeError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl InvalidExportTimeError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "InvalidExportTimeException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for InvalidExportTimeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidExportTimeError")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for InvalidExportTimeError {}
/// See [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
pub mod invalid_export_time_error {

    use crate::error::InvalidExportTimeError;
    /// A builder for [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
        pub fn build(self) -> InvalidExportTimeError {
            InvalidExportTimeError {
                message: self.message,
            }
        }
    }
}
impl InvalidExportTimeError {
    /// Creates a new builder-style object to manufacture [`InvalidExportTimeError`](crate::error::InvalidExportTimeError)
    pub fn builder() -> crate::error::invalid_export_time_error::Builder {
        crate::error::invalid_export_time_error::Builder::default()
    }
}

/// <p>There was a conflict when writing to the specified S3 bucket.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ExportConflictError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ExportConflictError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "ExportConflictException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ExportConflictError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExportConflictError")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ExportConflictError {}
/// See [`ExportConflictError`](crate::error::ExportConflictError)
pub mod export_conflict_error {

    use crate::error::ExportConflictError;
    /// A builder for [`ExportConflictError`](crate::error::ExportConflictError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ExportConflictError`](crate::error::ExportConflictError)
        pub fn build(self) -> ExportConflictError {
            ExportConflictError {
                message: self.message,
            }
        }
    }
}
impl ExportConflictError {
    /// Creates a new builder-style object to manufacture [`ExportConflictError`](crate::error::ExportConflictError)
    pub fn builder() -> crate::error::export_conflict_error::Builder {
        crate::error::export_conflict_error::Builder::default()
    }
}

/// <p>
/// There was an attempt to insert an item with the same primary key as an item that already exists in the DynamoDB table.
/// </p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct DuplicateItemError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl DuplicateItemError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "DuplicateItemException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for DuplicateItemError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DuplicateItemError")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for DuplicateItemError {}
/// See [`DuplicateItemError`](crate::error::DuplicateItemError)
pub mod duplicate_item_error {

    use crate::error::DuplicateItemError;
    /// A builder for [`DuplicateItemError`](crate::error::DuplicateItemError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`DuplicateItemError`](crate::error::DuplicateItemError)
        pub fn build(self) -> DuplicateItemError {
            DuplicateItemError {
                message: self.message,
            }
        }
    }
}
impl DuplicateItemError {
    /// Creates a new builder-style object to manufacture [`DuplicateItemError`](crate::error::DuplicateItemError)
    pub fn builder() -> crate::error::duplicate_item_error::Builder {
        crate::error::duplicate_item_error::Builder::default()
    }
}

/// <p>The specified export was not found.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct ExportNotFoundError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl ExportNotFoundError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "ExportNotFoundException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ExportNotFoundError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ExportNotFoundError")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for ExportNotFoundError {}
/// See [`ExportNotFoundError`](crate::error::ExportNotFoundError)
pub mod export_not_found_error {

    use crate::error::ExportNotFoundError;
    /// A builder for [`ExportNotFoundError`](crate::error::ExportNotFoundError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`ExportNotFoundError`](crate::error::ExportNotFoundError)
        pub fn build(self) -> ExportNotFoundError {
            ExportNotFoundError {
                message: self.message,
            }
        }
    }
}
impl ExportNotFoundError {
    /// Creates a new builder-style object to manufacture [`ExportNotFoundError`](crate::error::ExportNotFoundError)
    pub fn builder() -> crate::error::export_not_found_error::Builder {
        crate::error::export_not_found_error::Builder::default()
    }
}

/// <p>The specified global table already exists.</p>
#[non_exhaustive]
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    ::std::clone::Clone,
    ::std::cmp::PartialEq,
    ::std::fmt::Debug,
)]
pub struct GlobalTableAlreadyExistsError {
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub message: ::std::option::Option<::std::string::String>,
}
impl GlobalTableAlreadyExistsError {
    pub fn retryable(&self) -> bool {
        false
    }
    pub fn throttling(&self) -> bool {
        false
    }
    pub fn code(&self) -> &str {
        "GlobalTableAlreadyExistsException"
    }
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for GlobalTableAlreadyExistsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GlobalTableAlreadyExistsError")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl ::std::error::Error for GlobalTableAlreadyExistsError {}
/// See [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
pub mod global_table_already_exists_error {

    use crate::error::GlobalTableAlreadyExistsError;
    /// A builder for [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
    #[non_exhaustive]
    #[derive(Debug, Clone, Default)]
    pub struct Builder {
        message: ::std::option::Option<::std::string::String>,
    }
    impl Builder {
        pub fn message(mut self, inp: impl Into<::std::string::String>) -> Self {
            self.message = Some(inp.into());
            self
        }
        /// Consumes the builder and constructs a [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
        pub fn build(self) -> GlobalTableAlreadyExistsError {
            GlobalTableAlreadyExistsError {
                message: self.message,
            }
        }
    }
}
impl GlobalTableAlreadyExistsError {
    /// Creates a new builder-style object to manufacture [`GlobalTableAlreadyExistsError`](crate::error::GlobalTableAlreadyExistsError)
    pub fn builder() -> crate::error::global_table_already_exists_error::Builder {
        crate::error::global_table_already_exists_error::Builder::default()
    }
}
