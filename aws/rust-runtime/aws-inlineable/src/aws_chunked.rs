// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

#![allow(dead_code)]

use aws_runtime::{
    auth::PayloadSigningOverride,
    content_encoding::{
        header_value::AWS_CHUNKED, AwsChunkedBody, AwsChunkedBodyOptions, DeferredSigner,
    },
};
use aws_smithy_checksums::http::HttpChecksum;
use aws_smithy_runtime_api::{
    box_error::BoxError,
    client::{
        interceptors::{context::BeforeTransmitInterceptorContextMut, Intercept},
        runtime_components::RuntimeComponents,
    },
};
use aws_smithy_types::{body::SdkBody, config_bag::ConfigBag, error::operation::BuildError};
use http_1x::HeaderValue;
use http_body_1x::Body;

use crate::presigning::PresigningMarker;

#[derive(Debug)]
pub(crate) struct AwsChunkedContentEncodingInterceptor;

impl Intercept for AwsChunkedContentEncodingInterceptor {
    fn name(&self) -> &'static str {
        "AwsChunkedContentEncodingInterceptor"
    }

    fn modify_before_signing(
        &self,
        context: &mut BeforeTransmitInterceptorContextMut<'_>,
        _runtime_components: &RuntimeComponents,
        cfg: &mut ConfigBag,
    ) -> Result<(), BoxError> {
        if cfg.load::<PresigningMarker>().is_some() {
            // Presigning, no need to apply aws-chunked encoding
            return Ok(());
        }

        // Let TLS handle encryption, and we only need explicit signing when using HTTP
        let sign_during_aws_chunked_encoding = context.request().uri().starts_with("http:");

        if context
            .request()
            .headers()
            .contains_key(http_1x::header::HeaderName::from_static("x-amz-trailer"))
        {
            if sign_during_aws_chunked_encoding {
                let (signer, sender) = DeferredSigner::new();
                cfg.interceptor_state().store_put(signer);
                cfg.interceptor_state().store_put(sender);
                cfg.interceptor_state()
                    .store_put(PayloadSigningOverride::StreamingSignedPayloadTrailer);
            } else {
                cfg.interceptor_state()
                    .store_put(PayloadSigningOverride::StreamingUnsignedPayloadTrailer);
            }
        }

        let request = context.request_mut();

        let original_body_size = match request
            .headers()
            .get(http_1x::header::CONTENT_LENGTH)
            .and_then(|s| s.parse::<u64>().ok())
            .or_else(|| request.body().size_hint().exact())
        {
            Some(size) => Some(size),
            _ => {
                return Err(BuildError::other(
                    crate::http_request_checksum::Error::UnsizedRequestBody,
                ))?
            }
        };

        // For streaming case, we set x-amz-decoded-content-length and content-length headers
        if let Some(size) = original_body_size {
            if request.body().bytes().is_none() {
                let state = cfg
                    .load::<crate::http_request_checksum::RequestChecksumInterceptorState>()
                    .clone()
                    .expect("state set");
                let checksum_algorithm = state.checksum_algorithm().clone().unwrap();
                let checksum = checksum_algorithm.into_impl();
                let trailer_len = HttpChecksum::size(checksum.as_ref());
                let mut opt = AwsChunkedBodyOptions::new(size, vec![trailer_len]);
                let encoded_content_length = if sign_during_aws_chunked_encoding {
                    opt = opt.with_trailer_len(88); // 88 is the length of the signature trailer
                    opt.signed_encoded_length()
                } else {
                    opt.encoded_length()
                };
                request.headers_mut().insert(
                    http::header::CONTENT_LENGTH,
                    HeaderValue::from(encoded_content_length),
                );

                request.headers_mut().insert(
                    http_1x::header::HeaderName::from_static("x-amz-decoded-content-length"),
                    HeaderValue::from(size),
                );

                request.headers_mut().append(
                    http_1x::header::CONTENT_ENCODING,
                    HeaderValue::from_str(AWS_CHUNKED)
                        .map_err(BuildError::other)
                        .expect("\"aws-chunked\" will always be a valid HeaderValue"),
                );

                request
                    .headers_mut()
                    .remove(http_1x::header::TRANSFER_ENCODING);

                cfg.interceptor_state().store_put(opt);
            }
        }

        Ok(())
    }

    fn modify_before_transmit(
        &self,
        ctx: &mut BeforeTransmitInterceptorContextMut<'_>,
        _runtime_components: &RuntimeComponents,
        cfg: &mut ConfigBag,
    ) -> Result<(), BoxError> {
        if ctx.request().body().bytes().is_some() {
            // Not a streaming body, no need to apply aws-chunked encoding
            return Ok(());
        }

        if cfg.load::<PresigningMarker>().is_some() {
            // Presigning, no need to apply aws-chunked encoding
            return Ok(());
        }

        let request = ctx.request_mut();

        let mut body = {
            let body = std::mem::replace(request.body_mut(), SdkBody::taken());
            let opt = cfg
                .get_mut_from_interceptor_state::<AwsChunkedBodyOptions>()
                .ok_or_else(|| {
                    BuildError::other("AwsChunkedBodyOptions missing from config bag")
                })?;
            let aws_chunked_body_options = std::mem::take(opt);
            let body = AwsChunkedBody::new(body, aws_chunked_body_options);

            let body = match cfg.get_mut_from_interceptor_state::<DeferredSigner>() {
                Some(signer) => {
                    let signer = std::mem::replace(signer, DeferredSigner::empty());
                    body.with_signer(signer)
                }
                None => body,
            };

            SdkBody::from_body_1_x(body)
        };

        std::mem::swap(request.body_mut(), &mut body);

        Ok(())
    }
}
