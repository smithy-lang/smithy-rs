// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

#![allow(dead_code)]

use std::{
    ops::DerefMut,
    sync::{Arc, Mutex},
};

use aws_runtime::{
    auth::PayloadSigningOverride,
    content_encoding::{
        header_value::AWS_CHUNKED, AwsChunkedBody, AwsChunkedBodyOptions, DeferredSigner,
    },
};
use aws_sigv4::http_request::SigningError;
use aws_smithy_checksums::http::HttpChecksum;
use aws_smithy_runtime_api::{
    box_error::BoxError,
    client::{
        interceptors::{context::BeforeTransmitInterceptorContextMut, Intercept},
        runtime_components::RuntimeComponents,
    },
};
use aws_smithy_types::{body::SdkBody, config_bag::ConfigBag, error::operation::BuildError};
use http_1x::{header::TRANSFER_ENCODING, HeaderValue};
use http_body_1x::Body;

use crate::presigning::PresigningMarker;

#[derive(Debug)]
pub(crate) struct AwsChunkedContentEncodingInterceptor {
    requires_length: bool, // ideally, this value should come from the trait, but we set this to true for PutObject
    body_options: Arc<Mutex<AwsChunkedBodyOptions>>,
}

impl AwsChunkedContentEncodingInterceptor {
    pub(crate) fn new(requires_length: bool) -> Self {
        Self {
            requires_length,
            body_options: Arc::new(Mutex::new(AwsChunkedBodyOptions::default())),
        }
    }
}

impl Intercept for AwsChunkedContentEncodingInterceptor {
    fn name(&self) -> &'static str {
        "AwsChunkedContentEncodingInterceptor"
    }

    fn modify_before_signing(
        &self,
        context: &mut BeforeTransmitInterceptorContextMut<'_>,
        _runtime_components: &RuntimeComponents,
        cfg: &mut ConfigBag,
    ) -> Result<(), BoxError> {
        if cfg.load::<PresigningMarker>().is_some() {
            // Presigning, no need to apply aws-chunked encoding
            return Ok(());
        }

        if context
            .request()
            .headers()
            .contains_key(http_1x::header::HeaderName::from_static("x-amz-trailer"))
        {
            let _over_tls = true; // TODO: determine if connection is over TLS
                                  /*
                                  if _over_tls && cfg.load::<PayloadSigningOverride>().is_none() {
                                      let (signer, sender) = DeferredSigner::new();
                                      cfg.interceptor_state().store_put(signer);
                                      cfg.interceptor_state().store_put(sender);
                                      cfg.interceptor_state().store_put(PayloadSigningOverride::StreamingSignedPayloadTrailer);
                                  } else {
                                   */
            cfg.interceptor_state()
                .store_put(PayloadSigningOverride::StreamingUnsignedPayloadTrailer);
            //}
        }

        let request = context.request_mut();

        let original_body_size = match request
            .headers()
            .get(http_1x::header::CONTENT_LENGTH)
            .and_then(|s| s.parse::<u64>().ok())
            .or_else(|| request.body().size_hint().exact())
        {
            Some(size) => Some(size),
            None if self.requires_length => {
                return Err(BuildError::other(
                    crate::http_request_checksum::Error::UnsizedRequestBody,
                ))?;
            }
            // It's ok to not have a length if `requires_length` is false
            _ => None,
        };

        // For streaming case, we set x-amz-decoded-content-length and content-length headers
        if let Some(size) = original_body_size {
            if request.body().bytes().is_none() {
                let state = cfg
                    .load::<crate::http_request_checksum::RequestChecksumInterceptorState>()
                    .clone()
                    .expect("state set");
                let checksum_algorithm = state.checksum_algorithm().clone().unwrap();
                let checksum = checksum_algorithm.into_impl();
                let trailer_len = HttpChecksum::size(checksum.as_ref());
                let opt = AwsChunkedBodyOptions::new(size, vec![trailer_len]);
                let encoded_content_length = opt.encoded_length();
                request.headers_mut().insert(
                    http::header::CONTENT_LENGTH,
                    HeaderValue::from(encoded_content_length),
                );

                request.headers_mut().insert(
                    http_1x::header::HeaderName::from_static("x-amz-decoded-content-length"),
                    HeaderValue::from(size),
                );

                request
                    .headers_mut()
                    .remove(http_1x::header::TRANSFER_ENCODING);

                *self.body_options.lock().unwrap() = opt;
            }
        }

        Ok(())
    }

    fn modify_before_transmit(
        &self,
        ctx: &mut BeforeTransmitInterceptorContextMut<'_>,
        _runtime_components: &RuntimeComponents,
        cfg: &mut ConfigBag,
    ) -> Result<(), BoxError> {
        if ctx.request().body().bytes().is_some() {
            // Not a streaming body, no need to apply aws-chunked encoding
            return Ok(());
        }

        if cfg.load::<PresigningMarker>().is_some() {
            // Presigning, no need to apply aws-chunked encoding
            return Ok(());
        }

        let request = ctx.request_mut();

        let mut body = {
            let body = std::mem::replace(request.body_mut(), SdkBody::taken());
            let aws_chunked_body_options = std::mem::replace(
                self.body_options.lock().unwrap().deref_mut(),
                AwsChunkedBodyOptions::default(),
            );
            let body = AwsChunkedBody::new(body, aws_chunked_body_options);

            let body = match cfg.get_mut_from_interceptor_state::<DeferredSigner>() {
                Some(signer) => {
                    let signer = std::mem::replace(signer, DeferredSigner::empty());
                    body.with_signer(signer)
                }
                None => body,
            };

            SdkBody::from_body_1_x(body)
        };

        request.headers_mut().append(
            http_1x::header::CONTENT_ENCODING,
            HeaderValue::from_str(AWS_CHUNKED)
                .map_err(BuildError::other)
                .expect("\"aws-chunked\" will always be a valid HeaderValue"),
        );

        std::mem::swap(request.body_mut(), &mut body);

        Ok(())
    }
}
