// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

#![allow(dead_code)]

use std::vec;

use aws_runtime::{
    auth::PayloadSigningOverride,
    content_encoding::{
        header_value::AWS_CHUNKED, AwsChunkedBody, AwsChunkedBodyOptions, DeferredSigner,
    },
};
use aws_smithy_checksums::{http::HttpChecksum, ChecksumAlgorithm};
use aws_smithy_runtime_api::{
    box_error::BoxError,
    client::{
        interceptors::{context::BeforeTransmitInterceptorContextMut, Intercept},
        runtime_components::RuntimeComponents,
    },
};
use aws_smithy_types::{body::SdkBody, config_bag::ConfigBag, error::operation::BuildError};
use http_1x::HeaderValue;
use http_body_1x::Body;

use crate::presigning::PresigningMarker;

const X_AMZ_TRAILER_SIGNATURE: &str = "x-amz-trailer-signature";
const TRAILER_SEPARATOR: &[u8] = b":";
const SIGNATURE_VALUE_LENGTH: usize = 64;

#[derive(Debug)]
pub(crate) struct AwsChunkedContentEncodingInterceptor;

impl Intercept for AwsChunkedContentEncodingInterceptor {
    fn name(&self) -> &'static str {
        "AwsChunkedContentEncodingInterceptor"
    }

    fn modify_before_signing(
        &self,
        context: &mut BeforeTransmitInterceptorContextMut<'_>,
        _runtime_components: &RuntimeComponents,
        cfg: &mut ConfigBag,
    ) -> Result<(), BoxError> {
        if context.request().body().bytes().is_some() {
            return Ok(());
        }

        let state = cfg
            .load::<crate::http_request_checksum::RequestChecksumInterceptorState>()
            .expect("state set");
        if !state.calculate_checksum() {
            return Ok(());
        }

        let original_body_size = if let Some(size) = context
            .request()
            .headers()
            .get(http_1x::header::CONTENT_LENGTH)
            .and_then(|s| s.parse::<u64>().ok())
            .or_else(|| context.request().body().size_hint().exact())
        {
            size
        } else {
            return Err(BuildError::other(
                crate::http_request_checksum::Error::UnsizedRequestBody,
            ))?;
        };

        let sign_during_aws_chunked_encoding = context.request().uri().starts_with("http:");
        let chunked_boty_options = create_chunked_body_options(
            state.checksum_algorithm(),
            sign_during_aws_chunked_encoding,
            original_body_size,
            cfg,
        );

        let request = context.request_mut();

        request.headers_mut().insert(
            http::header::CONTENT_LENGTH,
            HeaderValue::from(chunked_boty_options.encoded_length()),
        );

        request.headers_mut().insert(
            http_1x::header::HeaderName::from_static("x-amz-decoded-content-length"),
            HeaderValue::from(original_body_size),
        );

        request.headers_mut().append(
            http_1x::header::CONTENT_ENCODING,
            HeaderValue::from_str(AWS_CHUNKED)
                .map_err(BuildError::other)
                .expect("\"aws-chunked\" will always be a valid HeaderValue"),
        );

        request
            .headers_mut()
            .remove(http_1x::header::TRANSFER_ENCODING);

        cfg.interceptor_state().store_put(chunked_boty_options);

        Ok(())
    }

    fn modify_before_transmit(
        &self,
        ctx: &mut BeforeTransmitInterceptorContextMut<'_>,
        _runtime_components: &RuntimeComponents,
        cfg: &mut ConfigBag,
    ) -> Result<(), BoxError> {
        if ctx.request().body().bytes().is_some() {
            return Ok(());
        }

        let state = cfg
            .load::<crate::http_request_checksum::RequestChecksumInterceptorState>()
            .expect("state set");
        if !state.calculate_checksum() {
            return Ok(());
        }

        let request = ctx.request_mut();

        let mut body = {
            let body = std::mem::replace(request.body_mut(), SdkBody::taken());
            let opt = cfg
                .get_mut_from_interceptor_state::<AwsChunkedBodyOptions>()
                .ok_or_else(|| {
                    BuildError::other("AwsChunkedBodyOptions missing from config bag")
                })?;
            let aws_chunked_body_options = std::mem::take(opt);
            let body = AwsChunkedBody::new(body, aws_chunked_body_options);

            let body = match cfg.get_mut_from_interceptor_state::<DeferredSigner>() {
                Some(signer) => {
                    let signer = std::mem::replace(signer, DeferredSigner::empty());
                    body.with_signer(signer)
                }
                None => body,
            };

            SdkBody::from_body_1_x(body)
        };

        std::mem::swap(request.body_mut(), &mut body);

        Ok(())
    }
}

fn create_chunked_body_options(
    checksum_algorithm: Option<ChecksumAlgorithm>,
    sign_during_aws_chunked_encoding: bool,
    original_body_size: u64,
    cfg: &mut ConfigBag,
) -> AwsChunkedBodyOptions {
    // Let TLS handle encryption, and we only need explicit signing when using HTTP
    if sign_during_aws_chunked_encoding {
        let (signer, sender) = DeferredSigner::new();
        cfg.interceptor_state().store_put(signer);
        cfg.interceptor_state().store_put(sender);
        cfg.interceptor_state()
            .store_put(PayloadSigningOverride::StreamingSignedPayloadTrailer);
    } else {
        cfg.interceptor_state()
            .store_put(PayloadSigningOverride::StreamingUnsignedPayloadTrailer);
    }

    let chunked_body_options = AwsChunkedBodyOptions::new(original_body_size, vec![])
        .signed_chunked_encoding(sign_during_aws_chunked_encoding);

    if let Some(alg) = checksum_algorithm {
        let checksum = alg.into_impl();
        let trailer_len = HttpChecksum::size(checksum.as_ref());
        if sign_during_aws_chunked_encoding {
            chunked_body_options
                .with_trailer_len(trailer_len)
                .with_trailer_len(
                    (X_AMZ_TRAILER_SIGNATURE.len()
                        + TRAILER_SEPARATOR.len()
                        + SIGNATURE_VALUE_LENGTH) as u64,
                )
        } else {
            chunked_body_options.with_trailer_len(trailer_len)
        }
    } else {
        chunked_body_options
    }
}
