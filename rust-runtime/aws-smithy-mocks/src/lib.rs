/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

//! # aws-smithy-mocks
//!
//! A flexible mocking framework for testing clients generated by smithy-rs, including all packages of the AWS SDK for Rust.
//!
//! This crate provides a simple yet powerful way to mock SDK client responses for testing purposes.
//! It uses interceptors to return stub responses, allowing you to test both happy-path and error scenarios
//! without mocking the entire client or using traits.
//!
//! ## Key Features
//!
//! - **Simple API**: Create mock rules with a fluent API using the [`mock!`] macro
//! - **Flexible Response Types**: Return modeled outputs, errors, or raw HTTP responses
//! - **Request Matching**: Match requests based on their properties
//! - **Response Sequencing**: Define sequences of responses for testing retry behavior
//! - **Rule Modes**: Control how rules are matched and applied
//!
//! ## Basic Usage
//!
//! ```rust,ignore
//! use aws_sdk_s3::operation::get_object::GetObjectOutput;
//! use aws_sdk_s3::Client;
//! use aws_smithy_types::byte_stream::ByteStream;
//! use aws_smithy_mocks::{mock, mock_client};
//!
//! #[tokio::test]
//! async fn test_s3_get_object() {
//!     // Create a rule that returns a successful response
//!     let get_object_rule = mock!(Client::get_object)
//!         .match_requests(|req| req.bucket() == Some("test-bucket") && req.key() == Some("test-key"))
//!         .then_output(|| GetObjectOutput::builder()
//!             .body(ByteStream::from_static(b"test-content"))
//!             .build());
//!     
//!     // Create a mocked client with the rule
//!     let s3 = mock_client!(aws_sdk_s3, [&get_object_rule]);
//!     
//!     // Use the client as you would normally
//!     let result = s3.get_object()
//!         .bucket("test-bucket")
//!         .key("test-key")
//!         .send()
//!         .await
//!         .expect("success response");
//!     
//!     // Verify the response
//!     let data = result.body.collect().await.expect("successful read").to_vec();
//!     assert_eq!(data, b"test-content");
//!     
//!     // Verify the rule was used
//!     assert_eq!(get_object_rule.num_calls(), 1);
//! }
//! ```
//!
//! ## Creating Rules
//!
//! Rules are created using the [`mock!`] macro, which takes a client operation as an argument:
//!
//! ```rust,ignore
//! let rule = mock!(Client::get_object)
//!     // Optional: Add a matcher to filter requests
//!     .match_requests(|req| req.bucket() == Some("test-bucket"))
//!     // Add a response
//!     .then_output(|| GetObjectOutput::builder().build());
//! ```
//!
//! ### Response Types
//!
//! You can return different types of responses:
//!
//! ```rust,ignore
//! // Return a modeled output
//! let success_rule = mock!(Client::get_object)
//!     .then_output(|| GetObjectOutput::builder().build());
//!
//! // Return a modeled error
//! let error_rule = mock!(Client::get_object)
//!     .then_error(|| GetObjectError::NoSuchKey(NoSuchKey::builder().build()));
//!
//! // Return an HTTP response
//! let http_rule = mock!(Client::get_object)
//!     .then_http_response(|| HttpResponse::new(
//!         StatusCode::try_from(503).unwrap(),
//!         SdkBody::from("service unavailable")
//!     ));
//! ```
//!
//! ### Response Sequences
//!
//! For testing retry behavior or complex scenarios, you can define sequences of responses using the [`serve`](RuleBuilder::serve) method:
//!
//! ```rust,ignore
//! let retry_rule = mock!(Client::get_object)
//!     .serve(|idx| match idx {
//!         0 | 1 => Some(mock_response!(status: 503)),  // First two calls return 503
//!         2 => Some(mock_response!(GetObjectOutput::builder().build())),  // Third call succeeds
//!         _ => None  // No more responses
//!     });
//! ```
//!
//! The `serve` method takes a closure that receives the call index and returns an optional response.
//! When the closure returns `None`, the rule is considered exhausted.
//!
//! ## Creating Mocked Clients
//!
//! Use the [`mock_client!`] macro to create a client with your rules:
//!
//! ```rust,ignore
//! // Create a client with a single rule
//! let client = mock_client!(aws_sdk_s3, [&rule]);
//!
//! // Create a client with multiple rules and a specific rule mode
//! let client = mock_client!(aws_sdk_s3, RuleMode::Sequential, [&rule1, &rule2]);
//!
//! // Create a client with additional configuration
//! let client = mock_client!(
//!     aws_sdk_s3,
//!     RuleMode::Sequential,
//!     [&rule],
//!     |config| config.force_path_style(true)
//! );
//! ```
//!
//! ## Rule Modes
//!
//! The [`RuleMode`] enum controls how rules are matched and applied:
//!
//! - `RuleMode::Sequential`: Rules are tried in order. When a rule is exhausted, the next rule is used.
//! - `RuleMode::MatchAny`: The first matching rule is used, regardless of order.
//!
//! ```rust,ignore
//! let interceptor = MockResponseInterceptor::new()
//!     .rule_mode(RuleMode::Sequential)
//!     .with_rule(&rule1)
//!     .with_rule(&rule2);
//! ```
//!
//! ## Testing Retry Behavior
//!
//! The mocking framework supports testing retry behavior by allowing you to define sequences of responses:
//!
//! ```rust,ignore
//! #[tokio::test]
//! async fn test_retry() {
//!     // Create a rule that returns errors for the first two attempts, then succeeds
//!     let rule = mock!(Client::get_object)
//!         .serve(|idx| match idx {
//!             0 | 1 => Some(mock_response!(status: 503)),  // Service unavailable
//!             2 => Some(mock_response!(GetObjectOutput::builder().build())),  // Success
//!             _ => None
//!         });
//!     
//!     // Create a client with retry enabled
//!     let client = mock_client!(aws_sdk_s3, [&rule]);
//!     
//!     // The operation should succeed after retries
//!     let result = client.get_object()
//!         .bucket("test-bucket")
//!         .key("test-key")
//!         .send()
//!         .await;
//!     
//!     assert!(result.is_ok());
//!     assert_eq!(rule.num_calls(), 3);  // Called 3 times (2 failures + 1 success)
//! }
//! ```
//!

/* Automatically managed default lints */
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
/* End of automatically managed default lints */
#![warn(
    missing_docs,
    rustdoc::missing_crate_level_docs,
    unreachable_pub,
    rust_2018_idioms
)]

use std::collections::VecDeque;
use std::sync::{Arc, Mutex};
use std::{fmt, panic};

use aws_smithy_http_client::test_util::infallible_client_fn;
use aws_smithy_runtime_api::box_error::BoxError;
use aws_smithy_runtime_api::client::http::SharedHttpClient;
use aws_smithy_runtime_api::client::interceptors::context::{
    BeforeSerializationInterceptorContextMut, BeforeTransmitInterceptorContextMut, Error,
    FinalizerInterceptorContextMut, Output,
};
use aws_smithy_runtime_api::client::interceptors::Intercept;
use aws_smithy_runtime_api::client::orchestrator::{HttpResponse, OrchestratorError};
use aws_smithy_runtime_api::client::runtime_components::RuntimeComponents;
use aws_smithy_types::body::SdkBody;
use aws_smithy_types::config_bag::{ConfigBag, Storable, StoreReplace};

mod response;
mod rule;

pub use response::MockResponse;
pub use rule::{Rule, RuleBuilder, RuleMode};

// why do we need a macro for this?
// We want customers to be able to provide an ergonomic way to say the method they're looking for,
// `Client::list_buckets`, e.g. But there isn't enough information on that type to recover everything.
// This macro commits a small amount of crimes to recover that type information so we can construct
// a rule that can intercept these operations.

/// `mock!` macro that produces a [`RuleBuilder`] from a client invocation
///
/// See the `examples` folder of this crate for fully worked examples.
///
/// # Examples
/// **Mock and return a success response**:
/// ```rust,ignore
/// use aws_sdk_s3::operation::get_object::GetObjectOutput;
/// use aws_sdk_s3::Client;
/// use aws_smithy_types::byte_stream::ByteStream;
/// use aws_smithy_mocks::mock;
/// let get_object_happy_path = mock!(Client::get_object)
///   .match_requests(|req|req.bucket() == Some("test-bucket") && req.key() == Some("test-key"))
///   .then_output(||GetObjectOutput::builder().body(ByteStream::from_static(b"12345-abcde")).build());
/// ```
///
/// **Mock and return an error**:
/// ```rust,ignore
/// use aws_sdk_s3::operation::get_object::GetObjectError;
/// use aws_sdk_s3::types::error::NoSuchKey;
/// use aws_sdk_s3::Client;
/// use aws_smithy_mocks::mock;
/// let get_object_error_path = mock!(Client::get_object)
///   .then_error(||GetObjectError::NoSuchKey(NoSuchKey::builder().build()));
/// ```
#[macro_export]
macro_rules! mock {
    ($operation: expr) => {
        #[allow(unreachable_code)]
        {
            $crate::RuleBuilder::new_from_mock(
                // We don't actually want to run this code, so we put it in a closure. The closure
                // has the types we want which makes this whole thing type-safe (and the IDE can even
                // figure out the right input/output types in inference!)
                // The code generated here is:
                // `Client::list_buckets(todo!())`
                || $operation(todo!()).as_input().clone().build().unwrap(),
                || $operation(todo!()).send(),
            )
        }
    };
}

// This could be obviated by a reasonable trait, since you can express it with SdkConfig if clients implement From<&SdkConfig>.

/// `mock_client!` macro produces a Client configured with a number of Rules and appropriate test default configuration.
///
/// # Examples
/// **Create a client that uses a mock failure and then a success**:
/// rust,ignore
/// use aws_sdk_s3::operation::get_object::{GetObjectOutput, GetObjectError};
/// use aws_sdk_s3::types::error::NoSuchKey;
/// use aws_sdk_s3::Client;
/// use aws_smithy_types::byte_stream::ByteStream;
/// use aws_smithy_mocks::{mock_client, mock, RuleMode};
/// let get_object_error_path = mock!(Client::get_object)
///   .then_error(||GetObjectError::NoSuchKey(NoSuchKey::builder().build()))
///   .build();
/// let get_object_happy_path = mock!(Client::get_object)
///   .match_requests(|req|req.bucket() == Some("test-bucket") && req.key() == Some("test-key"))
///   .then_output(||GetObjectOutput::builder().body(ByteStream::from_static(b"12345-abcde")).build())
///   .build();
/// let client = mock_client!(aws_sdk_s3, RuleMode::Sequential, &[&get_object_error_path, &get_object_happy_path]);
///
///
/// **Create a client but customize a specific setting**:
/// rust,ignore
/// use aws_sdk_s3::operation::get_object::GetObjectOutput;
/// use aws_sdk_s3::Client;
/// use aws_smithy_types::byte_stream::ByteStream;
/// use aws_smithy_mocks::{mock_client, mock, RuleMode};
/// let get_object_happy_path = mock!(Client::get_object)
///   .match_requests(|req|req.bucket() == Some("test-bucket") && req.key() == Some("test-key"))
///   .then_output(||GetObjectOutput::builder().body(ByteStream::from_static(b"12345-abcde")).build())
///   .build();
/// let client = mock_client!(
///     aws_sdk_s3,
///     RuleMode::Sequential,
///     &[&get_object_happy_path],
///     // Perhaps you need to force path style
///     |client_builder|client_builder.force_path_style(true)
/// );
///
#[macro_export]
macro_rules! mock_client {
    ($aws_crate: ident, $rules: expr) => {
        $crate::mock_client!($aws_crate, $crate::RuleMode::Sequential, $rules)
    };
    ($aws_crate: ident, $rule_mode: expr, $rules: expr) => {{
        $crate::mock_client!($aws_crate, $rule_mode, $rules, |conf| conf)
    }};
    ($aws_crate: ident, $rule_mode: expr, $rules: expr, $additional_configuration: expr) => {{
        let mut mock_response_interceptor =
            $crate::MockResponseInterceptor::new().rule_mode($rule_mode);
        for rule in $rules {
            mock_response_interceptor = mock_response_interceptor.with_rule(rule)
        }

        // Create a mock HTTP client
        let mock_http_client = $crate::create_mock_http_client();

        // Allow callers to avoid explicitly specifying the type
        fn coerce<T: Fn($aws_crate::config::Builder) -> $aws_crate::config::Builder>(f: T) -> T {
            f
        }

        $aws_crate::client::Client::from_conf(
            coerce($additional_configuration)(
                $aws_crate::config::Config::builder()
                    .with_test_defaults()
                    .region($aws_crate::config::Region::from_static("us-east-1"))
                    .http_client(mock_http_client)
                    .interceptor(mock_response_interceptor),
            )
            .build(),
        )
    }};
}

// Store active rule in config bag
#[derive(Debug, Clone)]
struct ActiveRule(Rule);

impl Storable for ActiveRule {
    type Storer = StoreReplace<ActiveRule>;
}

/// Interceptor which produces mock responses based on a list of rules
pub struct MockResponseInterceptor {
    rules: Arc<Mutex<VecDeque<Rule>>>,
    rule_mode: RuleMode,
    must_match: bool,
    active_response: Arc<Mutex<Option<MockResponse<Output, Error>>>>,
}

impl fmt::Debug for MockResponseInterceptor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} rules", self.rules.lock().unwrap().len())
    }
}

impl Default for MockResponseInterceptor {
    fn default() -> Self {
        Self::new()
    }
}

impl MockResponseInterceptor {
    /// Create a new [MockResponseInterceptor]
    ///
    /// This is normally created and registered on a client through the [`mock_client`] macro.
    pub fn new() -> Self {
        Self {
            rules: Default::default(),
            rule_mode: RuleMode::MatchAny,
            must_match: true,
            active_response: Default::default(),
        }
    }
    /// Add a rule to the Interceptor
    ///
    /// Rules are matched in orderâ€”this rule will only apply if all previous rules do not match.
    pub fn with_rule(self, rule: &Rule) -> Self {
        self.rules.lock().unwrap().push_back(rule.clone());
        self
    }

    /// Set the RuleMode to use when evaluating rules.
    ///
    /// See `RuleMode` enum for modes and how they are applied.
    pub fn rule_mode(mut self, rule_mode: RuleMode) -> Self {
        self.rule_mode = rule_mode;
        self
    }

    /// Allow passthrough for unmatched requests.
    ///
    /// By default, if a request doesn't match any rule, the interceptor will panic.
    /// This method allows unmatched requests to pass through.
    pub fn allow_passthrough(mut self) -> Self {
        self.must_match = false;
        self
    }
}

impl Intercept for MockResponseInterceptor {
    fn name(&self) -> &'static str {
        "MockResponseInterceptor"
    }

    fn modify_before_serialization(
        &self,
        context: &mut BeforeSerializationInterceptorContextMut<'_>,
        _runtime_components: &RuntimeComponents,
        cfg: &mut ConfigBag,
    ) -> Result<(), BoxError> {
        let mut rules = self.rules.lock().unwrap();
        let input = context.inner().input().expect("input set");

        // Find a matching rule and get its response
        let mut matching_rule = None;
        let mut matching_response = None;

        match self.rule_mode {
            RuleMode::Sequential => {
                // Try rules in order until we find one that matches and has a response
                let mut i = 0;
                while i < rules.len() && matching_response.is_none() {
                    let rule = &rules[i];
                    if !(rule.matcher)(input) {
                        // Rule doesn't match, this is an error in sequential mode
                        panic!(
                            "In order matching was enforced but rule did not match {:?}",
                            input
                        );
                    }
                    // Get the next response
                    if let Some(response) = rule.next_response() {
                        matching_rule = Some(rule.clone());
                        matching_response = Some(response);
                    } else {
                        // Rule is exhausted, remove it and try the next one
                        rules.remove(i);
                        continue; // Don't increment i since we removed an element
                    }
                    i += 1;
                }
            }
            RuleMode::MatchAny => {
                // Find any matching rule with a response
                for rule in rules.iter() {
                    if (rule.matcher)(input) {
                        if let Some(response) = rule.next_response() {
                            matching_rule = Some(rule.clone());
                            matching_response = Some(response);
                            break;
                        }
                    }
                }
            }
        };

        match (matching_rule, matching_response) {
            (Some(rule), Some(response)) => {
                // Store the rule in the config bag
                cfg.interceptor_state().store_put(ActiveRule(rule));
                // store the response on the interceptor (because going
                // through interceptor context requires the type to impl Clone)
                let mut active_resp = self.active_response.lock().unwrap();
                let _ = std::mem::replace(&mut *active_resp, Some(response));
            }
            _ => {
                // No matching rule or no response
                if self.must_match {
                    panic!(
                        "must_match was enabled but no rules matched or all rules were exhausted for {:?}",
                        input
                    );
                }
            }
        }

        Ok(())
    }

    fn modify_before_transmit(
        &self,
        context: &mut BeforeTransmitInterceptorContextMut<'_>,
        _runtime_components: &RuntimeComponents,
        cfg: &mut ConfigBag,
    ) -> Result<(), BoxError> {
        let mut state = self.active_response.lock().unwrap();
        let mut active_response = (*state).take();
        if active_response.is_none() {
            // in the case of retries we try to get the next response if it has been consumed
            if let Some(active_rule) = cfg.load::<ActiveRule>() {
                let next_resp = active_rule.0.next_response();
                active_response = next_resp;
            }
        }

        if let Some(resp) = active_response {
            match resp {
                // place the http response into the extensions and let the HTTP client return it
                MockResponse::Http(http_resp) => {
                    context
                        .request_mut()
                        .add_extension(MockHttpResponse(Arc::new(http_resp)));
                }
                _ => {
                    // put it back for modeled output/errors
                    let _ = std::mem::replace(&mut *state, Some(resp));
                }
            }
        }

        Ok(())
    }

    fn modify_before_attempt_completion(
        &self,
        context: &mut FinalizerInterceptorContextMut<'_>,
        _runtime_components: &RuntimeComponents,
        _cfg: &mut ConfigBag,
    ) -> Result<(), BoxError> {
        // Handle modeled responses
        let mut state = self.active_response.lock().unwrap();
        let active_response = (*state).take();
        if let Some(resp) = active_response {
            match resp {
                MockResponse::Output(output) => {
                    context.inner_mut().set_output_or_error(Ok(output));
                }
                MockResponse::Error(error) => {
                    context
                        .inner_mut()
                        .set_output_or_error(Err(OrchestratorError::operation(error)));
                }
                MockResponse::Http(_) => {
                    // HTTP responses are handled by the mock HTTP client
                }
            }
        }

        Ok(())
    }
}

/// Extension for storing mock HTTP responses in request extensions
#[derive(Clone)]
struct MockHttpResponse(Arc<HttpResponse>);

/// Create a mock HTTP client that works with the interceptor using existing utilities
pub fn create_mock_http_client() -> SharedHttpClient {
    infallible_client_fn(|mut req| {
        // Try to get the mock HTTP response generator from the extensions
        if let Some(mock_response) = req.extensions_mut().remove::<MockHttpResponse>() {
            let http_resp =
                Arc::try_unwrap(mock_response.0).expect("mock HTTP response has single reference");
            return http_resp.try_into_http1x().unwrap();
        }

        // Default dummy response if no mock response is defined
        http::Response::builder()
            .status(418)
            .body(SdkBody::from("Mock HTTP client dummy response"))
            .unwrap()
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use aws_smithy_async::rt::sleep::{SharedAsyncSleep, TokioSleep};
    use aws_smithy_runtime::client::orchestrator::operation::Operation;
    use aws_smithy_runtime::client::retries::classifiers::HttpStatusCodeClassifier;
    use aws_smithy_runtime_api::client::orchestrator::{HttpRequest, HttpResponse};
    use aws_smithy_runtime_api::client::result::SdkError;
    use aws_smithy_runtime_api::http::StatusCode;
    use aws_smithy_types::body::SdkBody;
    use aws_smithy_types::retry::RetryConfig;
    use aws_smithy_types::timeout::TimeoutConfig;

    use std::time::Duration;

    // Simple test input and output types
    #[derive(Debug)]
    struct TestInput {
        bucket: String,
        key: String,
    }
    impl TestInput {
        fn new(bucket: &str, key: &str) -> Self {
            Self {
                bucket: bucket.to_string(),
                key: key.to_string(),
            }
        }
    }

    #[derive(Debug, PartialEq)]
    struct TestOutput {
        content: String,
    }

    impl TestOutput {
        fn new(content: &str) -> Self {
            Self {
                content: content.to_string(),
            }
        }
    }

    #[derive(Debug)]
    struct TestError {
        message: String,
    }

    impl TestError {
        fn new(message: &str) -> Self {
            Self {
                message: message.to_string(),
            }
        }
    }

    impl std::fmt::Display for TestError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{}", self.message)
        }
    }

    impl std::error::Error for TestError {}

    // Helper function to create a RuleBuilder with proper type hints
    fn create_rule_builder() -> RuleBuilder<TestInput, TestOutput, TestError> {
        RuleBuilder::new_from_mock(
            || TestInput {
                bucket: "".to_string(),
                key: "".to_string(),
            },
            || {
                let fut: std::future::Ready<Result<TestOutput, SdkError<TestError, HttpResponse>>> =
                    std::future::ready(Ok(TestOutput {
                        content: "".to_string(),
                    }));
                fut
            },
        )
    }

    // Helper function to create an Operation with common configuration
    fn create_test_operation(
        interceptor: MockResponseInterceptor,
        enable_retries: bool,
    ) -> Operation<TestInput, TestOutput, TestError> {
        let builder = Operation::builder()
            .service_name("test")
            .operation_name("test")
            .http_client(create_mock_http_client())
            .endpoint_url("http://localhost:1234")
            .no_auth()
            .sleep_impl(SharedAsyncSleep::new(TokioSleep::new()))
            .timeout_config(TimeoutConfig::disabled())
            .interceptor(interceptor)
            .serializer(|input: TestInput| {
                let mut request = HttpRequest::new(SdkBody::empty());
                request
                    .set_uri(format!("/{}/{}", input.bucket, input.key))
                    .expect("valid URI");
                Ok(request)
            })
            .deserializer::<TestOutput, TestError>(|response| {
                if response.status().is_success() {
                    let body = std::str::from_utf8(response.body().bytes().unwrap())
                        .unwrap_or("empty body")
                        .to_string();
                    Ok(TestOutput { content: body })
                } else {
                    Err(OrchestratorError::operation(TestError {
                        message: format!("Error: {}", response.status()),
                    }))
                }
            });

        if enable_retries {
            let retry_config = RetryConfig::standard()
                .with_max_attempts(5)
                .with_initial_backoff(Duration::from_millis(1))
                .with_max_backoff(Duration::from_millis(5));

            builder
                .retry_classifier(HttpStatusCodeClassifier::default())
                .standard_retry(&retry_config)
                .build()
        } else {
            builder.no_retry().build()
        }
    }

    #[tokio::test]
    async fn test_retry_serve() {
        // Create a rule with repeated error responses followed by success
        let rule = create_rule_builder()
            .match_requests(|input| input.bucket == "test-bucket" && input.key == "test-key")
            .serve(|idx| match idx {
                0 | 1 => Some(mock_response!(status: 503)),
                2 => Some(mock_response!(TestOutput::new("success after retries"))),
                _ => None,
            });

        // Create an interceptor with the rule
        let interceptor = MockResponseInterceptor::new()
            .rule_mode(RuleMode::Sequential)
            .with_rule(&rule);

        let operation = create_test_operation(interceptor, true);

        // Make a single request - it should automatically retry through the sequence
        let result = operation
            .invoke(TestInput::new("test-bucket", "test-key"))
            .await;

        // Should succeed with the final output after retries
        assert!(
            result.is_ok(),
            "Expected success but got error: {:?}",
            result.err()
        );
        assert_eq!(
            result.unwrap(),
            TestOutput {
                content: "success after retries".to_string()
            }
        );

        // Verify the rule was used the expected number of times (all 4 responses: 2 errors + 1 success)
        assert_eq!(rule.num_calls(), 3);
    }

    #[should_panic(
        expected = "must_match was enabled but no rules matched or all rules were exhausted for"
    )]
    #[tokio::test]
    async fn test_exhausted_rules() {
        // Create a rule with a single response
        let rule = create_rule_builder().then_output(|| TestOutput::new("only response"));

        // Create an interceptor with the rule
        let interceptor = MockResponseInterceptor::new()
            .rule_mode(RuleMode::Sequential)
            .with_rule(&rule);

        let operation = create_test_operation(interceptor, false);

        // First call should succeed
        let result1 = operation
            .invoke(TestInput::new("test-bucket", "test-key"))
            .await;
        assert!(result1.is_ok());

        // Second call should panic because the rules are exhausted
        let _result2 = operation
            .invoke(TestInput::new("test-bucket", "test-key"))
            .await;
    }

    #[tokio::test]
    async fn test_rule_mode_match_any() {
        // Create two rules with different matchers
        let rule1 = create_rule_builder()
            .match_requests(|input| input.bucket == "bucket1")
            .then_output(|| TestOutput::new("response1"));

        let rule2 = create_rule_builder()
            .match_requests(|input| input.bucket == "bucket2")
            .then_output(|| TestOutput::new("response2"));

        // Create an interceptor with both rules in MatchAny mode
        let interceptor = MockResponseInterceptor::new()
            .rule_mode(RuleMode::MatchAny)
            .with_rule(&rule1)
            .with_rule(&rule2);

        let operation = create_test_operation(interceptor, false);

        // Call with bucket1 should match rule1
        let result1 = operation
            .invoke(TestInput::new("bucket1", "test-key"))
            .await;
        assert!(result1.is_ok());
        assert_eq!(result1.unwrap(), TestOutput::new("response1"));

        // Call with bucket2 should match rule2
        let result2 = operation
            .invoke(TestInput::new("bucket2", "test-key"))
            .await;
        assert!(result2.is_ok());
        assert_eq!(result2.unwrap(), TestOutput::new("response2"));

        // Verify the rules were used the expected number of times
        assert_eq!(rule1.num_calls(), 1);
        assert_eq!(rule2.num_calls(), 1);
    }

    #[tokio::test]
    async fn test_mixed_response_types() {
        // Create a rule with all three types of responses
        let rule = create_rule_builder().serve(|idx| match idx {
            0 => Some(mock_response!(TestOutput::new("first output"))),
            1 => Some(mock_response!(error: TestError::new("expected error"))),
            2 => Some(mock_response!(http: HttpResponse::new(
                StatusCode::try_from(200).unwrap(),
                SdkBody::from("http response")
            ))),
            _ => None,
        });

        // Create an interceptor with the rule
        let interceptor = MockResponseInterceptor::new()
            .rule_mode(RuleMode::Sequential)
            .with_rule(&rule);

        let operation = create_test_operation(interceptor, false);

        // First call should return the modeled output
        let result1 = operation
            .invoke(TestInput::new("test-bucket", "test-key"))
            .await;
        assert!(result1.is_ok());
        assert_eq!(result1.unwrap(), TestOutput::new("first output"));

        // Second call should return the modeled error
        let result2 = operation
            .invoke(TestInput::new("test-bucket", "test-key"))
            .await;
        assert!(result2.is_err());
        let sdk_err = result2.unwrap_err();
        let err = sdk_err.as_service_error().expect("expected service error");
        assert_eq!(err.to_string(), "expected error");

        // Third call should return the HTTP response
        let result3 = operation
            .invoke(TestInput::new("test-bucket", "test-key"))
            .await;
        assert!(result3.is_ok());
        assert_eq!(result3.unwrap(), TestOutput::new("http response"));

        // Verify the rule was used the expected number of times
        assert_eq!(rule.num_calls(), 3);
    }

    #[tokio::test]
    async fn test_exhausted_sequence() {
        // Create a rule with a sequence that will be exhausted
        let rule = create_rule_builder().serve(|idx| match idx {
            0 => Some(mock_response!(TestOutput::new("response 1"))),
            1 => Some(mock_response!(TestOutput::new("response 2"))),
            _ => None,
        });

        // Create another rule to use after the first one is exhausted
        let fallback_rule =
            create_rule_builder().then_output(|| TestOutput::new("fallback response"));

        // Create an interceptor with both rules
        let interceptor = MockResponseInterceptor::new()
            .rule_mode(RuleMode::Sequential)
            .with_rule(&rule)
            .with_rule(&fallback_rule);

        let operation = create_test_operation(interceptor, false);

        // First two calls should use the first rule
        let result1 = operation
            .invoke(TestInput::new("test-bucket", "test-key"))
            .await;
        assert!(result1.is_ok());
        assert_eq!(result1.unwrap(), TestOutput::new("response 1"));

        let result2 = operation
            .invoke(TestInput::new("test-bucket", "test-key"))
            .await;
        assert!(result2.is_ok());
        assert_eq!(result2.unwrap(), TestOutput::new("response 2"));

        // Third call should use the fallback rule
        let result3 = operation
            .invoke(TestInput::new("test-bucket", "test-key"))
            .await;
        assert!(result3.is_ok());
        assert_eq!(result3.unwrap(), TestOutput::new("fallback response"));

        // Verify the rules were used the expected number of times
        assert_eq!(rule.num_calls(), 2);
        assert_eq!(fallback_rule.num_calls(), 1);
    }

    #[tokio::test]
    async fn test_concurrent_usage() {
        use std::sync::Arc;
        use tokio::task;

        // Create a rule with multiple responses
        let rule = Arc::new(create_rule_builder().serve(|idx| match idx {
            0 => Some(mock_response!(TestOutput::new("response 1"))),
            1 => Some(mock_response!(TestOutput::new("response 2"))),
            2 => Some(mock_response!(TestOutput::new("response 3"))),
            _ => None,
        }));

        // Create an interceptor with the rule
        let interceptor = MockResponseInterceptor::new()
            .rule_mode(RuleMode::Sequential)
            .with_rule(&rule);

        let operation = Arc::new(create_test_operation(interceptor, false));

        // Spawn multiple tasks that use the operation concurrently
        let mut handles = vec![];
        for i in 0..3 {
            let op = operation.clone();
            let handle = task::spawn(async move {
                let result = op
                    .invoke(TestInput::new(&format!("bucket-{}", i), "test-key"))
                    .await;
                result.unwrap()
            });
            handles.push(handle);
        }

        // Wait for all tasks to complete
        let mut results = vec![];
        for handle in handles {
            results.push(handle.await.unwrap());
        }

        // Sort the results to make the test deterministic
        results.sort_by(|a, b| a.content.cmp(&b.content));

        // Verify we got all three responses
        assert_eq!(results.len(), 3);
        assert_eq!(results[0], TestOutput::new("response 1"));
        assert_eq!(results[1], TestOutput::new("response 2"));
        assert_eq!(results[2], TestOutput::new("response 3"));

        // Verify the rule was used the expected number of times
        assert_eq!(rule.num_calls(), 3);
    }
}
